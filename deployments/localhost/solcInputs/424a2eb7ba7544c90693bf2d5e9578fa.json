{
  "language": "Solidity",
  "sources": {
    "contracts/AggregatorV2V3Interface.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\n/**\r\n * @title The V2 & V3 Aggregator Interface\r\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\r\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\r\n * and v0.5 AggregatorV3Interface.sol.\r\n */\r\ninterface AggregatorV2V3Interface {\r\n  //\r\n  // V2 Interface:\r\n  //\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\r\n\r\n  //\r\n  // V3 Interface:\r\n  //\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n"
    },
    "contracts/BEP20Interface.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\ninterface BEP20Interface {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token decimals.\r\n   */\r\n  function decimals() external view returns (uint8);\r\n\r\n  /**\r\n   * @dev Returns the token symbol.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n  * @dev Returns the token name.\r\n  */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the bep token owner.\r\n   */\r\n  function getOwner() external view returns (address);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
    },
    "contracts/CarefulMath.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/**\r\n  * @title Careful Math\r\n  * @author Venus\r\n  * @notice Derived from OpenZeppelin's SafeMath library\r\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n  */\r\ncontract CarefulMath {\r\n\r\n    /**\r\n     * @dev Possible error codes that we can return\r\n     */\r\n    enum MathError {\r\n        NO_ERROR,\r\n        DIVISION_BY_ZERO,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, returns an error on overflow.\r\n    */\r\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (a == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        uint c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (MathError.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b == 0) {\r\n            return (MathError.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        if (b <= a) {\r\n            return (MathError.NO_ERROR, a - b);\r\n        } else {\r\n            return (MathError.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, returns an error on overflow.\r\n    */\r\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\r\n        uint c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (MathError.NO_ERROR, c);\r\n        } else {\r\n            return (MathError.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev add a and b and then subtract c\r\n    */\r\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\r\n        (MathError err0, uint sum) = addUInt(a, b);\r\n\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return subUInt(sum, c);\r\n    }\r\n}"
    },
    "contracts/Comptroller.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\nimport \"./Unitroller.sol\";\r\nimport \"./Governance/XVS.sol\";\r\nimport \"./VAI/VAI.sol\";\r\nimport \"./ComptrollerLensInterface.sol\";\r\nimport \"./IAccessControlManager.sol\";\r\n// import \"hardhat/console.sol\";\r\n\r\n\r\n/**\r\n * @title Venus's Comptroller Contract\r\n * @author Venus\r\n */\r\ncontract Comptroller is ComptrollerV9Storage, ComptrollerInterfaceG2, ComptrollerErrorReporter, ExponentialNoError {\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketListed(VToken vToken);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\r\n\r\n    /// @notice Emitted when a collateral factor is changed by admin\r\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\r\n\r\n    /// @notice Emitted when price oracle is changed\r\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\r\n\r\n    /// @notice Emitted when VAI Vault info is changed\r\n    event NewVAIVaultInfo(address vault_, uint releaseStartBlock_, uint releaseInterval_);\r\n\r\n    /// @notice Emitted when pause guardian is changed\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    /// @notice Emitted when an action is paused on a market\r\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\r\n\r\n    /// @notice Emitted when Venus VAI Vault rate is changed\r\n    event NewVenusVAIVaultRate(uint oldVenusVAIVaultRate, uint newVenusVAIVaultRate);\r\n\r\n    /// @notice Emitted when a new Venus speed is calculated for a market\r\n    event VenusSpeedUpdated(VToken indexed vToken, uint newSpeed);\r\n\r\n    /// @notice Emitted when XVS is distributed to a supplier\r\n    event DistributedSupplierVenus(VToken indexed vToken, address indexed supplier, uint venusDelta, uint venusSupplyIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a borrower\r\n    event DistributedBorrowerVenus(VToken indexed vToken, address indexed borrower, uint venusDelta, uint venusBorrowIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to VAI Vault\r\n    event DistributedVAIVaultVenus(uint amount);\r\n\r\n    /// @notice Emitted when VAIController is changed\r\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\r\n\r\n    /// @notice Emitted when VAI mint rate is changed by admin\r\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\r\n\r\n    /// @notice Emitted when protocol state is changed by admin\r\n    event ActionProtocolPaused(bool state);\r\n\r\n    /// @notice Emitted when borrow cap for a vToken is changed\r\n    event NewBorrowCap(VToken indexed vToken, uint newBorrowCap);\r\n\r\n    /// @notice Emitted when treasury guardian is changed\r\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\r\n\r\n    /// @notice Emitted when treasury address is changed\r\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\r\n\r\n    /// @notice Emitted when treasury percent is changed\r\n    event NewTreasuryPercent(uint oldTreasuryPercent, uint newTreasuryPercent);\r\n\r\n    // @notice Emitted when liquidator adress is changed\r\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\r\n\r\n    /// @notice Emitted when Venus is granted by admin\r\n    event VenusGranted(address recipient, uint amount);\r\n\r\n    /// @notice Emitted whe ComptrollerLens address is changed\r\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\r\n\r\n    /// @notice Emitted when supply cap for a vToken is changed\r\n    event NewSupplyCap(VToken indexed vToken, uint newSupplyCap);\r\n\r\n    /// @notice Emitted when access control address is changed by admin\r\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\r\n\r\n    /// @notice The initial Venus index for a market\r\n    uint224 public constant venusInitialIndex = 1e36;\r\n\r\n    // closeFactorMantissa must be strictly greater than this value\r\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n    // closeFactorMantissa must not exceed this value\r\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // No collateralFactorMantissa may exceed this value\r\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /// @notice Reverts if the protocol is paused\r\n    function checkProtocolPauseState() private view {\r\n        require(!protocolPaused, \"protocol is paused\");\r\n    }\r\n\r\n    /// @notice Reverts if a certain action is paused on a market\r\n    function checkActionPauseState(address market, Action action) private view {\r\n        require(!actionPaused(market, action), \"action is paused\");\r\n    }\r\n\r\n    /// @notice Reverts if the caller is not admin\r\n    function ensureAdmin() private view {\r\n        require(msg.sender == admin, \"only admin can\");\r\n    }\r\n\r\n    /// @notice Checks the passed address is nonzero\r\n    function ensureNonzeroAddress(address someone) private pure {\r\n        require(someone != address(0), \"can't be zero address\");\r\n    }\r\n\r\n    /// @notice Reverts if the market is not listed\r\n    function ensureListed(Market storage market) private view {\r\n        require(market.isListed, \"market not listed\");\r\n    }\r\n\r\n    /// @notice Reverts if the caller is neither admin nor the passed address\r\n    function ensureAdminOr(address privilegedAddress) private view {\r\n        require(\r\n            msg.sender == admin || msg.sender == privilegedAddress,\r\n            \"access denied\"\r\n        );\r\n    }\r\n\r\n    function ensureAllowed(string memory functionSig) private view {\r\n        require(\r\n            IAccessControlManager(accessControl).isAllowedToCall(msg.sender, functionSig),\r\n            \"access denied\"\r\n        );\r\n    }\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\r\n        return accountAssets[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account is entered in the given asset\r\n     * @param account The address of the account to check\r\n     * @param vToken The vToken to check\r\n     * @return True if the account is in the asset, otherwise false.\r\n     */\r\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\r\n        return markets[address(vToken)].accountMembership[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add assets to be included in account liquidity calculation\r\n     * @param vTokens The list of addresses of the vToken markets to be enabled\r\n     * @return Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory) {\r\n        uint len = vTokens.length;\r\n\r\n        uint[] memory results = new uint[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            results[i] = uint(addToMarketInternal(VToken(vTokens[i]), msg.sender));\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n     * @param vToken The market to enter\r\n     * @param borrower The address of the account to modify\r\n     * @return Success indicator for whether the market was entered\r\n     */\r\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\r\n        checkActionPauseState(address(vToken), Action.ENTER_MARKET);\r\n\r\n        Market storage marketToJoin = markets[address(vToken)];\r\n        ensureListed(marketToJoin);\r\n\r\n        if (marketToJoin.accountMembership[borrower]) {\r\n            // already joined\r\n            return Error.NO_ERROR;\r\n        }\r\n\r\n        // survived the gauntlet, add to list\r\n        // NOTE: we store these somewhat redundantly as a significant optimization\r\n        //  this avoids having to iterate through the list for the most common use cases\r\n        //  that is, only when we need to perform liquidity checks\r\n        //  and not whenever we want to check if an account is in a particular market\r\n        marketToJoin.accountMembership[borrower] = true;\r\n        accountAssets[borrower].push(vToken);\r\n\r\n        emit MarketEntered(vToken, borrower);\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes asset from sender's account liquidity calculation\r\n     * @dev Sender must not have an outstanding borrow balance in the asset,\r\n     *  or be providing necessary collateral for an outstanding borrow.\r\n     * @param vTokenAddress The address of the asset to be removed\r\n     * @return Whether or not the account successfully exited the market\r\n     */\r\n    function exitMarket(address vTokenAddress) external returns (uint) {\r\n        checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\r\n\r\n        VToken vToken = VToken(vTokenAddress);\r\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\r\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\r\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\r\n\r\n        /* Fail if the sender has a borrow balance */\r\n        if (amountOwed != 0) {\r\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\r\n        }\r\n\r\n        /* Fail if the sender is not permitted to redeem all of their tokens */\r\n        uint allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\r\n        }\r\n\r\n        Market storage marketToExit = markets[address(vToken)];\r\n\r\n        /* Return true if the sender is not already ‘in’ the market */\r\n        if (!marketToExit.accountMembership[msg.sender]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Set vToken account membership to false */\r\n        delete marketToExit.accountMembership[msg.sender];\r\n\r\n        /* Delete vToken from the account’s list of assets */\r\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\r\n        VToken[] storage userAssetList = accountAssets[msg.sender];\r\n        uint len = userAssetList.length;\r\n        uint i;\r\n        for (; i < len; i++) {\r\n            if (userAssetList[i] == vToken) {\r\n                userAssetList[i] = userAssetList[len - 1];\r\n                userAssetList.length--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // We *must* have found the asset in the list or our redundant data structure is broken\r\n        assert(i < len);\r\n\r\n        emit MarketExited(vToken, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to mint tokens in the given market\r\n     * @param vToken The market to verify the mint against\r\n     * @param minter The account which would get the minted tokens\r\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function mintAllowed(address vToken, address minter, uint mintAmount) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        checkProtocolPauseState();\r\n        checkActionPauseState(vToken, Action.MINT);\r\n\r\n        // Shh - currently unused\r\n        mintAmount;\r\n\r\n        ensureListed(markets[vToken]);\r\n\r\n        uint256 supplyCap = supplyCaps[vToken];\r\n\r\n        // Supply cap of 0 corresponds to Minting notAllowed\r\n        require(supplyCap != 0, \"market supply cap is 0\");\r\n\r\n        uint256 vTokenSupply = VToken(vToken).totalSupply();\r\n        Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\r\n        uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\r\n        require(nextTotalSupply <= supplyCap, \"market supply cap reached\");\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, minter);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates mint and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being minted\r\n     * @param minter The address minting the tokens\r\n     * @param actualMintAmount The amount of the underlying asset being minted\r\n     * @param mintTokens The number of tokens being minted\r\n     */\r\n    function mintVerify(address vToken, address minter, uint actualMintAmount, uint mintTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        minter;\r\n        actualMintAmount;\r\n        mintTokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n     * @param vToken The market to verify the redeem against\r\n     * @param redeemer The account which would redeem the tokens\r\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\r\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external returns (uint) {\r\n        checkProtocolPauseState();\r\n        checkActionPauseState(vToken, Action.REDEEM);\r\n\r\n        uint allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, redeemer);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function redeemAllowedInternal(address vToken, address redeemer, uint redeemTokens) internal view returns (uint) {\r\n        ensureListed(markets[vToken]);\r\n\r\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n        if (!markets[vToken].accountMembership[redeemer]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, VToken(vToken), redeemTokens, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates redeem and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being redeemed\r\n     * @param redeemer The address redeeming the tokens\r\n     * @param redeemAmount The amount of the underlying asset being redeemed\r\n     * @param redeemTokens The number of tokens being redeemed\r\n     */\r\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        redeemer;\r\n\r\n        // Require tokens is zero or amount is also zero\r\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param vToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        checkProtocolPauseState();\r\n        checkActionPauseState(vToken, Action.BORROW);\r\n\r\n        ensureListed(markets[vToken]);\r\n\r\n        if (!markets[vToken].accountMembership[borrower]) {\r\n            // only vTokens may call borrowAllowed if borrower not in market\r\n            require(msg.sender == vToken, \"sender must be vToken\");\r\n\r\n            // attempt to add borrower to the market\r\n            Error err = addToMarketInternal(VToken(vToken), borrower);\r\n            if (err != Error.NO_ERROR) {\r\n                return uint(err);\r\n            }\r\n        }\r\n\r\n        if (oracle.getUnderlyingPrice(VToken(vToken)) == 0) {\r\n            return uint(Error.PRICE_ERROR);\r\n        }\r\n\r\n        uint borrowCap = borrowCaps[vToken];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint totalBorrows = VToken(vToken).totalBorrows();\r\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(vToken), 0, borrowAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates borrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset whose underlying is being borrowed\r\n     * @param borrower The address borrowing the underlying\r\n     * @param borrowAmount The amount of the underlying asset requested to borrow\r\n     */\r\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        borrower;\r\n        borrowAmount;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n     * @param vToken The market to verify the repay against\r\n     * @param payer The account which would repay the asset\r\n     * @param borrower The account which borrowed the asset\r\n     * @param repayAmount The amount of the underlying asset the account would repay\r\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function repayBorrowAllowed(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount\r\n    )\r\n        external\r\n        returns (uint)\r\n    {\r\n        checkProtocolPauseState();\r\n        checkActionPauseState(vToken, Action.REPAY);\r\n        // Shh - currently unused\r\n        payer;\r\n        borrower;\r\n        repayAmount;\r\n\r\n        ensureListed(markets[vToken]);\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being repaid\r\n     * @param payer The address repaying the borrow\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function repayBorrowVerify(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint borrowerIndex\r\n    )\r\n        external\r\n    {\r\n        // Shh - currently unused\r\n        vToken;\r\n        payer;\r\n        borrower;\r\n        actualRepayAmount;\r\n        borrowerIndex;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the liquidation should be allowed to occur\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param repayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowAllowed(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount\r\n    )\r\n        external\r\n        returns (uint)\r\n    {\r\n        checkProtocolPauseState();\r\n\r\n        // if we want to pause liquidating to vTokenCollateral, we should pause seizing\r\n        checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\r\n\r\n        if (liquidatorContract != address(0) && liquidator != liquidatorContract) {\r\n            return uint(Error.UNAUTHORIZED);\r\n        }\r\n\r\n        ensureListed(markets[vTokenCollateral]);\r\n        if (address(vTokenBorrowed) != address(vaiController)) {\r\n            ensureListed(markets[vTokenBorrowed]);\r\n        }\r\n\r\n        /* The borrower must have shortfall in order to be liquidatable */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(0), 0, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall == 0) {\r\n            return uint(Error.INSUFFICIENT_SHORTFALL);\r\n        }\r\n\r\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n        uint borrowBalance;\r\n        if (address(vTokenBorrowed) != address(vaiController)) {\r\n            borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\r\n        } else {\r\n            borrowBalance = mintedVAIs[borrower];\r\n        }\r\n        uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\r\n        if (repayAmount > maxClose) {\r\n            return uint(Error.TOO_MUCH_REPAY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     * @param seizeTokens The amount of collateral token that will be seized\r\n     */\r\n    function liquidateBorrowVerify(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint seizeTokens\r\n    )\r\n        external\r\n    {\r\n        // Shh - currently unused\r\n        vTokenBorrowed;\r\n        vTokenCollateral;\r\n        liquidator;\r\n        borrower;\r\n        actualRepayAmount;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the seizing of assets should be allowed to occur\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeAllowed(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens\r\n    )\r\n        external\r\n        returns (uint)\r\n    {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        checkProtocolPauseState();\r\n        checkActionPauseState(vTokenCollateral, Action.SEIZE);\r\n\r\n        // Shh - currently unused\r\n        seizeTokens;\r\n\r\n        // We've added VAIController as a borrowed token list check for seize\r\n        ensureListed(markets[vTokenCollateral]);\r\n        if (address(vTokenBorrowed) != address(vaiController)) {\r\n            ensureListed(markets[vTokenBorrowed]);\r\n        }\r\n\r\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\r\n            return uint(Error.COMPTROLLER_MISMATCH);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vTokenCollateral);\r\n        distributeSupplierVenus(vTokenCollateral, borrower);\r\n        distributeSupplierVenus(vTokenCollateral, liquidator);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates seize and reverts on rejection. May emit logs.\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeVerify(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens\r\n    )\r\n        external\r\n    {\r\n        // Shh - currently unused\r\n        vTokenCollateral;\r\n        vTokenBorrowed;\r\n        liquidator;\r\n        borrower;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n     * @param vToken The market to verify the transfer against\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        checkProtocolPauseState();\r\n        checkActionPauseState(vToken, Action.TRANSFER);\r\n\r\n        // Currently the only consideration is whether or not\r\n        //  the src is allowed to redeem this many tokens\r\n        uint allowed = redeemAllowedInternal(vToken, src, transferTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, src);\r\n        distributeSupplierVenus(vToken, dst);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates transfer and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being transferred\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     */\r\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        src;\r\n        dst;\r\n        transferTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code (semi-opaque),\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(0), 0, 0);\r\n\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidity(\r\n        address account,\r\n        address vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount\r\n    )\r\n        public\r\n        view\r\n        returns (uint, uint, uint)\r\n    {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(\r\n            account,\r\n            VToken(vTokenModify),\r\n            redeemTokens,\r\n            borrowAmount\r\n        );\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\r\n     *  without calculating accumulated interest.\r\n     * @return (possible error code,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidityInternal(\r\n        address account,\r\n        VToken vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount\r\n    )\r\n        internal\r\n        view\r\n        returns (Error, uint, uint)\r\n    {\r\n        (uint err, uint liquidity, uint shortfall) = comptrollerLens.getHypotheticalAccountLiquidity(\r\n            address(this),\r\n            account,\r\n            vTokenModify,\r\n            redeemTokens,\r\n            borrowAmount\r\n        );\r\n        return (Error(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\r\n     * @param vTokenBorrowed The address of the borrowed vToken\r\n     * @param vTokenCollateral The address of the collateral vToken\r\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\r\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateCalculateSeizeTokens(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        uint actualRepayAmount\r\n    )\r\n        external\r\n        view\r\n        returns (uint, uint)\r\n    {\r\n        (uint err, uint seizeTokens) = comptrollerLens.liquidateCalculateSeizeTokens(\r\n            address(this),\r\n            vTokenBorrowed,\r\n            vTokenCollateral,\r\n            actualRepayAmount\r\n        );\r\n        return (err, seizeTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\r\n     * @param vTokenCollateral The address of the collateral vToken\r\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\r\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateVAICalculateSeizeTokens(\r\n        address vTokenCollateral,\r\n        uint actualRepayAmount\r\n    )\r\n        external\r\n        view\r\n        returns (uint, uint)\r\n    {\r\n        (uint err, uint seizeTokens) = comptrollerLens.liquidateVAICalculateSeizeTokens(\r\n            address(this),\r\n            vTokenCollateral,\r\n            actualRepayAmount\r\n        );\r\n        return (err, seizeTokens);\r\n    }\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new price oracle for the comptroller\r\n      * @dev Admin function to set a new price oracle\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPriceOracle(PriceOracle newOracle) external returns (uint) {\r\n        // Check caller is admin\r\n        ensureAdmin();\r\n        ensureNonzeroAddress(address(newOracle));\r\n\r\n        // Track the old oracle for the comptroller\r\n        PriceOracle oldOracle = oracle;\r\n\r\n        // Set comptroller's oracle to newOracle\r\n        oracle = newOracle;\r\n\r\n        // Emit NewPriceOracle(oldOracle, newOracle)\r\n        emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the closeFactor used when liquidating borrows\r\n      * @dev Admin function to set closeFactor\r\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise will revert\r\n      */\r\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        ensureAdmin();\r\n\r\n        uint oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = newCloseFactorMantissa;\r\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n     /**\r\n      * @notice Sets the address of the access control of this contract\r\n      * @dev Admin function to set the access control address\r\n      * @param newAccessControlAddress New address for the access control\r\n      * @return uint 0=success, otherwise will revert\r\n      */\r\n    function _setAccessControl(address newAccessControlAddress) external returns (uint) {\r\n        // Check caller is admin\r\n        ensureAdmin();\r\n        ensureNonzeroAddress(newAccessControlAddress);\r\n\r\n        address oldAccessControlAddress = accessControl;\r\n        accessControl = newAccessControlAddress;\r\n        emit NewAccessControl(oldAccessControlAddress, accessControl);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the collateralFactor for a market\r\n      * @dev Restricted function to set per-market collateralFactor\r\n      * @param vToken The market to set the factor on\r\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\r\n        // Check caller is allowed by access control manager\r\n        ensureAllowed(\"_setCollateralFactor(address,uint256)\");\r\n        ensureNonzeroAddress(address(vToken));\r\n\r\n        // Verify market is listed\r\n        Market storage market = markets[address(vToken)];\r\n        ensureListed(market);\r\n\r\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\r\n\r\n        // Check collateral factor <= 0.9\r\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\r\n        }\r\n\r\n        // If collateral factor != 0, fail if price == 0\r\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\r\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\r\n        }\r\n\r\n        // Set market's collateral factor to new collateral factor, remember old value\r\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n        // Emit event with asset, old collateral factor, and new collateral factor\r\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets liquidationIncentive\r\n      * @dev Admin function to set liquidationIncentive\r\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\r\n        ensureAllowed(\"_setLiquidationIncentive(uint256)\");\r\n\r\n        require(newLiquidationIncentiveMantissa >= 1e18, \"incentive must be over 1e18\");\r\n\r\n        // Save current value for use in log\r\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n        // Set liquidation incentive to new incentive\r\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n        // Emit event with old incentive, new incentive\r\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setLiquidatorContract(address newLiquidatorContract_) external {\r\n        // Check caller is admin\r\n        ensureAdmin();\r\n        address oldLiquidatorContract = liquidatorContract;\r\n        liquidatorContract = newLiquidatorContract_;\r\n        emit NewLiquidatorContract(oldLiquidatorContract, newLiquidatorContract_);\r\n    }\r\n\r\n    /**\r\n      * @notice Add the market to the markets mapping and set it as listed\r\n      * @dev Admin function to set isListed and add support for the market\r\n      * @param vToken The address of the market (token) to list\r\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n      */\r\n    function _supportMarket(VToken vToken) external returns (uint) {\r\n        // console.log('_supportMarket 1');\r\n        ensureAllowed(\"_supportMarket(address)\");\r\n\r\n        // console.log('_supportMarket 2');\r\n        if (markets[address(vToken)].isListed) {\r\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n        }\r\n\r\n        // console.log('_supportMarket 3');\r\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\r\n\r\n        // Note that isVenus is not in active use anymore\r\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\r\n        // console.log('_supportMarket 4');\r\n        _addMarketInternal(vToken);\r\n\r\n        emit MarketListed(vToken);\r\n        // console.log('_supportMarket end');\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _addMarketInternal(VToken vToken) internal {\r\n        for (uint i = 0; i < allMarkets.length; i++) {\r\n            require(allMarkets[i] != vToken, \"market already added\");\r\n        }\r\n        allMarkets.push(vToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Pause Guardian\r\n     * @param newPauseGuardian The address of the new Pause Guardian\r\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n     */\r\n    function _setPauseGuardian(address newPauseGuardian) external returns (uint) {\r\n        ensureAdmin();\r\n        ensureNonzeroAddress(newPauseGuardian);\r\n\r\n        // Save current value for inclusion in log\r\n        address oldPauseGuardian = pauseGuardian;\r\n\r\n        // Store pauseGuardian with value newPauseGuardian\r\n        pauseGuardian = newPauseGuardian;\r\n\r\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\r\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Set the given borrow caps for the given vToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\r\n      * @dev Access is controled by ACM. A borrow cap of 0 corresponds to unlimited borrowing.\r\n      * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\r\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\r\n      */\r\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint[] calldata newBorrowCaps) external {\r\n        ensureAllowed(\"_setMarketBorrowCaps(address[],uint256[])\");\r\n\r\n        uint numMarkets = vTokens.length;\r\n        uint numBorrowCaps = newBorrowCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\r\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @notice Set the given supply caps for the given vToken markets. Supply that brings total Supply to or above supply cap will revert.\r\n      * @dev Admin function to set the supply caps. A supply cap of 0 corresponds to Minting NotAllowed.\r\n      * @param vTokens The addresses of the markets (tokens) to change the supply caps for\r\n      * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed.\r\n      */\r\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\r\n        ensureAllowed(\"_setMarketSupplyCaps(address[],uint256[])\");\r\n\r\n        uint numMarkets = vTokens.length;\r\n        uint numSupplyCaps = newSupplyCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\r\n\r\n        for(uint i; i < numMarkets; ++i) {\r\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\r\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set whole protocol pause/unpause state\r\n     */\r\n    function _setProtocolPaused(bool state) external returns(bool) {\r\n        ensureAllowed(\"_setProtocolPaused(bool)\");\r\n\r\n        protocolPaused = state;\r\n        emit ActionProtocolPaused(state);\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * @notice Pause/unpause certain actions\r\n     * @param markets Markets to pause/unpause the actions on\r\n     * @param actions List of action ids to pause/unpause\r\n     * @param paused The new paused state (true=paused, false=unpaused)\r\n     */\r\n    function _setActionsPaused(\r\n        address[] calldata markets,\r\n        Action[] calldata actions,\r\n        bool paused\r\n    )\r\n        external\r\n    {\r\n        ensureAllowed(\"_setActionsPaused(address[],uint256[],bool)\");\r\n\r\n        uint256 numMarkets = markets.length;\r\n        uint256 numActions = actions.length;\r\n        for (uint marketIdx; marketIdx < numMarkets; ++marketIdx) {\r\n            for (uint actionIdx; actionIdx < numActions; ++actionIdx) {\r\n                setActionPausedInternal(markets[marketIdx], actions[actionIdx], paused);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Pause/unpause an action on a market\r\n     * @param market Market to pause/unpause the action on\r\n     * @param action Action id to pause/unpause\r\n     * @param paused The new paused state (true=paused, false=unpaused)\r\n     */\r\n    function setActionPausedInternal(address market, Action action, bool paused) internal {\r\n        ensureListed(markets[market]);\r\n        _actionPaused[market][uint(action)] = paused;\r\n        emit ActionPausedMarket(VToken(market), action, paused);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new VAI controller\r\n      * @dev Admin function to set a new VAI controller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\r\n        // Check caller is admin\r\n        ensureAdmin();\r\n        ensureNonzeroAddress(address(vaiController_));\r\n\r\n        VAIControllerInterface oldVaiController = vaiController;\r\n        vaiController = vaiController_;\r\n        emit NewVAIController(oldVaiController, vaiController_);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\r\n        // Check caller is admin\r\n        ensureAdmin();\r\n        uint oldVAIMintRate = vaiMintRate;\r\n        vaiMintRate = newVAIMintRate;\r\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setTreasuryData(address newTreasuryGuardian, address newTreasuryAddress, uint newTreasuryPercent) external returns (uint) {\r\n        // Check caller is admin\r\n        ensureAdminOr(treasuryGuardian);\r\n\r\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\r\n        ensureNonzeroAddress(newTreasuryGuardian);\r\n        ensureNonzeroAddress(newTreasuryAddress);\r\n\r\n        address oldTreasuryGuardian = treasuryGuardian;\r\n        address oldTreasuryAddress = treasuryAddress;\r\n        uint oldTreasuryPercent = treasuryPercent;\r\n\r\n        treasuryGuardian = newTreasuryGuardian;\r\n        treasuryAddress = newTreasuryAddress;\r\n        treasuryPercent = newTreasuryPercent;\r\n\r\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\r\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\r\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _become(Unitroller unitroller) external {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\r\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\r\n    }\r\n\r\n    /*** Venus Distribution ***/\r\n\r\n    function setVenusSpeedInternal(VToken vToken, uint venusSpeed) internal {\r\n        uint currentVenusSpeed = venusSpeeds[address(vToken)];\r\n        if (currentVenusSpeed != 0) {\r\n            // note that XVS speed could be set to 0 to halt liquidity rewards for a market\r\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n            updateVenusSupplyIndex(address(vToken));\r\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n        } else if (venusSpeed != 0) {\r\n            // Add the XVS market\r\n            ensureListed(markets[address(vToken)]);\r\n\r\n            if (venusSupplyState[address(vToken)].index == 0 && venusSupplyState[address(vToken)].block == 0) {\r\n                venusSupplyState[address(vToken)] = VenusMarketState({\r\n                    index: venusInitialIndex,\r\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n            }\r\n\r\n\r\n            if (venusBorrowState[address(vToken)].index == 0 && venusBorrowState[address(vToken)].block == 0) {\r\n                venusBorrowState[address(vToken)] = VenusMarketState({\r\n                    index: venusInitialIndex,\r\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n            }\r\n        }\r\n\r\n        if (currentVenusSpeed != venusSpeed) {\r\n            venusSpeeds[address(vToken)] = venusSpeed;\r\n            emit VenusSpeedUpdated(vToken, venusSpeed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set ComptrollerLens contract address\r\n     */\r\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external returns (uint) {\r\n        ensureAdmin();\r\n        ensureNonzeroAddress(address(comptrollerLens_));\r\n        address oldComptrollerLens = address(comptrollerLens);\r\n        comptrollerLens = comptrollerLens_;\r\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the supply index\r\n     * @param vToken The market whose supply index to update\r\n     */\r\n    function updateVenusSupplyIndex(address vToken) internal {\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        uint supplySpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\r\n        if (deltaBlocks > 0 && supplySpeed > 0) {\r\n            uint supplyTokens = VToken(vToken).totalSupply();\r\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\r\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\r\n            venusSupplyState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the borrow index\r\n     * @param vToken The market whose borrow index to update\r\n     */\r\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        uint borrowSpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\r\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\r\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\r\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\r\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\r\n            venusBorrowState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\r\n     * @param vToken The market in which the supplier is interacting\r\n     * @param supplier The address of the supplier to distribute XVS to\r\n     */\r\n    function distributeSupplierVenus(address vToken, address supplier) internal {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        VenusMarketState memory supplyState = venusSupplyState[vToken];\r\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\r\n        Double memory supplierIndex = Double({mantissa: venusSupplierIndex[vToken][supplier]});\r\n        venusSupplierIndex[vToken][supplier] = supplyIndex.mantissa;\r\n\r\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\r\n            supplierIndex.mantissa = venusInitialIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\r\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\r\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\r\n        uint supplierAccrued = add_(venusAccrued[supplier], supplierDelta);\r\n        venusAccrued[supplier] = supplierAccrued;\r\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\r\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vToken The market in which the borrower is interacting\r\n     * @param borrower The address of the borrower to distribute XVS to\r\n     */\r\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        VenusMarketState memory borrowState = venusBorrowState[vToken];\r\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\r\n        Double memory borrowerIndex = Double({mantissa: venusBorrowerIndex[vToken][borrower]});\r\n        venusBorrowerIndex[vToken][borrower] = borrowIndex.mantissa;\r\n\r\n        if (borrowerIndex.mantissa > 0) {\r\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\r\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\r\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\r\n            uint borrowerAccrued = add_(venusAccrued[borrower], borrowerDelta);\r\n            venusAccrued[borrower] = borrowerAccrued;\r\n            emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\r\n     * @param holder The address to claim XVS for\r\n     */\r\n    function claimVenus(address holder) public {\r\n        return claimVenus(holder, allMarkets);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in the specified markets\r\n     * @param holder The address to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     */\r\n    function claimVenus(address holder, VToken[] memory vTokens) public {\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = holder;\r\n        claimVenus(holders, vTokens, true, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all xvs accrued by the holders\r\n     * @param holders The addresses to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     * @param borrowers Whether or not to claim XVS earned by borrowing\r\n     * @param suppliers Whether or not to claim XVS earned by supplying\r\n     */\r\n     function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\r\n        claimVenus(holders, vTokens, borrowers, suppliers, false);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Claim all xvs accrued by the holders\r\n     * @param holders The addresses to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     * @param borrowers Whether or not to claim XVS earned by borrowing\r\n     * @param suppliers Whether or not to claim XVS earned by supplying\r\n     * @param collateral Whether or not to use XVS earned as collateral, only takes effect when the holder has a shortfall\r\n     */\r\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers, bool collateral) public {\r\n        uint j;\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            VToken vToken = vTokens[i];\r\n            ensureListed(markets[address(vToken)]);\r\n            if (borrowers) {\r\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\r\n                }\r\n            }\r\n            if (suppliers) {\r\n                updateVenusSupplyIndex(address(vToken));\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeSupplierVenus(address(vToken), holders[j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (j = 0; j < holders.length; j++) {\r\n            address holder = holders[j];\r\n            // If there is a positive shortfall, the XVS reward is accrued,\r\n            // but won't be granted to this holder\r\n            (, , uint shortfall) = getHypotheticalAccountLiquidityInternal(holder, VToken(0), 0, 0);\r\n            venusAccrued[holder] = grantXVSInternal(holder, venusAccrued[holder], shortfall, collateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in all markets, a shorthand for `claimVenus` with collateral set to `true`\r\n     * @param holder The address to claim XVS for\r\n     */\r\n    function claimVenusAsCollateral(address holder) external {\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = holder;\r\n        claimVenus(holders, allMarkets, true, true, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to the user with user's shortfall considered\r\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer XVS to\r\n     * @param amount The amount of XVS to (possibly) transfer\r\n     * @param shortfall The shortfall of the user\r\n     * @param collateral Whether or not we will use user's venus reward as collateral to pay off the debt\r\n     * @return The amount of XVS which was NOT transferred to the user\r\n     */\r\n    function grantXVSInternal(address user, uint amount, uint shortfall, bool collateral) internal returns (uint) {\r\n        // If the user is blacklisted, they can't get XVS rewards\r\n        require(\r\n            user != 0xEF044206Db68E40520BfA82D45419d498b4bc7Bf\r\n            && user != 0x7589dD3355DAE848FDbF75044A3495351655cB1A\r\n            && user != 0x33df7a7F6D44307E1e5F3B15975b47515e5524c0\r\n            && user != 0x24e77E5b74B30b026E9996e4bc3329c881e24968,\r\n            \"Blacklisted\"\r\n        );\r\n\r\n        XVS xvs = XVS(getXVSAddress());\r\n        uint venusRemaining = xvs.balanceOf(address(this));\r\n        bool bankrupt = shortfall > 0;\r\n\r\n        if (amount == 0 || amount > venusRemaining) {\r\n            return amount;\r\n        }\r\n\r\n        // If user's not bankrupt, user can get the reward,\r\n        // so the liquidators will have chances to liquidate bankrupt accounts\r\n        if (!bankrupt) {\r\n            xvs.transfer(user, amount);\r\n            return 0;\r\n        }\r\n        // If user's bankrupt and doesn't use pending xvs as collateral, don't grant\r\n        // anything, otherwise, we will transfer the pending xvs as collateral to\r\n        // vXVS token and mint vXVS for the user.\r\n        //\r\n        // If mintBehalf failed, don't grant any xvs\r\n        require(collateral, \"bankrupt accounts can only collateralize their pending xvs rewards\");\r\n\r\n        xvs.approve(getXVSVTokenAddress(), amount);\r\n        require(\r\n            VBep20Interface(getXVSVTokenAddress()).mintBehalf(user, amount) == uint(Error.NO_ERROR),\r\n            \"mint behalf error during collateralize xvs\"\r\n        );\r\n\r\n        // set venusAccrue[user] to 0\r\n        return 0;\r\n    }\r\n\r\n    /*** Venus Distribution Admin ***/\r\n\r\n    /**\r\n     * @notice Transfer XVS to the recipient\r\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all.\r\n     * @param recipient The address of the recipient to transfer XVS to\r\n     * @param amount The amount of XVS to (possibly) transfer\r\n     */\r\n    function _grantXVS(address recipient, uint amount) external {\r\n        ensureAdminOr(comptrollerImplementation);\r\n        uint amountLeft = grantXVSInternal(recipient, amount, 0, false);\r\n        require(amountLeft == 0, \"insufficient xvs for grant\");\r\n        emit VenusGranted(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the amount of XVS distributed per block to VAI Vault\r\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\r\n     */\r\n    function _setVenusVAIVaultRate(uint venusVAIVaultRate_) external {\r\n        ensureAdmin();\r\n\r\n        uint oldVenusVAIVaultRate = venusVAIVaultRate;\r\n        venusVAIVaultRate = venusVAIVaultRate_;\r\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the VAI Vault infos\r\n     * @param vault_ The address of the VAI Vault\r\n     * @param releaseStartBlock_ The start block of release to VAI Vault\r\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\r\n     */\r\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) external {\r\n        ensureAdmin();\r\n        ensureNonzeroAddress(vault_);\r\n\r\n        vaiVaultAddress = vault_;\r\n        releaseStartBlock = releaseStartBlock_;\r\n        minReleaseAmount = minReleaseAmount_;\r\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\r\n    }\r\n\r\n    /**\r\n     * @notice Set XVS speed for a single market\r\n     * @param vToken The market whose XVS speed to update\r\n     * @param venusSpeed New XVS speed for market\r\n     */\r\n    function _setVenusSpeed(VToken vToken, uint venusSpeed) external {\r\n        ensureAdminOr(comptrollerImplementation);\r\n        ensureNonzeroAddress(address(vToken));\r\n        setVenusSpeedInternal(vToken, venusSpeed);\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() public view returns (VToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the XVS token\r\n     * @return The address of XVS\r\n     */\r\n    function getXVSAddress() public view returns (address) {\r\n        return 0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the XVS vToken\r\n     * @return The address of XVS vToken\r\n     */\r\n    function getXVSVTokenAddress() public view returns (address) {\r\n        return 0x151B1e2635A717bcDc836ECd6FbB62B674FE3E1D;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a certain action is paused on a market\r\n     * @param action Action id\r\n     * @param market vToken address\r\n     */\r\n    function actionPaused(address market, Action action) public view returns (bool) {\r\n        return _actionPaused[market][uint(action)];\r\n    }\r\n\r\n\r\n    /*** VAI functions ***/\r\n\r\n    /**\r\n     * @notice Set the minted VAI amount of the `owner`\r\n     * @param owner The address of the account to set\r\n     * @param amount The amount of VAI to set to the account\r\n     * @return The number of minted VAI by `owner`\r\n     */\r\n    function setMintedVAIOf(address owner, uint amount) external returns (uint) {\r\n        checkProtocolPauseState();\r\n\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\r\n        // Check caller is vaiController\r\n        if (msg.sender != address(vaiController)) {\r\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\r\n        }\r\n        mintedVAIs[owner] = amount;\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to VAI Vault\r\n     */\r\n    function releaseToVault() public {\r\n        if(releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\r\n            return;\r\n        }\r\n\r\n        XVS xvs = XVS(getXVSAddress());\r\n\r\n        uint256 xvsBalance = xvs.balanceOf(address(this));\r\n        if(xvsBalance == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 actualAmount;\r\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\r\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\r\n        uint256 _releaseAmount = mul_(venusVAIVaultRate, deltaBlocks);\r\n\r\n        if (xvsBalance >= _releaseAmount) {\r\n            actualAmount = _releaseAmount;\r\n        } else {\r\n            actualAmount = xvsBalance;\r\n        }\r\n\r\n        if (actualAmount < minReleaseAmount) {\r\n            return;\r\n        }\r\n\r\n        releaseStartBlock = getBlockNumber();\r\n\r\n        xvs.transfer(vaiVaultAddress, actualAmount);\r\n        emit DistributedVAIVaultVenus(actualAmount);\r\n\r\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\r\n    }\r\n}\r\n"
    },
    "contracts/ComptrollerG1.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./Exponential.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\nimport \"./Unitroller.sol\";\r\nimport \"./Governance/XVS.sol\";\r\nimport \"./VAI/VAI.sol\";\r\n\r\n/**\r\n * @title Venus's Comptroller Contract\r\n * @author Venus\r\n */\r\ncontract ComptrollerG1 is ComptrollerV1Storage, ComptrollerInterfaceG1, ComptrollerErrorReporter, Exponential {\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketListed(VToken vToken);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\r\n\r\n    /// @notice Emitted when a collateral factor is changed by admin\r\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\r\n\r\n    /// @notice Emitted when maxAssets is changed by admin\r\n    event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);\r\n\r\n    /// @notice Emitted when price oracle is changed\r\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\r\n\r\n    /// @notice Emitted when pause guardian is changed\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    /// @notice Emitted when an action is paused globally\r\n    event ActionPaused(string action, bool pauseState);\r\n\r\n    /// @notice Emitted when an action is paused on a market\r\n    event ActionPaused(VToken vToken, string action, bool pauseState);\r\n\r\n    /// @notice Emitted when market venus status is changed\r\n    event MarketVenus(VToken vToken, bool isVenus);\r\n\r\n    /// @notice Emitted when Venus rate is changed\r\n    event NewVenusRate(uint oldVenusRate, uint newVenusRate);\r\n\r\n    /// @notice Emitted when a new Venus speed is calculated for a market\r\n    event VenusSpeedUpdated(VToken indexed vToken, uint newSpeed);\r\n\r\n    /// @notice Emitted when XVS is distributed to a supplier\r\n    event DistributedSupplierVenus(VToken indexed vToken, address indexed supplier, uint venusDelta, uint venusSupplyIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a borrower\r\n    event DistributedBorrowerVenus(VToken indexed vToken, address indexed borrower, uint venusDelta, uint venusBorrowIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a VAI minter\r\n    event DistributedVAIMinterVenus(address indexed vaiMinter, uint venusDelta, uint venusVAIMintIndex);\r\n\r\n    /// @notice Emitted when VAIController is changed\r\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\r\n\r\n    /// @notice Emitted when VAI mint rate is changed by admin\r\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\r\n\r\n    /// @notice Emitted when protocol state is changed by admin\r\n    event ActionProtocolPaused(bool state);\r\n\r\n    /// @notice The threshold above which the flywheel transfers XVS, in wei\r\n    uint public constant venusClaimThreshold = 0.001e18;\r\n\r\n    /// @notice The initial Venus index for a market\r\n    uint224 public constant venusInitialIndex = 1e36;\r\n\r\n    // closeFactorMantissa must be strictly greater than this value\r\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n    // closeFactorMantissa must not exceed this value\r\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // No collateralFactorMantissa may exceed this value\r\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // liquidationIncentiveMantissa must be no less than this value\r\n    uint internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\r\n\r\n    // liquidationIncentiveMantissa must be no greater than this value\r\n    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyProtocolAllowed {\r\n        require(!protocolPaused, \"protocol is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyListedMarket(VToken vToken) {\r\n        require(markets[address(vToken)].isListed, \"venus market is not listed\");\r\n        _;\r\n    }\r\n\r\n    modifier validPauseState(bool state) {\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n        _;\r\n    }\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\r\n        return accountAssets[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account is entered in the given asset\r\n     * @param account The address of the account to check\r\n     * @param vToken The vToken to check\r\n     * @return True if the account is in the asset, otherwise false.\r\n     */\r\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\r\n        return markets[address(vToken)].accountMembership[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add assets to be included in account liquidity calculation\r\n     * @param vTokens The list of addresses of the vToken markets to be enabled\r\n     * @return Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory) {\r\n        uint len = vTokens.length;\r\n\r\n        uint[] memory results = new uint[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            results[i] = uint(addToMarketInternal(VToken(vTokens[i]), msg.sender));\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n     * @param vToken The market to enter\r\n     * @param borrower The address of the account to modify\r\n     * @return Success indicator for whether the market was entered\r\n     */\r\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\r\n        Market storage marketToJoin = markets[address(vToken)];\r\n\r\n        if (!marketToJoin.isListed) {\r\n            // market is not listed, cannot join\r\n            return Error.MARKET_NOT_LISTED;\r\n        }\r\n\r\n        if (marketToJoin.accountMembership[borrower]) {\r\n            // already joined\r\n            return Error.NO_ERROR;\r\n        }\r\n\r\n        if (accountAssets[borrower].length >= maxAssets)  {\r\n            // no space, cannot join\r\n            return Error.TOO_MANY_ASSETS;\r\n        }\r\n\r\n        // survived the gauntlet, add to list\r\n        // NOTE: we store these somewhat redundantly as a significant optimization\r\n        //  this avoids having to iterate through the list for the most common use cases\r\n        //  that is, only when we need to perform liquidity checks\r\n        //  and not whenever we want to check if an account is in a particular market\r\n        marketToJoin.accountMembership[borrower] = true;\r\n        accountAssets[borrower].push(vToken);\r\n\r\n        emit MarketEntered(vToken, borrower);\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes asset from sender's account liquidity calculation\r\n     * @dev Sender must not have an outstanding borrow balance in the asset,\r\n     *  or be providing necessary collateral for an outstanding borrow.\r\n     * @param vTokenAddress The address of the asset to be removed\r\n     * @return Whether or not the account successfully exited the market\r\n     */\r\n    function exitMarket(address vTokenAddress) external returns (uint) {\r\n        VToken vToken = VToken(vTokenAddress);\r\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\r\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\r\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\r\n\r\n        /* Fail if the sender has a borrow balance */\r\n        if (amountOwed != 0) {\r\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\r\n        }\r\n\r\n        /* Fail if the sender is not permitted to redeem all of their tokens */\r\n        uint allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\r\n        }\r\n\r\n        Market storage marketToExit = markets[address(vToken)];\r\n\r\n        /* Return true if the sender is not already ‘in’ the market */\r\n        if (!marketToExit.accountMembership[msg.sender]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Set vToken account membership to false */\r\n        delete marketToExit.accountMembership[msg.sender];\r\n\r\n        /* Delete vToken from the account’s list of assets */\r\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\r\n        VToken[] storage userAssetList = accountAssets[msg.sender];\r\n        uint len = userAssetList.length;\r\n        uint i;\r\n        for (; i < len; i++) {\r\n            if (userAssetList[i] == vToken) {\r\n                userAssetList[i] = userAssetList[len - 1];\r\n                userAssetList.length--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // We *must* have found the asset in the list or our redundant data structure is broken\r\n        assert(i < len);\r\n\r\n        emit MarketExited(vToken, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to mint tokens in the given market\r\n     * @param vToken The market to verify the mint against\r\n     * @param minter The account which would get the minted tokens\r\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function mintAllowed(address vToken, address minter, uint mintAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintGuardianPaused[vToken], \"mint is paused\");\r\n\r\n        // Shh - currently unused\r\n        mintAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, minter, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates mint and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being minted\r\n     * @param minter The address minting the tokens\r\n     * @param actualMintAmount The amount of the underlying asset being minted\r\n     * @param mintTokens The number of tokens being minted\r\n     */\r\n    function mintVerify(address vToken, address minter, uint actualMintAmount, uint mintTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        minter;\r\n        actualMintAmount;\r\n        mintTokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n     * @param vToken The market to verify the redeem against\r\n     * @param redeemer The account which would redeem the tokens\r\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\r\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external onlyProtocolAllowed returns (uint) {\r\n        uint allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, redeemer, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function redeemAllowedInternal(address vToken, address redeemer, uint redeemTokens) internal view returns (uint) {\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n        if (!markets[vToken].accountMembership[redeemer]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, VToken(vToken), redeemTokens, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates redeem and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being redeemed\r\n     * @param redeemer The address redeeming the tokens\r\n     * @param redeemAmount The amount of the underlying asset being redeemed\r\n     * @param redeemTokens The number of tokens being redeemed\r\n     */\r\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        redeemer;\r\n\r\n        // Require tokens is zero or amount is also zero\r\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param vToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!borrowGuardianPaused[vToken], \"borrow is paused\");\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (!markets[vToken].accountMembership[borrower]) {\r\n            // only vTokens may call borrowAllowed if borrower not in market\r\n            require(msg.sender == vToken, \"sender must be vToken\");\r\n\r\n            // attempt to add borrower to the market\r\n            Error err = addToMarketInternal(VToken(vToken), borrower);\r\n            if (err != Error.NO_ERROR) {\r\n                return uint(err);\r\n            }\r\n        }\r\n\r\n        if (oracle.getUnderlyingPrice(VToken(vToken)) == 0) {\r\n            return uint(Error.PRICE_ERROR);\r\n        }\r\n\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(vToken), 0, borrowAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates borrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset whose underlying is being borrowed\r\n     * @param borrower The address borrowing the underlying\r\n     * @param borrowAmount The amount of the underlying asset requested to borrow\r\n     */\r\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        borrower;\r\n        borrowAmount;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n     * @param vToken The market to verify the repay against\r\n     * @param payer The account which would repay the asset\r\n     * @param borrower The account which would repay the asset\r\n     * @param repayAmount The amount of the underlying asset the account would repay\r\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function repayBorrowAllowed(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        payer;\r\n        borrower;\r\n        repayAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being repaid\r\n     * @param payer The address repaying the borrow\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function repayBorrowVerify(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint borrowerIndex) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        payer;\r\n        borrower;\r\n        actualRepayAmount;\r\n        borrowerIndex;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the liquidation should be allowed to occur\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param repayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowAllowed(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        liquidator;\r\n\r\n        if (!markets[vTokenBorrowed].isListed || !markets[vTokenCollateral].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* The borrower must have shortfall in order to be liquidatable */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(0), 0, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall == 0) {\r\n            return uint(Error.INSUFFICIENT_SHORTFALL);\r\n        }\r\n\r\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n        uint borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\r\n        (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return uint(Error.MATH_ERROR);\r\n        }\r\n        if (repayAmount > maxClose) {\r\n            return uint(Error.TOO_MUCH_REPAY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowVerify(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenBorrowed;\r\n        vTokenCollateral;\r\n        liquidator;\r\n        borrower;\r\n        actualRepayAmount;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the seizing of assets should be allowed to occur\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeAllowed(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!seizeGuardianPaused, \"seize is paused\");\r\n\r\n        // Shh - currently unused\r\n        seizeTokens;\r\n\r\n        if (!markets[vTokenCollateral].isListed || !markets[vTokenBorrowed].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\r\n            return uint(Error.COMPTROLLER_MISMATCH);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vTokenCollateral);\r\n        distributeSupplierVenus(vTokenCollateral, borrower, false);\r\n        distributeSupplierVenus(vTokenCollateral, liquidator, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates seize and reverts on rejection. May emit logs.\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeVerify(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenCollateral;\r\n        vTokenBorrowed;\r\n        liquidator;\r\n        borrower;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n     * @param vToken The market to verify the transfer against\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!transferGuardianPaused, \"transfer is paused\");\r\n\r\n        // Currently the only consideration is whether or not\r\n        //  the src is allowed to redeem this many tokens\r\n        uint allowed = redeemAllowedInternal(vToken, src, transferTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, src, false);\r\n        distributeSupplierVenus(vToken, dst, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates transfer and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being transferred\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     */\r\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        src;\r\n        dst;\r\n        transferTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountLiquidityLocalVars {\r\n        uint sumCollateral;\r\n        uint sumBorrowPlusEffects;\r\n        uint vTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code (semi-opaque),\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(0), 0, 0);\r\n\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidity(\r\n        address account,\r\n        address vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(vTokenModify), redeemTokens, borrowAmount);\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\r\n     *  without calculating accumulated interest.\r\n     * @return (possible error code,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidityInternal(\r\n        address account,\r\n        VToken vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) internal view returns (Error, uint, uint) {\r\n\r\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n        MathError mErr;\r\n\r\n        // For each asset the account is in\r\n        VToken[] memory assets = accountAssets[account];\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            VToken asset = assets[i];\r\n\r\n            // Read the balances and exchange rate from the vToken\r\n            (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\r\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                return (Error.SNAPSHOT_ERROR, 0, 0);\r\n            }\r\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                return (Error.PRICE_ERROR, 0, 0);\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\r\n            (mErr, vars.tokensToDenom) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);\r\n            if (mErr != MathError.NO_ERROR) {\r\n                return (Error.MATH_ERROR, 0, 0);\r\n            }\r\n\r\n            // sumCollateral += tokensToDenom * vTokenBalance\r\n            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToDenom, vars.vTokenBalance, vars.sumCollateral);\r\n            if (mErr != MathError.NO_ERROR) {\r\n                return (Error.MATH_ERROR, 0, 0);\r\n            }\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n            if (mErr != MathError.NO_ERROR) {\r\n                return (Error.MATH_ERROR, 0, 0);\r\n            }\r\n\r\n            // Calculate effects of interacting with vTokenModify\r\n            if (asset == vTokenModify) {\r\n                // redeem effect\r\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\r\n                if (mErr != MathError.NO_ERROR) {\r\n                    return (Error.MATH_ERROR, 0, 0);\r\n                }\r\n\r\n                // borrow effect\r\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\r\n                if (mErr != MathError.NO_ERROR) {\r\n                    return (Error.MATH_ERROR, 0, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        /// @dev VAI Integration^\r\n        (mErr, vars.sumBorrowPlusEffects) = addUInt(vars.sumBorrowPlusEffects, mintedVAIs[account]);\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (Error.MATH_ERROR, 0, 0);\r\n        }\r\n        /// @dev VAI Integration$\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\r\n     * @param vTokenBorrowed The address of the borrowed vToken\r\n     * @param vTokenCollateral The address of the collateral vToken\r\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\r\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateCalculateSeizeTokens(address vTokenBorrowed, address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(VToken(vTokenBorrowed));\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(VToken(vTokenCollateral));\r\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n        MathError mathErr;\r\n\r\n        (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (mathErr, denominator) = mulExp(priceCollateralMantissa, exchangeRateMantissa);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (mathErr, ratio) = divExp(numerator, denominator);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (mathErr, seizeTokens) = mulScalarTruncate(ratio, actualRepayAmount);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new price oracle for the comptroller\r\n      * @dev Admin function to set a new price oracle\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\r\n        }\r\n\r\n        // Track the old oracle for the comptroller\r\n        PriceOracle oldOracle = oracle;\r\n\r\n        // Set comptroller's oracle to newOracle\r\n        oracle = newOracle;\r\n\r\n        // Emit NewPriceOracle(oldOracle, newOracle)\r\n        emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the closeFactor used when liquidating borrows\r\n      * @dev Admin function to set closeFactor\r\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\r\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\r\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\r\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\r\n        }\r\n\r\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\r\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\r\n        }\r\n\r\n        uint oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = newCloseFactorMantissa;\r\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the collateralFactor for a market\r\n      * @dev Admin function to set per-market collateralFactor\r\n      * @param vToken The market to set the factor on\r\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        // Verify market is listed\r\n        Market storage market = markets[address(vToken)];\r\n        if (!market.isListed) {\r\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\r\n        }\r\n\r\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\r\n\r\n        // Check collateral factor <= 0.9\r\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\r\n        }\r\n\r\n        // If collateral factor != 0, fail if price == 0\r\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\r\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\r\n        }\r\n\r\n        // Set market's collateral factor to new collateral factor, remember old value\r\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n        // Emit event with asset, old collateral factor, and new collateral factor\r\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets maxAssets which controls how many markets can be entered\r\n      * @dev Admin function to set maxAssets\r\n      * @param newMaxAssets New max assets\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\r\n        }\r\n\r\n        uint oldMaxAssets = maxAssets;\r\n        maxAssets = newMaxAssets;\r\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets liquidationIncentive\r\n      * @dev Admin function to set liquidationIncentive\r\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\r\n        }\r\n\r\n        // Check de-scaled min <= newLiquidationIncentive <= max\r\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\r\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\r\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\r\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\r\n        }\r\n\r\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\r\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\r\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\r\n        }\r\n\r\n        // Save current value for use in log\r\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n        // Set liquidation incentive to new incentive\r\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n        // Emit event with old incentive, new incentive\r\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Add the market to the markets mapping and set it as listed\r\n      * @dev Admin function to set isListed and add support for the market\r\n      * @param vToken The address of the market (token) to list\r\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n      */\r\n    function _supportMarket(VToken vToken) external returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n        }\r\n\r\n        if (markets[address(vToken)].isListed) {\r\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n        }\r\n\r\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\r\n\r\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\r\n\r\n        _addMarketInternal(vToken);\r\n\r\n        emit MarketListed(vToken);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _addMarketInternal(VToken vToken) internal {\r\n        for (uint i = 0; i < allMarkets.length; i ++) {\r\n            require(allMarkets[i] != vToken, \"market already added\");\r\n        }\r\n        allMarkets.push(vToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Pause Guardian\r\n     * @param newPauseGuardian The address of the new Pause Guardian\r\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n     */\r\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for inclusion in log\r\n        address oldPauseGuardian = pauseGuardian;\r\n\r\n        // Store pauseGuardian with value newPauseGuardian\r\n        pauseGuardian = newPauseGuardian;\r\n\r\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\r\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setMintPaused(VToken vToken, bool state) public onlyListedMarket(vToken) validPauseState(state) returns (bool) {\r\n        mintGuardianPaused[address(vToken)] = state;\r\n        emit ActionPaused(vToken, \"Mint\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setBorrowPaused(VToken vToken, bool state) public onlyListedMarket(vToken) validPauseState(state) returns (bool) {\r\n        borrowGuardianPaused[address(vToken)] = state;\r\n        emit ActionPaused(vToken, \"Borrow\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setTransferPaused(bool state) public validPauseState(state) returns (bool) {\r\n        transferGuardianPaused = state;\r\n        emit ActionPaused(\"Transfer\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setSeizePaused(bool state) public validPauseState(state) returns (bool) {\r\n        seizeGuardianPaused = state;\r\n        emit ActionPaused(\"Seize\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setMintVAIPaused(bool state) public validPauseState(state) returns (bool) {\r\n        mintVAIGuardianPaused = state;\r\n        emit ActionPaused(\"MintVAI\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setRepayVAIPaused(bool state) public validPauseState(state) returns (bool) {\r\n        repayVAIGuardianPaused = state;\r\n        emit ActionPaused(\"RepayVAI\", state);\r\n        return state;\r\n    }\r\n    /**\r\n     * @notice Set whole protocol pause/unpause state\r\n     */\r\n    function _setProtocolPaused(bool state) public onlyAdmin returns(bool) {\r\n        protocolPaused = state;\r\n        emit ActionProtocolPaused(state);\r\n        return state;\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new VAI controller\r\n      * @dev Admin function to set a new VAI controller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAICONTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        VAIControllerInterface oldRate = vaiController;\r\n        vaiController = vaiController_;\r\n        emit NewVAIController(oldRate, vaiController_);\r\n    }\r\n\r\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAI_MINT_RATE_CHECK);\r\n        }\r\n\r\n        uint oldVAIMintRate = vaiMintRate;\r\n        vaiMintRate = newVAIMintRate;\r\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _become(Unitroller unitroller) public {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\r\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\r\n    }\r\n\r\n    /*** Venus Distribution ***/\r\n\r\n    /**\r\n     * @notice Recalculate and update Venus speeds for all Venus markets\r\n     */\r\n    function refreshVenusSpeeds() public {\r\n        require(msg.sender == tx.origin, \"only externally owned accounts can\");\r\n        refreshVenusSpeedsInternal();\r\n    }\r\n\r\n    function refreshVenusSpeedsInternal() internal {\r\n        uint i;\r\n        VToken vToken;\r\n\r\n        for (i = 0; i < allMarkets.length; i++) {\r\n            vToken = allMarkets[i];\r\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n            updateVenusSupplyIndex(address(vToken));\r\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n        }\r\n\r\n        Exp memory totalUtility = Exp({mantissa: 0});\r\n        Exp[] memory utilities = new Exp[](allMarkets.length);\r\n        for (i = 0; i < allMarkets.length; i++) {\r\n            vToken = allMarkets[i];\r\n            if (markets[address(vToken)].isVenus) {\r\n                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(vToken)});\r\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\r\n                utilities[i] = utility;\r\n                totalUtility = add_(totalUtility, utility);\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < allMarkets.length; i++) {\r\n            vToken = allMarkets[i];\r\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\r\n            venusSpeeds[address(vToken)] = newSpeed;\r\n            emit VenusSpeedUpdated(vToken, newSpeed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the supply index\r\n     * @param vToken The market whose supply index to update\r\n     */\r\n    function updateVenusSupplyIndex(address vToken) internal {\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        uint supplySpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\r\n        if (deltaBlocks > 0 && supplySpeed > 0) {\r\n            uint supplyTokens = VToken(vToken).totalSupply();\r\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\r\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\r\n            venusSupplyState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the borrow index\r\n     * @param vToken The market whose borrow index to update\r\n     */\r\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        uint borrowSpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\r\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\r\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\r\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\r\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\r\n            venusBorrowState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to by updating the VAI minter index\r\n     */\r\n    function updateVenusVAIMintIndex() internal {\r\n        if (address(vaiController) != address(0)) {\r\n            vaiController.updateVenusVAIMintIndex();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\r\n     * @param vToken The market in which the supplier is interacting\r\n     * @param supplier The address of the supplier to distribute XVS to\r\n     */\r\n    function distributeSupplierVenus(address vToken, address supplier, bool distributeAll) internal {\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\r\n        Double memory supplierIndex = Double({mantissa: venusSupplierIndex[vToken][supplier]});\r\n        venusSupplierIndex[vToken][supplier] = supplyIndex.mantissa;\r\n\r\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\r\n            supplierIndex.mantissa = venusInitialIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\r\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\r\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\r\n        uint supplierAccrued = add_(venusAccrued[supplier], supplierDelta);\r\n        venusAccrued[supplier] = transferXVS(supplier, supplierAccrued, distributeAll ? 0 : venusClaimThreshold);\r\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\r\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vToken The market in which the borrower is interacting\r\n     * @param borrower The address of the borrower to distribute XVS to\r\n     */\r\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex, bool distributeAll) internal {\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\r\n        Double memory borrowerIndex = Double({mantissa: venusBorrowerIndex[vToken][borrower]});\r\n        venusBorrowerIndex[vToken][borrower] = borrowIndex.mantissa;\r\n\r\n        if (borrowerIndex.mantissa > 0) {\r\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\r\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\r\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\r\n            uint borrowerAccrued = add_(venusAccrued[borrower], borrowerDelta);\r\n            venusAccrued[borrower] = transferXVS(borrower, borrowerAccrued, distributeAll ? 0 : venusClaimThreshold);\r\n            emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a VAI minter and possibly transfer it to them\r\n     * @dev VAI minters will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vaiMinter The address of the VAI minter to distribute XVS to\r\n     */\r\n    function distributeVAIMinterVenus(address vaiMinter, bool distributeAll) internal {\r\n        if (address(vaiController) != address(0)) {\r\n            uint vaiMinterAccrued;\r\n            uint vaiMinterDelta;\r\n            uint vaiMintIndexMantissa;\r\n            uint err;\r\n            (err, vaiMinterAccrued, vaiMinterDelta, vaiMintIndexMantissa) = vaiController.calcDistributeVAIMinterVenus(vaiMinter);\r\n            if (err == uint(Error.NO_ERROR)) {\r\n                venusAccrued[vaiMinter] = transferXVS(vaiMinter, vaiMinterAccrued, distributeAll ? 0 : venusClaimThreshold);\r\n                emit DistributedVAIMinterVenus(vaiMinter, vaiMinterDelta, vaiMintIndexMantissa);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to the user, if they are above the threshold\r\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer XVS to\r\n     * @param userAccrued The amount of XVS to (possibly) transfer\r\n     * @return The amount of XVS which was NOT transferred to the user\r\n     */\r\n    function transferXVS(address user, uint userAccrued, uint threshold) internal returns (uint) {\r\n        if (userAccrued >= threshold && userAccrued > 0) {\r\n            XVS xvs = XVS(getXVSAddress());\r\n            uint xvsRemaining = xvs.balanceOf(address(this));\r\n            if (userAccrued <= xvsRemaining) {\r\n                xvs.transfer(user, userAccrued);\r\n                return 0;\r\n            }\r\n        }\r\n        return userAccrued;\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\r\n     * @param holder The address to claim XVS for\r\n     */\r\n    function claimVenus(address holder) public {\r\n        return claimVenus(holder, allMarkets);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in the specified markets\r\n     * @param holder The address to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     */\r\n    function claimVenus(address holder, VToken[] memory vTokens) public {\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = holder;\r\n        claimVenus(holders, vTokens, true, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all xvs accrued by the holders\r\n     * @param holders The addresses to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     * @param borrowers Whether or not to claim XVS earned by borrowing\r\n     * @param suppliers Whether or not to claim XVS earned by supplying\r\n     */\r\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\r\n        uint j;\r\n        updateVenusVAIMintIndex();\r\n        for (j = 0; j < holders.length; j++) {\r\n            distributeVAIMinterVenus(holders[j], true);\r\n        }\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            VToken vToken = vTokens[i];\r\n            require(markets[address(vToken)].isListed, \"not listed market\");\r\n            if (borrowers) {\r\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex, true);\r\n                }\r\n            }\r\n            if (suppliers) {\r\n                updateVenusSupplyIndex(address(vToken));\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeSupplierVenus(address(vToken), holders[j], true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*** Venus Distribution Admin ***/\r\n\r\n    /**\r\n     * @notice Set the amount of XVS distributed per block\r\n     * @param venusRate_ The amount of XVS wei per block to distribute\r\n     */\r\n    function _setVenusRate(uint venusRate_) public onlyAdmin {\r\n        uint oldRate = venusRate;\r\n        venusRate = venusRate_;\r\n        emit NewVenusRate(oldRate, venusRate_);\r\n\r\n        refreshVenusSpeedsInternal();\r\n    }\r\n\r\n    /**\r\n     * @notice Add markets to venusMarkets, allowing them to earn XVS in the flywheel\r\n     * @param vTokens The addresses of the markets to add\r\n     */\r\n    function _addVenusMarkets(address[] calldata vTokens) external onlyAdmin {\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            _addVenusMarketInternal(vTokens[i]);\r\n        }\r\n\r\n        refreshVenusSpeedsInternal();\r\n    }\r\n\r\n    function _addVenusMarketInternal(address vToken) internal {\r\n        Market storage market = markets[vToken];\r\n        require(market.isListed, \"venus market is not listed\");\r\n        require(!market.isVenus, \"venus market already added\");\r\n\r\n        market.isVenus = true;\r\n        emit MarketVenus(VToken(vToken), true);\r\n\r\n        if (venusSupplyState[vToken].index == 0 && venusSupplyState[vToken].block == 0) {\r\n            venusSupplyState[vToken] = VenusMarketState({\r\n                index: venusInitialIndex,\r\n                block: safe32(getBlockNumber(), \"block number overflows\")\r\n            });\r\n        }\r\n\r\n        if (venusBorrowState[vToken].index == 0 && venusBorrowState[vToken].block == 0) {\r\n            venusBorrowState[vToken] = VenusMarketState({\r\n                index: venusInitialIndex,\r\n                block: safe32(getBlockNumber(), \"block number overflows\")\r\n            });\r\n        }\r\n    }\r\n\r\n    function _initializeVenusVAIState(uint blockNumber) public {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        if (address(vaiController) != address(0)) {\r\n            vaiController._initializeVenusVAIState(blockNumber);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a market from venusMarkets, preventing it from earning XVS in the flywheel\r\n     * @param vToken The address of the market to drop\r\n     */\r\n    function _dropVenusMarket(address vToken) public onlyAdmin {\r\n        Market storage market = markets[vToken];\r\n        require(market.isVenus == true, \"not venus market\");\r\n\r\n        market.isVenus = false;\r\n        emit MarketVenus(VToken(vToken), false);\r\n\r\n        refreshVenusSpeedsInternal();\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() public view returns (VToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the XVS token\r\n     * @return The address of XVS\r\n     */\r\n    function getXVSAddress() public view returns (address) {\r\n        return 0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63;\r\n    }\r\n\r\n    /*** VAI functions ***/\r\n\r\n    /**\r\n     * @notice Set the minted VAI amount of the `owner`\r\n     * @param owner The address of the account to set\r\n     * @param amount The amount of VAI to set to the account\r\n     * @return The number of minted VAI by `owner`\r\n     */\r\n    function setMintedVAIOf(address owner, uint amount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\r\n        // Check caller is vaiController\r\n        if (msg.sender != address(vaiController)) {\r\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\r\n        }\r\n        mintedVAIs[owner] = amount;\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint VAI\r\n     */\r\n    function mintVAI(uint mintVAIAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintVAIGuardianPaused, \"mintVAI is paused\");\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusVAIMintIndex();\r\n        distributeVAIMinterVenus(msg.sender, false);\r\n        return vaiController.mintVAI(msg.sender, mintVAIAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Repay VAI\r\n     */\r\n    function repayVAI(uint repayVAIAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!repayVAIGuardianPaused, \"repayVAI is paused\");\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusVAIMintIndex();\r\n        distributeVAIMinterVenus(msg.sender, false);\r\n        return vaiController.repayVAI(msg.sender, repayVAIAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the minted VAI amount of the `owner`\r\n     * @param owner The address of the account to query\r\n     * @return The number of minted VAI by `owner`\r\n     */\r\n    function mintedVAIOf(address owner) external view returns (uint) {\r\n        return mintedVAIs[owner];\r\n    }\r\n\r\n    /**\r\n     * @notice Get Mintable VAI amount\r\n     */\r\n    function getMintableVAI(address minter) external view returns (uint, uint) {\r\n        return vaiController.getMintableVAI(minter);\r\n    }\r\n}\r\n"
    },
    "contracts/ComptrollerG2.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./Exponential.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\nimport \"./Unitroller.sol\";\r\nimport \"./Governance/XVS.sol\";\r\nimport \"./VAI/VAI.sol\";\r\n\r\n/**\r\n * @title Venus's Comptroller Contract\r\n * @author Venus\r\n */\r\ncontract ComptrollerG2 is ComptrollerV1Storage, ComptrollerInterfaceG1, ComptrollerErrorReporter, Exponential {\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketListed(VToken vToken);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\r\n\r\n    /// @notice Emitted when a collateral factor is changed by admin\r\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\r\n\r\n    /// @notice Emitted when maxAssets is changed by admin\r\n    event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);\r\n\r\n    /// @notice Emitted when price oracle is changed\r\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\r\n\r\n    /// @notice Emitted when pause guardian is changed\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    /// @notice Emitted when an action is paused globally\r\n    event ActionPaused(string action, bool pauseState);\r\n\r\n    /// @notice Emitted when an action is paused on a market\r\n    event ActionPaused(VToken vToken, string action, bool pauseState);\r\n\r\n    /// @notice Emitted when market venus status is changed\r\n    event MarketVenus(VToken vToken, bool isVenus);\r\n\r\n    /// @notice Emitted when Venus rate is changed\r\n    event NewVenusRate(uint oldVenusRate, uint newVenusRate);\r\n\r\n    /// @notice Emitted when a new Venus speed is calculated for a market\r\n    event VenusSpeedUpdated(VToken indexed vToken, uint newSpeed);\r\n\r\n    /// @notice Emitted when XVS is distributed to a supplier\r\n    event DistributedSupplierVenus(VToken indexed vToken, address indexed supplier, uint venusDelta, uint venusSupplyIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a borrower\r\n    event DistributedBorrowerVenus(VToken indexed vToken, address indexed borrower, uint venusDelta, uint venusBorrowIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a VAI minter\r\n    event DistributedVAIMinterVenus(address indexed vaiMinter, uint venusDelta, uint venusVAIMintIndex);\r\n\r\n    /// @notice Emitted when VAIController is changed\r\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\r\n\r\n    /// @notice Emitted when VAI mint rate is changed by admin\r\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\r\n\r\n    /// @notice Emitted when protocol state is changed by admin\r\n    event ActionProtocolPaused(bool state);\r\n\r\n    /// @notice The threshold above which the flywheel transfers XVS, in wei\r\n    uint public constant venusClaimThreshold = 0.001e18;\r\n\r\n    /// @notice The initial Venus index for a market\r\n    uint224 public constant venusInitialIndex = 1e36;\r\n\r\n    // closeFactorMantissa must be strictly greater than this value\r\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n    // closeFactorMantissa must not exceed this value\r\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // No collateralFactorMantissa may exceed this value\r\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // liquidationIncentiveMantissa must be no less than this value\r\n    uint internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\r\n\r\n    // liquidationIncentiveMantissa must be no greater than this value\r\n    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyProtocolAllowed {\r\n        require(!protocolPaused, \"protocol is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyListedMarket(VToken vToken) {\r\n        require(markets[address(vToken)].isListed, \"venus market is not listed\");\r\n        _;\r\n    }\r\n\r\n    modifier validPauseState(bool state) {\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n        _;\r\n    }\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\r\n        return accountAssets[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account is entered in the given asset\r\n     * @param account The address of the account to check\r\n     * @param vToken The vToken to check\r\n     * @return True if the account is in the asset, otherwise false.\r\n     */\r\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\r\n        return markets[address(vToken)].accountMembership[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add assets to be included in account liquidity calculation\r\n     * @param vTokens The list of addresses of the vToken markets to be enabled\r\n     * @return Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory) {\r\n        uint len = vTokens.length;\r\n\r\n        uint[] memory results = new uint[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            results[i] = uint(addToMarketInternal(VToken(vTokens[i]), msg.sender));\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n     * @param vToken The market to enter\r\n     * @param borrower The address of the account to modify\r\n     * @return Success indicator for whether the market was entered\r\n     */\r\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\r\n        Market storage marketToJoin = markets[address(vToken)];\r\n\r\n        if (!marketToJoin.isListed) {\r\n            // market is not listed, cannot join\r\n            return Error.MARKET_NOT_LISTED;\r\n        }\r\n\r\n        if (marketToJoin.accountMembership[borrower]) {\r\n            // already joined\r\n            return Error.NO_ERROR;\r\n        }\r\n\r\n        if (accountAssets[borrower].length >= maxAssets)  {\r\n            // no space, cannot join\r\n            return Error.TOO_MANY_ASSETS;\r\n        }\r\n\r\n        // survived the gauntlet, add to list\r\n        // NOTE: we store these somewhat redundantly as a significant optimization\r\n        //  this avoids having to iterate through the list for the most common use cases\r\n        //  that is, only when we need to perform liquidity checks\r\n        //  and not whenever we want to check if an account is in a particular market\r\n        marketToJoin.accountMembership[borrower] = true;\r\n        accountAssets[borrower].push(vToken);\r\n\r\n        emit MarketEntered(vToken, borrower);\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes asset from sender's account liquidity calculation\r\n     * @dev Sender must not have an outstanding borrow balance in the asset,\r\n     *  or be providing necessary collateral for an outstanding borrow.\r\n     * @param vTokenAddress The address of the asset to be removed\r\n     * @return Whether or not the account successfully exited the market\r\n     */\r\n    function exitMarket(address vTokenAddress) external returns (uint) {\r\n        VToken vToken = VToken(vTokenAddress);\r\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\r\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\r\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\r\n\r\n        /* Fail if the sender has a borrow balance */\r\n        if (amountOwed != 0) {\r\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\r\n        }\r\n\r\n        /* Fail if the sender is not permitted to redeem all of their tokens */\r\n        uint allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\r\n        }\r\n\r\n        Market storage marketToExit = markets[address(vToken)];\r\n\r\n        /* Return true if the sender is not already ‘in’ the market */\r\n        if (!marketToExit.accountMembership[msg.sender]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Set vToken account membership to false */\r\n        delete marketToExit.accountMembership[msg.sender];\r\n\r\n        /* Delete vToken from the account’s list of assets */\r\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\r\n        VToken[] storage userAssetList = accountAssets[msg.sender];\r\n        uint len = userAssetList.length;\r\n        uint i;\r\n        for (; i < len; i++) {\r\n            if (userAssetList[i] == vToken) {\r\n                userAssetList[i] = userAssetList[len - 1];\r\n                userAssetList.length--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // We *must* have found the asset in the list or our redundant data structure is broken\r\n        assert(i < len);\r\n\r\n        emit MarketExited(vToken, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to mint tokens in the given market\r\n     * @param vToken The market to verify the mint against\r\n     * @param minter The account which would get the minted tokens\r\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function mintAllowed(address vToken, address minter, uint mintAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintGuardianPaused[vToken], \"mint is paused\");\r\n\r\n        // Shh - currently unused\r\n        mintAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, minter, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates mint and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being minted\r\n     * @param minter The address minting the tokens\r\n     * @param actualMintAmount The amount of the underlying asset being minted\r\n     * @param mintTokens The number of tokens being minted\r\n     */\r\n    function mintVerify(address vToken, address minter, uint actualMintAmount, uint mintTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        minter;\r\n        actualMintAmount;\r\n        mintTokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n     * @param vToken The market to verify the redeem against\r\n     * @param redeemer The account which would redeem the tokens\r\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\r\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external onlyProtocolAllowed returns (uint) {\r\n        uint allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, redeemer, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function redeemAllowedInternal(address vToken, address redeemer, uint redeemTokens) internal view returns (uint) {\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n        if (!markets[vToken].accountMembership[redeemer]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, VToken(vToken), redeemTokens, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates redeem and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being redeemed\r\n     * @param redeemer The address redeeming the tokens\r\n     * @param redeemAmount The amount of the underlying asset being redeemed\r\n     * @param redeemTokens The number of tokens being redeemed\r\n     */\r\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        redeemer;\r\n\r\n        // Require tokens is zero or amount is also zero\r\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param vToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!borrowGuardianPaused[vToken], \"borrow is paused\");\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (!markets[vToken].accountMembership[borrower]) {\r\n            // only vTokens may call borrowAllowed if borrower not in market\r\n            require(msg.sender == vToken, \"sender must be vToken\");\r\n\r\n            // attempt to add borrower to the market\r\n            Error err = addToMarketInternal(VToken(vToken), borrower);\r\n            if (err != Error.NO_ERROR) {\r\n                return uint(err);\r\n            }\r\n        }\r\n\r\n        if (oracle.getUnderlyingPrice(VToken(vToken)) == 0) {\r\n            return uint(Error.PRICE_ERROR);\r\n        }\r\n\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(vToken), 0, borrowAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates borrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset whose underlying is being borrowed\r\n     * @param borrower The address borrowing the underlying\r\n     * @param borrowAmount The amount of the underlying asset requested to borrow\r\n     */\r\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        borrower;\r\n        borrowAmount;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n     * @param vToken The market to verify the repay against\r\n     * @param payer The account which would repay the asset\r\n     * @param borrower The account which would repay the asset\r\n     * @param repayAmount The amount of the underlying asset the account would repay\r\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function repayBorrowAllowed(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        payer;\r\n        borrower;\r\n        repayAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being repaid\r\n     * @param payer The address repaying the borrow\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function repayBorrowVerify(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint borrowerIndex) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        payer;\r\n        borrower;\r\n        actualRepayAmount;\r\n        borrowerIndex;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the liquidation should be allowed to occur\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param repayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowAllowed(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        liquidator;\r\n\r\n        if (!markets[vTokenBorrowed].isListed || !markets[vTokenCollateral].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* The borrower must have shortfall in order to be liquidatable */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(0), 0, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall == 0) {\r\n            return uint(Error.INSUFFICIENT_SHORTFALL);\r\n        }\r\n\r\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n        uint borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\r\n        (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return uint(Error.MATH_ERROR);\r\n        }\r\n        if (repayAmount > maxClose) {\r\n            return uint(Error.TOO_MUCH_REPAY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowVerify(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenBorrowed;\r\n        vTokenCollateral;\r\n        liquidator;\r\n        borrower;\r\n        actualRepayAmount;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the seizing of assets should be allowed to occur\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeAllowed(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!seizeGuardianPaused, \"seize is paused\");\r\n\r\n        // Shh - currently unused\r\n        seizeTokens;\r\n\r\n        if (!markets[vTokenCollateral].isListed || !markets[vTokenBorrowed].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\r\n            return uint(Error.COMPTROLLER_MISMATCH);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vTokenCollateral);\r\n        distributeSupplierVenus(vTokenCollateral, borrower, false);\r\n        distributeSupplierVenus(vTokenCollateral, liquidator, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates seize and reverts on rejection. May emit logs.\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeVerify(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenCollateral;\r\n        vTokenBorrowed;\r\n        liquidator;\r\n        borrower;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n     * @param vToken The market to verify the transfer against\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!transferGuardianPaused, \"transfer is paused\");\r\n\r\n        // Currently the only consideration is whether or not\r\n        //  the src is allowed to redeem this many tokens\r\n        uint allowed = redeemAllowedInternal(vToken, src, transferTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, src, false);\r\n        distributeSupplierVenus(vToken, dst, false);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates transfer and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being transferred\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     */\r\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        src;\r\n        dst;\r\n        transferTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountLiquidityLocalVars {\r\n        uint sumCollateral;\r\n        uint sumBorrowPlusEffects;\r\n        uint vTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code (semi-opaque),\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(0), 0, 0);\r\n\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidity(\r\n        address account,\r\n        address vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(vTokenModify), redeemTokens, borrowAmount);\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\r\n     *  without calculating accumulated interest.\r\n     * @return (possible error code,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidityInternal(\r\n        address account,\r\n        VToken vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) internal view returns (Error, uint, uint) {\r\n\r\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n        MathError mErr;\r\n\r\n        // For each asset the account is in\r\n        VToken[] memory assets = accountAssets[account];\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            VToken asset = assets[i];\r\n\r\n            // Read the balances and exchange rate from the vToken\r\n            (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\r\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                return (Error.SNAPSHOT_ERROR, 0, 0);\r\n            }\r\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                return (Error.PRICE_ERROR, 0, 0);\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\r\n            (mErr, vars.tokensToDenom) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);\r\n            if (mErr != MathError.NO_ERROR) {\r\n                return (Error.MATH_ERROR, 0, 0);\r\n            }\r\n\r\n            // sumCollateral += tokensToDenom * vTokenBalance\r\n            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToDenom, vars.vTokenBalance, vars.sumCollateral);\r\n            if (mErr != MathError.NO_ERROR) {\r\n                return (Error.MATH_ERROR, 0, 0);\r\n            }\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n            if (mErr != MathError.NO_ERROR) {\r\n                return (Error.MATH_ERROR, 0, 0);\r\n            }\r\n\r\n            // Calculate effects of interacting with vTokenModify\r\n            if (asset == vTokenModify) {\r\n                // redeem effect\r\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\r\n                if (mErr != MathError.NO_ERROR) {\r\n                    return (Error.MATH_ERROR, 0, 0);\r\n                }\r\n\r\n                // borrow effect\r\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\r\n                if (mErr != MathError.NO_ERROR) {\r\n                    return (Error.MATH_ERROR, 0, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        /// @dev VAI Integration^\r\n        (mErr, vars.sumBorrowPlusEffects) = addUInt(vars.sumBorrowPlusEffects, mintedVAIs[account]);\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (Error.MATH_ERROR, 0, 0);\r\n        }\r\n        /// @dev VAI Integration$\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\r\n     * @param vTokenBorrowed The address of the borrowed vToken\r\n     * @param vTokenCollateral The address of the collateral vToken\r\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\r\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateCalculateSeizeTokens(address vTokenBorrowed, address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(VToken(vTokenBorrowed));\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(VToken(vTokenCollateral));\r\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n        MathError mathErr;\r\n\r\n        (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (mathErr, denominator) = mulExp(priceCollateralMantissa, exchangeRateMantissa);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (mathErr, ratio) = divExp(numerator, denominator);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (mathErr, seizeTokens) = mulScalarTruncate(ratio, actualRepayAmount);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new price oracle for the comptroller\r\n      * @dev Admin function to set a new price oracle\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\r\n        }\r\n\r\n        // Track the old oracle for the comptroller\r\n        PriceOracle oldOracle = oracle;\r\n\r\n        // Set comptroller's oracle to newOracle\r\n        oracle = newOracle;\r\n\r\n        // Emit NewPriceOracle(oldOracle, newOracle)\r\n        emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the closeFactor used when liquidating borrows\r\n      * @dev Admin function to set closeFactor\r\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\r\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\r\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\r\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\r\n        }\r\n\r\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\r\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\r\n        }\r\n\r\n        uint oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = newCloseFactorMantissa;\r\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the collateralFactor for a market\r\n      * @dev Admin function to set per-market collateralFactor\r\n      * @param vToken The market to set the factor on\r\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        // Verify market is listed\r\n        Market storage market = markets[address(vToken)];\r\n        if (!market.isListed) {\r\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\r\n        }\r\n\r\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\r\n\r\n        // Check collateral factor <= 0.9\r\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\r\n        }\r\n\r\n        // If collateral factor != 0, fail if price == 0\r\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\r\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\r\n        }\r\n\r\n        // Set market's collateral factor to new collateral factor, remember old value\r\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n        // Emit event with asset, old collateral factor, and new collateral factor\r\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets maxAssets which controls how many markets can be entered\r\n      * @dev Admin function to set maxAssets\r\n      * @param newMaxAssets New max assets\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\r\n        }\r\n\r\n        uint oldMaxAssets = maxAssets;\r\n        maxAssets = newMaxAssets;\r\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets liquidationIncentive\r\n      * @dev Admin function to set liquidationIncentive\r\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\r\n        }\r\n\r\n        // Check de-scaled min <= newLiquidationIncentive <= max\r\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\r\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\r\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\r\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\r\n        }\r\n\r\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\r\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\r\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\r\n        }\r\n\r\n        // Save current value for use in log\r\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n        // Set liquidation incentive to new incentive\r\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n        // Emit event with old incentive, new incentive\r\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Add the market to the markets mapping and set it as listed\r\n      * @dev Admin function to set isListed and add support for the market\r\n      * @param vToken The address of the market (token) to list\r\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n      */\r\n    function _supportMarket(VToken vToken) external returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n        }\r\n\r\n        if (markets[address(vToken)].isListed) {\r\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n        }\r\n\r\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\r\n\r\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\r\n\r\n        _addMarketInternal(vToken);\r\n\r\n        emit MarketListed(vToken);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _addMarketInternal(VToken vToken) internal {\r\n        for (uint i = 0; i < allMarkets.length; i ++) {\r\n            require(allMarkets[i] != vToken, \"market already added\");\r\n        }\r\n        allMarkets.push(vToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Pause Guardian\r\n     * @param newPauseGuardian The address of the new Pause Guardian\r\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n     */\r\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for inclusion in log\r\n        address oldPauseGuardian = pauseGuardian;\r\n\r\n        // Store pauseGuardian with value newPauseGuardian\r\n        pauseGuardian = newPauseGuardian;\r\n\r\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\r\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setMintPaused(VToken vToken, bool state) public onlyListedMarket(vToken) validPauseState(state) returns (bool) {\r\n        mintGuardianPaused[address(vToken)] = state;\r\n        emit ActionPaused(vToken, \"Mint\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setBorrowPaused(VToken vToken, bool state) public onlyListedMarket(vToken) validPauseState(state) returns (bool) {\r\n        borrowGuardianPaused[address(vToken)] = state;\r\n        emit ActionPaused(vToken, \"Borrow\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setTransferPaused(bool state) public validPauseState(state) returns (bool) {\r\n        transferGuardianPaused = state;\r\n        emit ActionPaused(\"Transfer\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setSeizePaused(bool state) public validPauseState(state) returns (bool) {\r\n        seizeGuardianPaused = state;\r\n        emit ActionPaused(\"Seize\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setMintVAIPaused(bool state) public validPauseState(state) returns (bool) {\r\n        mintVAIGuardianPaused = state;\r\n        emit ActionPaused(\"MintVAI\", state);\r\n        return state;\r\n    }\r\n\r\n    function _setRepayVAIPaused(bool state) public validPauseState(state) returns (bool) {\r\n        repayVAIGuardianPaused = state;\r\n        emit ActionPaused(\"RepayVAI\", state);\r\n        return state;\r\n    }\r\n    /**\r\n     * @notice Set whole protocol pause/unpause state\r\n     */\r\n    function _setProtocolPaused(bool state) public onlyAdmin returns(bool) {\r\n        protocolPaused = state;\r\n        emit ActionProtocolPaused(state);\r\n        return state;\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new VAI controller\r\n      * @dev Admin function to set a new VAI controller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAICONTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        VAIControllerInterface oldRate = vaiController;\r\n        vaiController = vaiController_;\r\n        emit NewVAIController(oldRate, vaiController_);\r\n    }\r\n\r\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAI_MINT_RATE_CHECK);\r\n        }\r\n\r\n        uint oldVAIMintRate = vaiMintRate;\r\n        vaiMintRate = newVAIMintRate;\r\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _become(Unitroller unitroller) public {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\r\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\r\n    }\r\n\r\n    /*** Venus Distribution ***/\r\n\r\n    /**\r\n     * @notice Recalculate and update Venus speeds for all Venus markets\r\n     */\r\n    function refreshVenusSpeeds() public {\r\n        require(msg.sender == tx.origin, \"only externally owned accounts can\");\r\n        refreshVenusSpeedsInternal();\r\n    }\r\n\r\n    function refreshVenusSpeedsInternal() internal {\r\n        uint i;\r\n        VToken vToken;\r\n\r\n        for (i = 0; i < allMarkets.length; i++) {\r\n            vToken = allMarkets[i];\r\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n            updateVenusSupplyIndex(address(vToken));\r\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n        }\r\n\r\n        Exp memory totalUtility = Exp({mantissa: 0});\r\n        Exp[] memory utilities = new Exp[](allMarkets.length);\r\n        for (i = 0; i < allMarkets.length; i++) {\r\n            vToken = allMarkets[i];\r\n            if (markets[address(vToken)].isVenus) {\r\n                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(vToken)});\r\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\r\n                utilities[i] = utility;\r\n                totalUtility = add_(totalUtility, utility);\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < allMarkets.length; i++) {\r\n            vToken = allMarkets[i];\r\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\r\n            venusSpeeds[address(vToken)] = newSpeed;\r\n            emit VenusSpeedUpdated(vToken, newSpeed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the supply index\r\n     * @param vToken The market whose supply index to update\r\n     */\r\n    function updateVenusSupplyIndex(address vToken) internal {\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        uint supplySpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\r\n        if (deltaBlocks > 0 && supplySpeed > 0) {\r\n            uint supplyTokens = VToken(vToken).totalSupply();\r\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\r\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\r\n            venusSupplyState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the borrow index\r\n     * @param vToken The market whose borrow index to update\r\n     */\r\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        uint borrowSpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\r\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\r\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\r\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\r\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\r\n            venusBorrowState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to by updating the VAI minter index\r\n     */\r\n    function updateVenusVAIMintIndex() internal {\r\n        if (address(vaiController) != address(0)) {\r\n            vaiController.updateVenusVAIMintIndex();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\r\n     * @param vToken The market in which the supplier is interacting\r\n     * @param supplier The address of the supplier to distribute XVS to\r\n     */\r\n    function distributeSupplierVenus(address vToken, address supplier, bool distributeAll) internal {\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\r\n        Double memory supplierIndex = Double({mantissa: venusSupplierIndex[vToken][supplier]});\r\n        venusSupplierIndex[vToken][supplier] = supplyIndex.mantissa;\r\n\r\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\r\n            supplierIndex.mantissa = venusInitialIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\r\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\r\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\r\n        uint supplierAccrued = add_(venusAccrued[supplier], supplierDelta);\r\n        venusAccrued[supplier] = transferXVS(supplier, supplierAccrued, distributeAll ? 0 : venusClaimThreshold);\r\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\r\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vToken The market in which the borrower is interacting\r\n     * @param borrower The address of the borrower to distribute XVS to\r\n     */\r\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex, bool distributeAll) internal {\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\r\n        Double memory borrowerIndex = Double({mantissa: venusBorrowerIndex[vToken][borrower]});\r\n        venusBorrowerIndex[vToken][borrower] = borrowIndex.mantissa;\r\n\r\n        if (borrowerIndex.mantissa > 0) {\r\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\r\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\r\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\r\n            uint borrowerAccrued = add_(venusAccrued[borrower], borrowerDelta);\r\n            venusAccrued[borrower] = transferXVS(borrower, borrowerAccrued, distributeAll ? 0 : venusClaimThreshold);\r\n            emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a VAI minter and possibly transfer it to them\r\n     * @dev VAI minters will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vaiMinter The address of the VAI minter to distribute XVS to\r\n     */\r\n    function distributeVAIMinterVenus(address vaiMinter, bool distributeAll) internal {\r\n        if (address(vaiController) != address(0)) {\r\n            uint vaiMinterAccrued;\r\n            uint vaiMinterDelta;\r\n            uint vaiMintIndexMantissa;\r\n            uint err;\r\n            (err, vaiMinterAccrued, vaiMinterDelta, vaiMintIndexMantissa) = vaiController.calcDistributeVAIMinterVenus(vaiMinter);\r\n            if (err == uint(Error.NO_ERROR)) {\r\n                venusAccrued[vaiMinter] = transferXVS(vaiMinter, vaiMinterAccrued, distributeAll ? 0 : venusClaimThreshold);\r\n                emit DistributedVAIMinterVenus(vaiMinter, vaiMinterDelta, vaiMintIndexMantissa);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to the user, if they are above the threshold\r\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer XVS to\r\n     * @param userAccrued The amount of XVS to (possibly) transfer\r\n     * @return The amount of XVS which was NOT transferred to the user\r\n     */\r\n    function transferXVS(address user, uint userAccrued, uint threshold) internal returns (uint) {\r\n        if (userAccrued >= threshold && userAccrued > 0) {\r\n            XVS xvs = XVS(getXVSAddress());\r\n            uint xvsRemaining = xvs.balanceOf(address(this));\r\n            if (userAccrued <= xvsRemaining) {\r\n                xvs.transfer(user, userAccrued);\r\n                return 0;\r\n            }\r\n        }\r\n        return userAccrued;\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\r\n     * @param holder The address to claim XVS for\r\n     */\r\n    function claimVenus(address holder) public {\r\n        return claimVenus(holder, allMarkets);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in the specified markets\r\n     * @param holder The address to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     */\r\n    function claimVenus(address holder, VToken[] memory vTokens) public {\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = holder;\r\n        claimVenus(holders, vTokens, true, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all xvs accrued by the holders\r\n     * @param holders The addresses to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     * @param borrowers Whether or not to claim XVS earned by borrowing\r\n     * @param suppliers Whether or not to claim XVS earned by supplying\r\n     */\r\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\r\n        uint j;\r\n        updateVenusVAIMintIndex();\r\n        for (j = 0; j < holders.length; j++) {\r\n            distributeVAIMinterVenus(holders[j], true);\r\n        }\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            VToken vToken = vTokens[i];\r\n            require(markets[address(vToken)].isListed, \"not listed market\");\r\n            if (borrowers) {\r\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex, true);\r\n                }\r\n            }\r\n            if (suppliers) {\r\n                updateVenusSupplyIndex(address(vToken));\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeSupplierVenus(address(vToken), holders[j], true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*** Venus Distribution Admin ***/\r\n\r\n    /**\r\n     * @notice Set the amount of XVS distributed per block\r\n     * @param venusRate_ The amount of XVS wei per block to distribute\r\n     */\r\n    function _setVenusRate(uint venusRate_) public onlyAdmin {\r\n        uint oldRate = venusRate;\r\n        venusRate = venusRate_;\r\n        emit NewVenusRate(oldRate, venusRate_);\r\n\r\n        refreshVenusSpeedsInternal();\r\n    }\r\n\r\n    /**\r\n     * @notice Add markets to venusMarkets, allowing them to earn XVS in the flywheel\r\n     * @param vTokens The addresses of the markets to add\r\n     */\r\n    function _addVenusMarkets(address[] calldata vTokens) external onlyAdmin {\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            _addVenusMarketInternal(vTokens[i]);\r\n        }\r\n\r\n        refreshVenusSpeedsInternal();\r\n    }\r\n\r\n    function _addVenusMarketInternal(address vToken) internal {\r\n        Market storage market = markets[vToken];\r\n        require(market.isListed, \"venus market is not listed\");\r\n        require(!market.isVenus, \"venus market already added\");\r\n\r\n        market.isVenus = true;\r\n        emit MarketVenus(VToken(vToken), true);\r\n\r\n        if (venusSupplyState[vToken].index == 0 && venusSupplyState[vToken].block == 0) {\r\n            venusSupplyState[vToken] = VenusMarketState({\r\n                index: venusInitialIndex,\r\n                block: safe32(getBlockNumber(), \"block number overflows\")\r\n            });\r\n        }\r\n\r\n        if (venusBorrowState[vToken].index == 0 && venusBorrowState[vToken].block == 0) {\r\n            venusBorrowState[vToken] = VenusMarketState({\r\n                index: venusInitialIndex,\r\n                block: safe32(getBlockNumber(), \"block number overflows\")\r\n            });\r\n        }\r\n    }\r\n\r\n    function _initializeVenusVAIState(uint blockNumber) public {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        if (address(vaiController) != address(0)) {\r\n            vaiController._initializeVenusVAIState(blockNumber);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a market from venusMarkets, preventing it from earning XVS in the flywheel\r\n     * @param vToken The address of the market to drop\r\n     */\r\n    function _dropVenusMarket(address vToken) public onlyAdmin {\r\n        Market storage market = markets[vToken];\r\n        require(market.isVenus == true, \"not venus market\");\r\n\r\n        market.isVenus = false;\r\n        emit MarketVenus(VToken(vToken), false);\r\n\r\n        refreshVenusSpeedsInternal();\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() public view returns (VToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the XVS token\r\n     * @return The address of XVS\r\n     */\r\n    function getXVSAddress() public view returns (address) {\r\n        return 0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63;\r\n    }\r\n\r\n    /*** VAI functions ***/\r\n\r\n    /**\r\n     * @notice Set the minted VAI amount of the `owner`\r\n     * @param owner The address of the account to set\r\n     * @param amount The amount of VAI to set to the account\r\n     * @return The number of minted VAI by `owner`\r\n     */\r\n    function setMintedVAIOf(address owner, uint amount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\r\n        // Check caller is vaiController\r\n        if (msg.sender != address(vaiController)) {\r\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\r\n        }\r\n        mintedVAIs[owner] = amount;\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint VAI\r\n     */\r\n    function mintVAI(uint mintVAIAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintVAIGuardianPaused, \"mintVAI is paused\");\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusVAIMintIndex();\r\n        distributeVAIMinterVenus(msg.sender, false);\r\n        return vaiController.mintVAI(msg.sender, mintVAIAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Repay VAI\r\n     */\r\n    function repayVAI(uint repayVAIAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!repayVAIGuardianPaused, \"repayVAI is paused\");\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusVAIMintIndex();\r\n        distributeVAIMinterVenus(msg.sender, false);\r\n        return vaiController.repayVAI(msg.sender, repayVAIAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the minted VAI amount of the `owner`\r\n     * @param owner The address of the account to query\r\n     * @return The number of minted VAI by `owner`\r\n     */\r\n    function mintedVAIOf(address owner) external view returns (uint) {\r\n        return mintedVAIs[owner];\r\n    }\r\n\r\n    /**\r\n     * @notice Get Mintable VAI amount\r\n     */\r\n    function getMintableVAI(address minter) external view returns (uint, uint) {\r\n        return vaiController.getMintableVAI(minter);\r\n    }\r\n}\r\n"
    },
    "contracts/ComptrollerG3.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./Exponential.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\nimport \"./Unitroller.sol\";\r\nimport \"./Governance/XVS.sol\";\r\nimport \"./VAI/VAI.sol\";\r\n\r\n/**\r\n * @title Venus's Comptroller Contract\r\n * @author Venus\r\n */\r\ncontract ComptrollerG3 is ComptrollerV3Storage, ComptrollerInterfaceG1, ComptrollerErrorReporter, Exponential {\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketListed(VToken vToken);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\r\n\r\n    /// @notice Emitted when a collateral factor is changed by admin\r\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\r\n\r\n    /// @notice Emitted when maxAssets is changed by admin\r\n    event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);\r\n\r\n    /// @notice Emitted when price oracle is changed\r\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\r\n\r\n    /// @notice Emitted when VAI Vault info is changed\r\n    event NewVAIVaultInfo(address vault_, uint releaseStartBlock_, uint releaseInterval_);\r\n\r\n    /// @notice Emitted when pause guardian is changed\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    /// @notice Emitted when an action is paused globally\r\n    event ActionPaused(string action, bool pauseState);\r\n\r\n    /// @notice Emitted when an action is paused on a market\r\n    event ActionPaused(VToken vToken, string action, bool pauseState);\r\n\r\n    /// @notice Emitted when Venus VAI Vault rate is changed\r\n    event NewVenusVAIVaultRate(uint oldVenusVAIVaultRate, uint newVenusVAIVaultRate);\r\n\r\n    /// @notice Emitted when a new Venus speed is calculated for a market\r\n    event VenusSpeedUpdated(VToken indexed vToken, uint newSpeed);\r\n\r\n    /// @notice Emitted when XVS is distributed to a supplier\r\n    event DistributedSupplierVenus(VToken indexed vToken, address indexed supplier, uint venusDelta, uint venusSupplyIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a borrower\r\n    event DistributedBorrowerVenus(VToken indexed vToken, address indexed borrower, uint venusDelta, uint venusBorrowIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a VAI minter\r\n    event DistributedVAIMinterVenus(address indexed vaiMinter, uint venusDelta, uint venusVAIMintIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to VAI Vault\r\n    event DistributedVAIVaultVenus(uint amount);\r\n\r\n    /// @notice Emitted when VAIController is changed\r\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\r\n\r\n    /// @notice Emitted when VAI mint rate is changed by admin\r\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\r\n\r\n    /// @notice Emitted when protocol state is changed by admin\r\n    event ActionProtocolPaused(bool state);\r\n\r\n    /// @notice Emitted when borrow cap for a vToken is changed\r\n    event NewBorrowCap(VToken indexed vToken, uint newBorrowCap);\r\n\r\n    /// @notice Emitted when borrow cap guardian is changed\r\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\r\n\r\n    /// @notice The initial Venus index for a market\r\n    uint224 public constant venusInitialIndex = 1e36;\r\n\r\n    // closeFactorMantissa must be strictly greater than this value\r\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n    // closeFactorMantissa must not exceed this value\r\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // No collateralFactorMantissa may exceed this value\r\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // liquidationIncentiveMantissa must be no less than this value\r\n    uint internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\r\n\r\n    // liquidationIncentiveMantissa must be no greater than this value\r\n    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyProtocolAllowed {\r\n        require(!protocolPaused, \"protocol is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyListedMarket(VToken vToken) {\r\n        require(markets[address(vToken)].isListed, \"venus market is not listed\");\r\n        _;\r\n    }\r\n\r\n    modifier validPauseState(bool state) {\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n        _;\r\n    }\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\r\n        return accountAssets[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account is entered in the given asset\r\n     * @param account The address of the account to check\r\n     * @param vToken The vToken to check\r\n     * @return True if the account is in the asset, otherwise false.\r\n     */\r\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\r\n        return markets[address(vToken)].accountMembership[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add assets to be included in account liquidity calculation\r\n     * @param vTokens The list of addresses of the vToken markets to be enabled\r\n     * @return Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory) {\r\n        uint len = vTokens.length;\r\n\r\n        uint[] memory results = new uint[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            results[i] = uint(addToMarketInternal(VToken(vTokens[i]), msg.sender));\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n     * @param vToken The market to enter\r\n     * @param borrower The address of the account to modify\r\n     * @return Success indicator for whether the market was entered\r\n     */\r\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\r\n        Market storage marketToJoin = markets[address(vToken)];\r\n\r\n        if (!marketToJoin.isListed) {\r\n            // market is not listed, cannot join\r\n            return Error.MARKET_NOT_LISTED;\r\n        }\r\n\r\n        if (marketToJoin.accountMembership[borrower]) {\r\n            // already joined\r\n            return Error.NO_ERROR;\r\n        }\r\n\r\n        if (accountAssets[borrower].length >= maxAssets)  {\r\n            // no space, cannot join\r\n            return Error.TOO_MANY_ASSETS;\r\n        }\r\n\r\n        // survived the gauntlet, add to list\r\n        // NOTE: we store these somewhat redundantly as a significant optimization\r\n        //  this avoids having to iterate through the list for the most common use cases\r\n        //  that is, only when we need to perform liquidity checks\r\n        //  and not whenever we want to check if an account is in a particular market\r\n        marketToJoin.accountMembership[borrower] = true;\r\n        accountAssets[borrower].push(vToken);\r\n\r\n        emit MarketEntered(vToken, borrower);\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes asset from sender's account liquidity calculation\r\n     * @dev Sender must not have an outstanding borrow balance in the asset,\r\n     *  or be providing necessary collateral for an outstanding borrow.\r\n     * @param vTokenAddress The address of the asset to be removed\r\n     * @return Whether or not the account successfully exited the market\r\n     */\r\n    function exitMarket(address vTokenAddress) external returns (uint) {\r\n        VToken vToken = VToken(vTokenAddress);\r\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\r\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\r\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\r\n\r\n        /* Fail if the sender has a borrow balance */\r\n        if (amountOwed != 0) {\r\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\r\n        }\r\n\r\n        /* Fail if the sender is not permitted to redeem all of their tokens */\r\n        uint allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\r\n        }\r\n\r\n        Market storage marketToExit = markets[address(vToken)];\r\n\r\n        /* Return true if the sender is not already ‘in’ the market */\r\n        if (!marketToExit.accountMembership[msg.sender]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Set vToken account membership to false */\r\n        delete marketToExit.accountMembership[msg.sender];\r\n\r\n        /* Delete vToken from the account’s list of assets */\r\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\r\n        VToken[] storage userAssetList = accountAssets[msg.sender];\r\n        uint len = userAssetList.length;\r\n        uint i;\r\n        for (; i < len; i++) {\r\n            if (userAssetList[i] == vToken) {\r\n                userAssetList[i] = userAssetList[len - 1];\r\n                userAssetList.length--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // We *must* have found the asset in the list or our redundant data structure is broken\r\n        assert(i < len);\r\n\r\n        emit MarketExited(vToken, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to mint tokens in the given market\r\n     * @param vToken The market to verify the mint against\r\n     * @param minter The account which would get the minted tokens\r\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function mintAllowed(address vToken, address minter, uint mintAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintGuardianPaused[vToken], \"mint is paused\");\r\n\r\n        // Shh - currently unused\r\n        mintAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, minter);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates mint and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being minted\r\n     * @param minter The address minting the tokens\r\n     * @param actualMintAmount The amount of the underlying asset being minted\r\n     * @param mintTokens The number of tokens being minted\r\n     */\r\n    function mintVerify(address vToken, address minter, uint actualMintAmount, uint mintTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        minter;\r\n        actualMintAmount;\r\n        mintTokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n     * @param vToken The market to verify the redeem against\r\n     * @param redeemer The account which would redeem the tokens\r\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\r\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external onlyProtocolAllowed returns (uint) {\r\n        uint allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, redeemer);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function redeemAllowedInternal(address vToken, address redeemer, uint redeemTokens) internal view returns (uint) {\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n        if (!markets[vToken].accountMembership[redeemer]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, VToken(vToken), redeemTokens, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates redeem and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being redeemed\r\n     * @param redeemer The address redeeming the tokens\r\n     * @param redeemAmount The amount of the underlying asset being redeemed\r\n     * @param redeemTokens The number of tokens being redeemed\r\n     */\r\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        redeemer;\r\n\r\n        // Require tokens is zero or amount is also zero\r\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param vToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!borrowGuardianPaused[vToken], \"borrow is paused\");\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (!markets[vToken].accountMembership[borrower]) {\r\n            // only vTokens may call borrowAllowed if borrower not in market\r\n            require(msg.sender == vToken, \"sender must be vToken\");\r\n\r\n            // attempt to add borrower to the market\r\n            Error err = addToMarketInternal(VToken(vToken), borrower);\r\n            if (err != Error.NO_ERROR) {\r\n                return uint(err);\r\n            }\r\n        }\r\n\r\n        if (oracle.getUnderlyingPrice(VToken(vToken)) == 0) {\r\n            return uint(Error.PRICE_ERROR);\r\n        }\r\n\r\n        uint borrowCap = borrowCaps[vToken];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint totalBorrows = VToken(vToken).totalBorrows();\r\n            (MathError mathErr, uint nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);\r\n            require(mathErr == MathError.NO_ERROR, \"total borrows overflow\");\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(vToken), 0, borrowAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates borrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset whose underlying is being borrowed\r\n     * @param borrower The address borrowing the underlying\r\n     * @param borrowAmount The amount of the underlying asset requested to borrow\r\n     */\r\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        borrower;\r\n        borrowAmount;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n     * @param vToken The market to verify the repay against\r\n     * @param payer The account which would repay the asset\r\n     * @param borrower The account which would repay the asset\r\n     * @param repayAmount The amount of the underlying asset the account would repay\r\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function repayBorrowAllowed(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        payer;\r\n        borrower;\r\n        repayAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being repaid\r\n     * @param payer The address repaying the borrow\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function repayBorrowVerify(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint borrowerIndex) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        payer;\r\n        borrower;\r\n        actualRepayAmount;\r\n        borrowerIndex;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the liquidation should be allowed to occur\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param repayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowAllowed(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        liquidator;\r\n\r\n        if (!markets[vTokenBorrowed].isListed || !markets[vTokenCollateral].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* The borrower must have shortfall in order to be liquidatable */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(0), 0, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall == 0) {\r\n            return uint(Error.INSUFFICIENT_SHORTFALL);\r\n        }\r\n\r\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n        uint borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\r\n        (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return uint(Error.MATH_ERROR);\r\n        }\r\n        if (repayAmount > maxClose) {\r\n            return uint(Error.TOO_MUCH_REPAY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowVerify(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenBorrowed;\r\n        vTokenCollateral;\r\n        liquidator;\r\n        borrower;\r\n        actualRepayAmount;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the seizing of assets should be allowed to occur\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeAllowed(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!seizeGuardianPaused, \"seize is paused\");\r\n\r\n        // Shh - currently unused\r\n        seizeTokens;\r\n\r\n        if (!markets[vTokenCollateral].isListed || !markets[vTokenBorrowed].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\r\n            return uint(Error.COMPTROLLER_MISMATCH);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vTokenCollateral);\r\n        distributeSupplierVenus(vTokenCollateral, borrower);\r\n        distributeSupplierVenus(vTokenCollateral, liquidator);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates seize and reverts on rejection. May emit logs.\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeVerify(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenCollateral;\r\n        vTokenBorrowed;\r\n        liquidator;\r\n        borrower;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n     * @param vToken The market to verify the transfer against\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!transferGuardianPaused, \"transfer is paused\");\r\n\r\n        // Currently the only consideration is whether or not\r\n        //  the src is allowed to redeem this many tokens\r\n        uint allowed = redeemAllowedInternal(vToken, src, transferTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, src);\r\n        distributeSupplierVenus(vToken, dst);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates transfer and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being transferred\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     */\r\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        src;\r\n        dst;\r\n        transferTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountLiquidityLocalVars {\r\n        uint sumCollateral;\r\n        uint sumBorrowPlusEffects;\r\n        uint vTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code (semi-opaque),\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(0), 0, 0);\r\n\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidity(\r\n        address account,\r\n        address vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(vTokenModify), redeemTokens, borrowAmount);\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\r\n     *  without calculating accumulated interest.\r\n     * @return (possible error code,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidityInternal(\r\n        address account,\r\n        VToken vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) internal view returns (Error, uint, uint) {\r\n\r\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n        MathError mErr;\r\n\r\n        // For each asset the account is in\r\n        VToken[] memory assets = accountAssets[account];\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            VToken asset = assets[i];\r\n\r\n            // Read the balances and exchange rate from the vToken\r\n            (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\r\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                return (Error.SNAPSHOT_ERROR, 0, 0);\r\n            }\r\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                return (Error.PRICE_ERROR, 0, 0);\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\r\n            (mErr, vars.tokensToDenom) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);\r\n            if (mErr != MathError.NO_ERROR) {\r\n                return (Error.MATH_ERROR, 0, 0);\r\n            }\r\n\r\n            // sumCollateral += tokensToDenom * vTokenBalance\r\n            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToDenom, vars.vTokenBalance, vars.sumCollateral);\r\n            if (mErr != MathError.NO_ERROR) {\r\n                return (Error.MATH_ERROR, 0, 0);\r\n            }\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n            if (mErr != MathError.NO_ERROR) {\r\n                return (Error.MATH_ERROR, 0, 0);\r\n            }\r\n\r\n            // Calculate effects of interacting with vTokenModify\r\n            if (asset == vTokenModify) {\r\n                // redeem effect\r\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\r\n                if (mErr != MathError.NO_ERROR) {\r\n                    return (Error.MATH_ERROR, 0, 0);\r\n                }\r\n\r\n                // borrow effect\r\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\r\n                if (mErr != MathError.NO_ERROR) {\r\n                    return (Error.MATH_ERROR, 0, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        /// @dev VAI Integration^\r\n        (mErr, vars.sumBorrowPlusEffects) = addUInt(vars.sumBorrowPlusEffects, mintedVAIs[account]);\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (Error.MATH_ERROR, 0, 0);\r\n        }\r\n        /// @dev VAI Integration$\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\r\n     * @param vTokenBorrowed The address of the borrowed vToken\r\n     * @param vTokenCollateral The address of the collateral vToken\r\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\r\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateCalculateSeizeTokens(address vTokenBorrowed, address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(VToken(vTokenBorrowed));\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(VToken(vTokenCollateral));\r\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n        MathError mathErr;\r\n\r\n        (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (mathErr, denominator) = mulExp(priceCollateralMantissa, exchangeRateMantissa);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (mathErr, ratio) = divExp(numerator, denominator);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (mathErr, seizeTokens) = mulScalarTruncate(ratio, actualRepayAmount);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new price oracle for the comptroller\r\n      * @dev Admin function to set a new price oracle\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\r\n        }\r\n\r\n        // Track the old oracle for the comptroller\r\n        PriceOracle oldOracle = oracle;\r\n\r\n        // Set comptroller's oracle to newOracle\r\n        oracle = newOracle;\r\n\r\n        // Emit NewPriceOracle(oldOracle, newOracle)\r\n        emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the closeFactor used when liquidating borrows\r\n      * @dev Admin function to set closeFactor\r\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\r\n        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\r\n        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\r\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\r\n        }\r\n\r\n        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCloseFactorExp)) {\r\n            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\r\n        }\r\n\r\n        uint oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = newCloseFactorMantissa;\r\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the collateralFactor for a market\r\n      * @dev Admin function to set per-market collateralFactor\r\n      * @param vToken The market to set the factor on\r\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        // Verify market is listed\r\n        Market storage market = markets[address(vToken)];\r\n        if (!market.isListed) {\r\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\r\n        }\r\n\r\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\r\n\r\n        // Check collateral factor <= 0.9\r\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\r\n        }\r\n\r\n        // If collateral factor != 0, fail if price == 0\r\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\r\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\r\n        }\r\n\r\n        // Set market's collateral factor to new collateral factor, remember old value\r\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n        // Emit event with asset, old collateral factor, and new collateral factor\r\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets maxAssets which controls how many markets can be entered\r\n      * @dev Admin function to set maxAssets\r\n      * @param newMaxAssets New max assets\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\r\n        }\r\n\r\n        uint oldMaxAssets = maxAssets;\r\n        maxAssets = newMaxAssets;\r\n        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets liquidationIncentive\r\n      * @dev Admin function to set liquidationIncentive\r\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\r\n        }\r\n\r\n        // Check de-scaled min <= newLiquidationIncentive <= max\r\n        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\r\n        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\r\n        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\r\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\r\n        }\r\n\r\n        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\r\n        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\r\n            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\r\n        }\r\n\r\n        // Save current value for use in log\r\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n        // Set liquidation incentive to new incentive\r\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n        // Emit event with old incentive, new incentive\r\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Add the market to the markets mapping and set it as listed\r\n      * @dev Admin function to set isListed and add support for the market\r\n      * @param vToken The address of the market (token) to list\r\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n      */\r\n    function _supportMarket(VToken vToken) external returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n        }\r\n\r\n        if (markets[address(vToken)].isListed) {\r\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n        }\r\n\r\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\r\n\r\n        // Note that isVenus is not in active use anymore\r\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\r\n\r\n        _addMarketInternal(vToken);\r\n\r\n        emit MarketListed(vToken);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _addMarketInternal(VToken vToken) internal {\r\n        for (uint i = 0; i < allMarkets.length; i ++) {\r\n            require(allMarkets[i] != vToken, \"market already added\");\r\n        }\r\n        allMarkets.push(vToken);\r\n    }\r\n\r\n    /**\r\n      * @notice Set the given borrow caps for the given vToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\r\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\r\n      * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\r\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\r\n      */\r\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint[] calldata newBorrowCaps) external {\r\n    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\r\n\r\n        uint numMarkets = vTokens.length;\r\n        uint numBorrowCaps = newBorrowCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\r\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Borrow Cap Guardian\r\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\r\n     */\r\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\r\n        require(msg.sender == admin, \"only admin can set borrow cap guardian\");\r\n\r\n        // Save current value for inclusion in log\r\n        address oldBorrowCapGuardian = borrowCapGuardian;\r\n\r\n        // Store borrowCapGuardian with value newBorrowCapGuardian\r\n        borrowCapGuardian = newBorrowCapGuardian;\r\n\r\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\r\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\r\n    }\r\n\r\n    /**\r\n     * @notice Set whole protocol pause/unpause state\r\n     */\r\n    function _setProtocolPaused(bool state) public onlyAdmin returns(bool) {\r\n        protocolPaused = state;\r\n        emit ActionProtocolPaused(state);\r\n        return state;\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new VAI controller\r\n      * @dev Admin function to set a new VAI controller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAICONTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        VAIControllerInterface oldRate = vaiController;\r\n        vaiController = vaiController_;\r\n        emit NewVAIController(oldRate, vaiController_);\r\n    }\r\n\r\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAI_MINT_RATE_CHECK);\r\n        }\r\n\r\n        uint oldVAIMintRate = vaiMintRate;\r\n        vaiMintRate = newVAIMintRate;\r\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _become(Unitroller unitroller) public {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\r\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\r\n     */\r\n    function adminOrInitializing() internal view returns (bool) {\r\n        return msg.sender == admin || msg.sender == comptrollerImplementation;\r\n    }\r\n\r\n    /*** Venus Distribution ***/\r\n\r\n    function setVenusSpeedInternal(VToken vToken, uint venusSpeed) internal {\r\n        uint currentVenusSpeed = venusSpeeds[address(vToken)];\r\n        if (currentVenusSpeed != 0) {\r\n            // note that XVS speed could be set to 0 to halt liquidity rewards for a market\r\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n            updateVenusSupplyIndex(address(vToken));\r\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n        } else if (venusSpeed != 0) {\r\n            // Add the XVS market\r\n            Market storage market = markets[address(vToken)];\r\n            require(market.isListed == true, \"venus market is not listed\");\r\n\r\n            if (venusSupplyState[address(vToken)].index == 0 && venusSupplyState[address(vToken)].block == 0) {\r\n                venusSupplyState[address(vToken)] = VenusMarketState({\r\n                    index: venusInitialIndex,\r\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n            }\r\n\r\n\r\n        if (venusBorrowState[address(vToken)].index == 0 && venusBorrowState[address(vToken)].block == 0) {\r\n                venusBorrowState[address(vToken)] = VenusMarketState({\r\n                    index: venusInitialIndex,\r\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n            }\r\n        }\r\n\r\n        if (currentVenusSpeed != venusSpeed) {\r\n            venusSpeeds[address(vToken)] = venusSpeed;\r\n            emit VenusSpeedUpdated(vToken, venusSpeed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the supply index\r\n     * @param vToken The market whose supply index to update\r\n     */\r\n    function updateVenusSupplyIndex(address vToken) internal {\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        uint supplySpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\r\n        if (deltaBlocks > 0 && supplySpeed > 0) {\r\n            uint supplyTokens = VToken(vToken).totalSupply();\r\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\r\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\r\n            venusSupplyState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the borrow index\r\n     * @param vToken The market whose borrow index to update\r\n     */\r\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        uint borrowSpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\r\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\r\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\r\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\r\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\r\n            venusBorrowState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\r\n     * @param vToken The market in which the supplier is interacting\r\n     * @param supplier The address of the supplier to distribute XVS to\r\n     */\r\n    function distributeSupplierVenus(address vToken, address supplier) internal {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\r\n        Double memory supplierIndex = Double({mantissa: venusSupplierIndex[vToken][supplier]});\r\n        venusSupplierIndex[vToken][supplier] = supplyIndex.mantissa;\r\n\r\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\r\n            supplierIndex.mantissa = venusInitialIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\r\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\r\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\r\n        uint supplierAccrued = add_(venusAccrued[supplier], supplierDelta);\r\n        venusAccrued[supplier] = supplierAccrued;\r\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\r\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vToken The market in which the borrower is interacting\r\n     * @param borrower The address of the borrower to distribute XVS to\r\n     */\r\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\r\n        Double memory borrowerIndex = Double({mantissa: venusBorrowerIndex[vToken][borrower]});\r\n        venusBorrowerIndex[vToken][borrower] = borrowIndex.mantissa;\r\n\r\n        if (borrowerIndex.mantissa > 0) {\r\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\r\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\r\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\r\n            uint borrowerAccrued = add_(venusAccrued[borrower], borrowerDelta);\r\n            venusAccrued[borrower] = borrowerAccrued;\r\n            emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a VAI minter and possibly transfer it to them\r\n     * @dev VAI minters will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vaiMinter The address of the VAI minter to distribute XVS to\r\n     */\r\n    function distributeVAIMinterVenus(address vaiMinter, bool distributeAll) public {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        if (address(vaiController) != address(0)) {\r\n            uint vaiMinterAccrued;\r\n            uint vaiMinterDelta;\r\n            uint vaiMintIndexMantissa;\r\n            uint err;\r\n            (err, vaiMinterAccrued, vaiMinterDelta, vaiMintIndexMantissa) = vaiController.calcDistributeVAIMinterVenus(vaiMinter);\r\n            if (err == uint(Error.NO_ERROR)) {\r\n                venusAccrued[vaiMinter] = vaiMinterAccrued;\r\n                emit DistributedVAIMinterVenus(vaiMinter, vaiMinterDelta, vaiMintIndexMantissa);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\r\n     * @param holder The address to claim XVS for\r\n     */\r\n    function claimVenus(address holder) public {\r\n        return claimVenus(holder, allMarkets);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in the specified markets\r\n     * @param holder The address to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     */\r\n    function claimVenus(address holder, VToken[] memory vTokens) public {\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = holder;\r\n        claimVenus(holders, vTokens, true, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all xvs accrued by the holders\r\n     * @param holders The addresses to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     * @param borrowers Whether or not to claim XVS earned by borrowing\r\n     * @param suppliers Whether or not to claim XVS earned by supplying\r\n     */\r\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\r\n        uint j;\r\n        if(address(vaiController) != address(0)) {\r\n            vaiController.updateVenusVAIMintIndex();\r\n        }\r\n        for (j = 0; j < holders.length; j++) {\r\n            distributeVAIMinterVenus(holders[j], true);\r\n            venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\r\n        }\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            VToken vToken = vTokens[i];\r\n            require(markets[address(vToken)].isListed, \"not listed market\");\r\n            if (borrowers) {\r\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\r\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\r\n                }\r\n            }\r\n            if (suppliers) {\r\n                updateVenusSupplyIndex(address(vToken));\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeSupplierVenus(address(vToken), holders[j]);\r\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to the user\r\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer XVS to\r\n     * @param amount The amount of XVS to (possibly) transfer\r\n     * @return The amount of XVS which was NOT transferred to the user\r\n     */\r\n    function grantXVSInternal(address user, uint amount) internal returns (uint) {\r\n        XVS xvs = XVS(getXVSAddress());\r\n        uint venusRemaining = xvs.balanceOf(address(this));\r\n        if (amount > 0 && amount <= venusRemaining) {\r\n            xvs.transfer(user, amount);\r\n            return 0;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /*** Venus Distribution Admin ***/\r\n\r\n    /**\r\n     * @notice Set the amount of XVS distributed per block to VAI Vault\r\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\r\n     */\r\n    function _setVenusVAIVaultRate(uint venusVAIVaultRate_) public {\r\n        require(msg.sender == admin, \"only admin can\");\r\n\r\n        uint oldVenusVAIVaultRate = venusVAIVaultRate;\r\n        venusVAIVaultRate = venusVAIVaultRate_;\r\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the VAI Vault infos\r\n     * @param vault_ The address of the VAI Vault\r\n     * @param releaseStartBlock_ The start block of release to VAI Vault\r\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\r\n     */\r\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) public {\r\n        require(msg.sender == admin, \"only admin can\");\r\n\r\n        vaiVaultAddress = vault_;\r\n        releaseStartBlock = releaseStartBlock_;\r\n        minReleaseAmount = minReleaseAmount_;\r\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\r\n    }\r\n\r\n    /**\r\n     * @notice Set XVS speed for a single market\r\n     * @param vToken The market whose XVS speed to update\r\n     * @param venusSpeed New XVS speed for market\r\n     */\r\n    function _setVenusSpeed(VToken vToken, uint venusSpeed) public {\r\n        require(adminOrInitializing(), \"only admin can set venus speed\");\r\n        setVenusSpeedInternal(vToken, venusSpeed);\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() public view returns (VToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the XVS token\r\n     * @return The address of XVS\r\n     */\r\n    function getXVSAddress() public view returns (address) {\r\n        return 0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63;\r\n    }\r\n\r\n    /*** VAI functions ***/\r\n\r\n    /**\r\n     * @notice Set the minted VAI amount of the `owner`\r\n     * @param owner The address of the account to set\r\n     * @param amount The amount of VAI to set to the account\r\n     * @return The number of minted VAI by `owner`\r\n     */\r\n    function setMintedVAIOf(address owner, uint amount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\r\n        // Check caller is vaiController\r\n        if (msg.sender != address(vaiController)) {\r\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\r\n        }\r\n        mintedVAIs[owner] = amount;\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to VAI Vault\r\n     */\r\n    function releaseToVault() public {\r\n        if(releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\r\n            return;\r\n        }\r\n\r\n        XVS xvs = XVS(getXVSAddress());\r\n\r\n        uint256 xvsBalance = xvs.balanceOf(address(this));\r\n        if(xvsBalance == 0) {\r\n            return;\r\n        }\r\n\r\n\r\n        uint256 actualAmount;\r\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\r\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\r\n        uint256 _releaseAmount = mul_(venusVAIVaultRate, deltaBlocks);\r\n\r\n        if (_releaseAmount < minReleaseAmount) {\r\n            return;\r\n        }\r\n\r\n        if (xvsBalance >= _releaseAmount) {\r\n            actualAmount = _releaseAmount;\r\n        } else {\r\n            actualAmount = xvsBalance;\r\n        }\r\n\r\n        releaseStartBlock = getBlockNumber();\r\n\r\n        xvs.transfer(vaiVaultAddress, actualAmount);\r\n        emit DistributedVAIVaultVenus(actualAmount);\r\n\r\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\r\n    }\r\n}\r\n"
    },
    "contracts/ComptrollerG4.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\nimport \"./Unitroller.sol\";\r\nimport \"./Governance/XVS.sol\";\r\nimport \"./VAI/VAI.sol\";\r\n\r\n/**\r\n * @title Venus's Comptroller Contract\r\n * @author Venus\r\n */\r\ncontract ComptrollerG4 is ComptrollerV4Storage, ComptrollerInterfaceG2, ComptrollerErrorReporter, ExponentialNoError {\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketListed(VToken vToken);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\r\n\r\n    /// @notice Emitted when a collateral factor is changed by admin\r\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\r\n\r\n    /// @notice Emitted when price oracle is changed\r\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\r\n\r\n    /// @notice Emitted when VAI Vault info is changed\r\n    event NewVAIVaultInfo(address vault_, uint releaseStartBlock_, uint releaseInterval_);\r\n\r\n    /// @notice Emitted when pause guardian is changed\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    /// @notice Emitted when an action is paused globally\r\n    event ActionPaused(string action, bool pauseState);\r\n\r\n    /// @notice Emitted when an action is paused on a market\r\n    event ActionPaused(VToken vToken, string action, bool pauseState);\r\n\r\n    /// @notice Emitted when Venus VAI Vault rate is changed\r\n    event NewVenusVAIVaultRate(uint oldVenusVAIVaultRate, uint newVenusVAIVaultRate);\r\n\r\n    /// @notice Emitted when a new Venus speed is calculated for a market\r\n    event VenusSpeedUpdated(VToken indexed vToken, uint newSpeed);\r\n\r\n    /// @notice Emitted when XVS is distributed to a supplier\r\n    event DistributedSupplierVenus(VToken indexed vToken, address indexed supplier, uint venusDelta, uint venusSupplyIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a borrower\r\n    event DistributedBorrowerVenus(VToken indexed vToken, address indexed borrower, uint venusDelta, uint venusBorrowIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a VAI minter\r\n    event DistributedVAIMinterVenus(address indexed vaiMinter, uint venusDelta, uint venusVAIMintIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to VAI Vault\r\n    event DistributedVAIVaultVenus(uint amount);\r\n\r\n    /// @notice Emitted when VAIController is changed\r\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\r\n\r\n    /// @notice Emitted when VAI mint rate is changed by admin\r\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\r\n\r\n    /// @notice Emitted when protocol state is changed by admin\r\n    event ActionProtocolPaused(bool state);\r\n\r\n    /// @notice Emitted when borrow cap for a vToken is changed\r\n    event NewBorrowCap(VToken indexed vToken, uint newBorrowCap);\r\n\r\n    /// @notice Emitted when borrow cap guardian is changed\r\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\r\n\r\n    /// @notice Emitted when treasury guardian is changed\r\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\r\n\r\n    /// @notice Emitted when treasury address is changed\r\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\r\n\r\n    /// @notice Emitted when treasury percent is changed\r\n    event NewTreasuryPercent(uint oldTreasuryPercent, uint newTreasuryPercent);\r\n\r\n    /// @notice The initial Venus index for a market\r\n    uint224 public constant venusInitialIndex = 1e36;\r\n\r\n    // closeFactorMantissa must be strictly greater than this value\r\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n    // closeFactorMantissa must not exceed this value\r\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // No collateralFactorMantissa may exceed this value\r\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyProtocolAllowed {\r\n        require(!protocolPaused, \"protocol is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyListedMarket(VToken vToken) {\r\n        require(markets[address(vToken)].isListed, \"venus market is not listed\");\r\n        _;\r\n    }\r\n\r\n    modifier validPauseState(bool state) {\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n        _;\r\n    }\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\r\n        return accountAssets[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account is entered in the given asset\r\n     * @param account The address of the account to check\r\n     * @param vToken The vToken to check\r\n     * @return True if the account is in the asset, otherwise false.\r\n     */\r\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\r\n        return markets[address(vToken)].accountMembership[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add assets to be included in account liquidity calculation\r\n     * @param vTokens The list of addresses of the vToken markets to be enabled\r\n     * @return Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory) {\r\n        uint len = vTokens.length;\r\n\r\n        uint[] memory results = new uint[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            results[i] = uint(addToMarketInternal(VToken(vTokens[i]), msg.sender));\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n     * @param vToken The market to enter\r\n     * @param borrower The address of the account to modify\r\n     * @return Success indicator for whether the market was entered\r\n     */\r\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\r\n        Market storage marketToJoin = markets[address(vToken)];\r\n\r\n        if (!marketToJoin.isListed) {\r\n            // market is not listed, cannot join\r\n            return Error.MARKET_NOT_LISTED;\r\n        }\r\n\r\n        if (marketToJoin.accountMembership[borrower]) {\r\n            // already joined\r\n            return Error.NO_ERROR;\r\n        }\r\n\r\n        // survived the gauntlet, add to list\r\n        // NOTE: we store these somewhat redundantly as a significant optimization\r\n        //  this avoids having to iterate through the list for the most common use cases\r\n        //  that is, only when we need to perform liquidity checks\r\n        //  and not whenever we want to check if an account is in a particular market\r\n        marketToJoin.accountMembership[borrower] = true;\r\n        accountAssets[borrower].push(vToken);\r\n\r\n        emit MarketEntered(vToken, borrower);\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes asset from sender's account liquidity calculation\r\n     * @dev Sender must not have an outstanding borrow balance in the asset,\r\n     *  or be providing necessary collateral for an outstanding borrow.\r\n     * @param vTokenAddress The address of the asset to be removed\r\n     * @return Whether or not the account successfully exited the market\r\n     */\r\n    function exitMarket(address vTokenAddress) external returns (uint) {\r\n        VToken vToken = VToken(vTokenAddress);\r\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\r\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\r\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\r\n\r\n        /* Fail if the sender has a borrow balance */\r\n        if (amountOwed != 0) {\r\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\r\n        }\r\n\r\n        /* Fail if the sender is not permitted to redeem all of their tokens */\r\n        uint allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\r\n        }\r\n\r\n        Market storage marketToExit = markets[address(vToken)];\r\n\r\n        /* Return true if the sender is not already ‘in’ the market */\r\n        if (!marketToExit.accountMembership[msg.sender]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Set vToken account membership to false */\r\n        delete marketToExit.accountMembership[msg.sender];\r\n\r\n        /* Delete vToken from the account’s list of assets */\r\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\r\n        VToken[] storage userAssetList = accountAssets[msg.sender];\r\n        uint len = userAssetList.length;\r\n        uint i;\r\n        for (; i < len; i++) {\r\n            if (userAssetList[i] == vToken) {\r\n                userAssetList[i] = userAssetList[len - 1];\r\n                userAssetList.length--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // We *must* have found the asset in the list or our redundant data structure is broken\r\n        assert(i < len);\r\n\r\n        emit MarketExited(vToken, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to mint tokens in the given market\r\n     * @param vToken The market to verify the mint against\r\n     * @param minter The account which would get the minted tokens\r\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function mintAllowed(address vToken, address minter, uint mintAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintGuardianPaused[vToken], \"mint is paused\");\r\n\r\n        // Shh - currently unused\r\n        mintAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, minter);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates mint and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being minted\r\n     * @param minter The address minting the tokens\r\n     * @param actualMintAmount The amount of the underlying asset being minted\r\n     * @param mintTokens The number of tokens being minted\r\n     */\r\n    function mintVerify(address vToken, address minter, uint actualMintAmount, uint mintTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        minter;\r\n        actualMintAmount;\r\n        mintTokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n     * @param vToken The market to verify the redeem against\r\n     * @param redeemer The account which would redeem the tokens\r\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\r\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external onlyProtocolAllowed returns (uint) {\r\n        uint allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, redeemer);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function redeemAllowedInternal(address vToken, address redeemer, uint redeemTokens) internal view returns (uint) {\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n        if (!markets[vToken].accountMembership[redeemer]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, VToken(vToken), redeemTokens, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates redeem and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being redeemed\r\n     * @param redeemer The address redeeming the tokens\r\n     * @param redeemAmount The amount of the underlying asset being redeemed\r\n     * @param redeemTokens The number of tokens being redeemed\r\n     */\r\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        redeemer;\r\n\r\n        // Require tokens is zero or amount is also zero\r\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param vToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!borrowGuardianPaused[vToken], \"borrow is paused\");\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (!markets[vToken].accountMembership[borrower]) {\r\n            // only vTokens may call borrowAllowed if borrower not in market\r\n            require(msg.sender == vToken, \"sender must be vToken\");\r\n\r\n            // attempt to add borrower to the market\r\n            Error err = addToMarketInternal(VToken(vToken), borrower);\r\n            if (err != Error.NO_ERROR) {\r\n                return uint(err);\r\n            }\r\n        }\r\n\r\n        if (oracle.getUnderlyingPrice(VToken(vToken)) == 0) {\r\n            return uint(Error.PRICE_ERROR);\r\n        }\r\n\r\n        uint borrowCap = borrowCaps[vToken];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint totalBorrows = VToken(vToken).totalBorrows();\r\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(vToken), 0, borrowAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates borrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset whose underlying is being borrowed\r\n     * @param borrower The address borrowing the underlying\r\n     * @param borrowAmount The amount of the underlying asset requested to borrow\r\n     */\r\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        borrower;\r\n        borrowAmount;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n     * @param vToken The market to verify the repay against\r\n     * @param payer The account which would repay the asset\r\n     * @param borrower The account which would repay the asset\r\n     * @param repayAmount The amount of the underlying asset the account would repay\r\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function repayBorrowAllowed(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        payer;\r\n        borrower;\r\n        repayAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being repaid\r\n     * @param payer The address repaying the borrow\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function repayBorrowVerify(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint borrowerIndex) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        payer;\r\n        borrower;\r\n        actualRepayAmount;\r\n        borrowerIndex;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the liquidation should be allowed to occur\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param repayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowAllowed(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        liquidator;\r\n\r\n        if (!(markets[vTokenBorrowed].isListed || address(vTokenBorrowed) == address(vaiController)) || !markets[vTokenCollateral].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* The borrower must have shortfall in order to be liquidatable */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(0), 0, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall == 0) {\r\n            return uint(Error.INSUFFICIENT_SHORTFALL);\r\n        }\r\n\r\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n        uint borrowBalance;\r\n        if (address(vTokenBorrowed) != address(vaiController)) {\r\n            borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\r\n        } else {\r\n            borrowBalance = mintedVAIs[borrower];\r\n        }\r\n\r\n        uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\r\n        if (repayAmount > maxClose) {\r\n            return uint(Error.TOO_MUCH_REPAY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowVerify(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenBorrowed;\r\n        vTokenCollateral;\r\n        liquidator;\r\n        borrower;\r\n        actualRepayAmount;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the seizing of assets should be allowed to occur\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeAllowed(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!seizeGuardianPaused, \"seize is paused\");\r\n\r\n        // Shh - currently unused\r\n        seizeTokens;\r\n\r\n        // We've added VAIController as a borrowed token list check for seize\r\n        if (!markets[vTokenCollateral].isListed || !(markets[vTokenBorrowed].isListed || address(vTokenBorrowed) == address(vaiController))) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\r\n            return uint(Error.COMPTROLLER_MISMATCH);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vTokenCollateral);\r\n        distributeSupplierVenus(vTokenCollateral, borrower);\r\n        distributeSupplierVenus(vTokenCollateral, liquidator);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates seize and reverts on rejection. May emit logs.\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeVerify(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenCollateral;\r\n        vTokenBorrowed;\r\n        liquidator;\r\n        borrower;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n     * @param vToken The market to verify the transfer against\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!transferGuardianPaused, \"transfer is paused\");\r\n\r\n        // Currently the only consideration is whether or not\r\n        //  the src is allowed to redeem this many tokens\r\n        uint allowed = redeemAllowedInternal(vToken, src, transferTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, src);\r\n        distributeSupplierVenus(vToken, dst);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates transfer and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being transferred\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     */\r\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        src;\r\n        dst;\r\n        transferTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountLiquidityLocalVars {\r\n        uint sumCollateral;\r\n        uint sumBorrowPlusEffects;\r\n        uint vTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code (semi-opaque),\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(0), 0, 0);\r\n\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidity(\r\n        address account,\r\n        address vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(vTokenModify), redeemTokens, borrowAmount);\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\r\n     *  without calculating accumulated interest.\r\n     * @return (possible error code,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidityInternal(\r\n        address account,\r\n        VToken vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) internal view returns (Error, uint, uint) {\r\n\r\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n\r\n        // For each asset the account is in\r\n        VToken[] memory assets = accountAssets[account];\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            VToken asset = assets[i];\r\n\r\n            // Read the balances and exchange rate from the vToken\r\n            (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\r\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                return (Error.SNAPSHOT_ERROR, 0, 0);\r\n            }\r\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                return (Error.PRICE_ERROR, 0, 0);\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\r\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\r\n\r\n            // sumCollateral += tokensToDenom * vTokenBalance\r\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.vTokenBalance, vars.sumCollateral);\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n\r\n            // Calculate effects of interacting with vTokenModify\r\n            if (asset == vTokenModify) {\r\n                // redeem effect\r\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\r\n\r\n                // borrow effect\r\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\r\n            }\r\n        }\r\n\r\n        vars.sumBorrowPlusEffects = add_(vars.sumBorrowPlusEffects, mintedVAIs[account]);\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\r\n     * @param vTokenBorrowed The address of the borrowed vToken\r\n     * @param vTokenCollateral The address of the collateral vToken\r\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\r\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateCalculateSeizeTokens(address vTokenBorrowed, address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(VToken(vTokenBorrowed));\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(VToken(vTokenCollateral));\r\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n\r\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\r\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\r\n        ratio = div_(numerator, denominator);\r\n\r\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\r\n     * @param vTokenCollateral The address of the collateral vToken\r\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\r\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateVAICalculateSeizeTokens(address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = 1e18;  // Note: this is VAI\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(VToken(vTokenCollateral));\r\n        if (priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n\r\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\r\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\r\n        ratio = div_(numerator, denominator);\r\n\r\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new price oracle for the comptroller\r\n      * @dev Admin function to set a new price oracle\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\r\n        }\r\n\r\n        // Track the old oracle for the comptroller\r\n        PriceOracle oldOracle = oracle;\r\n\r\n        // Set comptroller's oracle to newOracle\r\n        oracle = newOracle;\r\n\r\n        // Emit NewPriceOracle(oldOracle, newOracle)\r\n        emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the closeFactor used when liquidating borrows\r\n      * @dev Admin function to set closeFactor\r\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure\r\n      */\r\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n    \trequire(msg.sender == admin, \"only admin can set close factor\");\r\n\r\n        uint oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = newCloseFactorMantissa;\r\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the collateralFactor for a market\r\n      * @dev Admin function to set per-market collateralFactor\r\n      * @param vToken The market to set the factor on\r\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        // Verify market is listed\r\n        Market storage market = markets[address(vToken)];\r\n        if (!market.isListed) {\r\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\r\n        }\r\n\r\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\r\n\r\n        // Check collateral factor <= 0.9\r\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\r\n        }\r\n\r\n        // If collateral factor != 0, fail if price == 0\r\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\r\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\r\n        }\r\n\r\n        // Set market's collateral factor to new collateral factor, remember old value\r\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n        // Emit event with asset, old collateral factor, and new collateral factor\r\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets liquidationIncentive\r\n      * @dev Admin function to set liquidationIncentive\r\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for use in log\r\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n        // Set liquidation incentive to new incentive\r\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n        // Emit event with old incentive, new incentive\r\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Add the market to the markets mapping and set it as listed\r\n      * @dev Admin function to set isListed and add support for the market\r\n      * @param vToken The address of the market (token) to list\r\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n      */\r\n    function _supportMarket(VToken vToken) external returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n        }\r\n\r\n        if (markets[address(vToken)].isListed) {\r\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n        }\r\n\r\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\r\n\r\n        // Note that isVenus is not in active use anymore\r\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\r\n\r\n        _addMarketInternal(vToken);\r\n\r\n        emit MarketListed(vToken);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _addMarketInternal(VToken vToken) internal {\r\n        for (uint i = 0; i < allMarkets.length; i ++) {\r\n            require(allMarkets[i] != vToken, \"market already added\");\r\n        }\r\n        allMarkets.push(vToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Pause Guardian\r\n     * @param newPauseGuardian The address of the new Pause Guardian\r\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n     */\r\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for inclusion in log\r\n        address oldPauseGuardian = pauseGuardian;\r\n\r\n        // Store pauseGuardian with value newPauseGuardian\r\n        pauseGuardian = newPauseGuardian;\r\n\r\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\r\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Set the given borrow caps for the given vToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\r\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\r\n      * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\r\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\r\n      */\r\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint[] calldata newBorrowCaps) external {\r\n        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\r\n\r\n        uint numMarkets = vTokens.length;\r\n        uint numBorrowCaps = newBorrowCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\r\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Borrow Cap Guardian\r\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\r\n     */\r\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external onlyAdmin {\r\n        // Save current value for inclusion in log\r\n        address oldBorrowCapGuardian = borrowCapGuardian;\r\n\r\n        // Store borrowCapGuardian with value newBorrowCapGuardian\r\n        borrowCapGuardian = newBorrowCapGuardian;\r\n\r\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\r\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\r\n    }\r\n\r\n    /**\r\n     * @notice Set whole protocol pause/unpause state\r\n     */\r\n    function _setProtocolPaused(bool state) public validPauseState(state) returns(bool) {\r\n        protocolPaused = state;\r\n        emit ActionProtocolPaused(state);\r\n        return state;\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new VAI controller\r\n      * @dev Admin function to set a new VAI controller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAICONTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        VAIControllerInterface oldRate = vaiController;\r\n        vaiController = vaiController_;\r\n        emit NewVAIController(oldRate, vaiController_);\r\n    }\r\n\r\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAI_MINT_RATE_CHECK);\r\n        }\r\n\r\n        uint oldVAIMintRate = vaiMintRate;\r\n        vaiMintRate = newVAIMintRate;\r\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setTreasuryData(address newTreasuryGuardian, address newTreasuryAddress, uint newTreasuryPercent) external returns (uint) {\r\n        // Check caller is admin\r\n        if (!(msg.sender == admin || msg.sender == treasuryGuardian)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_TREASURY_OWNER_CHECK);\r\n        }\r\n\r\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\r\n\r\n        address oldTreasuryGuardian = treasuryGuardian;\r\n        address oldTreasuryAddress = treasuryAddress;\r\n        uint oldTreasuryPercent = treasuryPercent;\r\n\r\n        treasuryGuardian = newTreasuryGuardian;\r\n        treasuryAddress = newTreasuryAddress;\r\n        treasuryPercent = newTreasuryPercent;\r\n\r\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\r\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\r\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _become(Unitroller unitroller) public {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\r\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\r\n     */\r\n    function adminOrInitializing() internal view returns (bool) {\r\n        return msg.sender == admin || msg.sender == comptrollerImplementation;\r\n    }\r\n\r\n    /*** Venus Distribution ***/\r\n\r\n    function setVenusSpeedInternal(VToken vToken, uint venusSpeed) internal {\r\n        uint currentVenusSpeed = venusSpeeds[address(vToken)];\r\n        if (currentVenusSpeed != 0) {\r\n            // note that XVS speed could be set to 0 to halt liquidity rewards for a market\r\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n            updateVenusSupplyIndex(address(vToken));\r\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n        } else if (venusSpeed != 0) {\r\n            // Add the XVS market\r\n            Market storage market = markets[address(vToken)];\r\n            require(market.isListed == true, \"venus market is not listed\");\r\n\r\n            if (venusSupplyState[address(vToken)].index == 0 && venusSupplyState[address(vToken)].block == 0) {\r\n                venusSupplyState[address(vToken)] = VenusMarketState({\r\n                    index: venusInitialIndex,\r\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n            }\r\n\r\n\r\n        if (venusBorrowState[address(vToken)].index == 0 && venusBorrowState[address(vToken)].block == 0) {\r\n                venusBorrowState[address(vToken)] = VenusMarketState({\r\n                    index: venusInitialIndex,\r\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n            }\r\n        }\r\n\r\n        if (currentVenusSpeed != venusSpeed) {\r\n            venusSpeeds[address(vToken)] = venusSpeed;\r\n            emit VenusSpeedUpdated(vToken, venusSpeed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the supply index\r\n     * @param vToken The market whose supply index to update\r\n     */\r\n    function updateVenusSupplyIndex(address vToken) internal {\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        uint supplySpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\r\n        if (deltaBlocks > 0 && supplySpeed > 0) {\r\n            uint supplyTokens = VToken(vToken).totalSupply();\r\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\r\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\r\n            venusSupplyState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the borrow index\r\n     * @param vToken The market whose borrow index to update\r\n     */\r\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        uint borrowSpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\r\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\r\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\r\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\r\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\r\n            venusBorrowState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\r\n     * @param vToken The market in which the supplier is interacting\r\n     * @param supplier The address of the supplier to distribute XVS to\r\n     */\r\n    function distributeSupplierVenus(address vToken, address supplier) internal {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\r\n        Double memory supplierIndex = Double({mantissa: venusSupplierIndex[vToken][supplier]});\r\n        venusSupplierIndex[vToken][supplier] = supplyIndex.mantissa;\r\n\r\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\r\n            supplierIndex.mantissa = venusInitialIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\r\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\r\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\r\n        uint supplierAccrued = add_(venusAccrued[supplier], supplierDelta);\r\n        venusAccrued[supplier] = supplierAccrued;\r\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\r\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vToken The market in which the borrower is interacting\r\n     * @param borrower The address of the borrower to distribute XVS to\r\n     */\r\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\r\n        Double memory borrowerIndex = Double({mantissa: venusBorrowerIndex[vToken][borrower]});\r\n        venusBorrowerIndex[vToken][borrower] = borrowIndex.mantissa;\r\n\r\n        if (borrowerIndex.mantissa > 0) {\r\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\r\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\r\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\r\n            uint borrowerAccrued = add_(venusAccrued[borrower], borrowerDelta);\r\n            venusAccrued[borrower] = borrowerAccrued;\r\n            emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a VAI minter and possibly transfer it to them\r\n     * @dev VAI minters will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vaiMinter The address of the VAI minter to distribute XVS to\r\n     */\r\n    function distributeVAIMinterVenus(address vaiMinter) public {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        if (address(vaiController) != address(0)) {\r\n            uint vaiMinterAccrued;\r\n            uint vaiMinterDelta;\r\n            uint vaiMintIndexMantissa;\r\n            uint err;\r\n            (err, vaiMinterAccrued, vaiMinterDelta, vaiMintIndexMantissa) = vaiController.calcDistributeVAIMinterVenus(vaiMinter);\r\n            if (err == uint(Error.NO_ERROR)) {\r\n                venusAccrued[vaiMinter] = vaiMinterAccrued;\r\n                emit DistributedVAIMinterVenus(vaiMinter, vaiMinterDelta, vaiMintIndexMantissa);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\r\n     * @param holder The address to claim XVS for\r\n     */\r\n    function claimVenus(address holder) public {\r\n        return claimVenus(holder, allMarkets);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in the specified markets\r\n     * @param holder The address to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     */\r\n    function claimVenus(address holder, VToken[] memory vTokens) public {\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = holder;\r\n        claimVenus(holders, vTokens, true, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all xvs accrued by the holders\r\n     * @param holders The addresses to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     * @param borrowers Whether or not to claim XVS earned by borrowing\r\n     * @param suppliers Whether or not to claim XVS earned by supplying\r\n     */\r\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\r\n        uint j;\r\n        if(address(vaiController) != address(0)) {\r\n            vaiController.updateVenusVAIMintIndex();\r\n        }\r\n        for (j = 0; j < holders.length; j++) {\r\n            distributeVAIMinterVenus(holders[j]);\r\n            venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\r\n        }\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            VToken vToken = vTokens[i];\r\n            require(markets[address(vToken)].isListed, \"not listed market\");\r\n            if (borrowers) {\r\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\r\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\r\n                }\r\n            }\r\n            if (suppliers) {\r\n                updateVenusSupplyIndex(address(vToken));\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeSupplierVenus(address(vToken), holders[j]);\r\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to the user\r\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer XVS to\r\n     * @param amount The amount of XVS to (possibly) transfer\r\n     * @return The amount of XVS which was NOT transferred to the user\r\n     */\r\n    function grantXVSInternal(address user, uint amount) internal returns (uint) {\r\n        XVS xvs = XVS(getXVSAddress());\r\n        uint venusRemaining = xvs.balanceOf(address(this));\r\n        if (amount > 0 && amount <= venusRemaining) {\r\n            xvs.transfer(user, amount);\r\n            return 0;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /*** Venus Distribution Admin ***/\r\n\r\n    /**\r\n     * @notice Set the amount of XVS distributed per block to VAI Vault\r\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\r\n     */\r\n    function _setVenusVAIVaultRate(uint venusVAIVaultRate_) public onlyAdmin {\r\n        uint oldVenusVAIVaultRate = venusVAIVaultRate;\r\n        venusVAIVaultRate = venusVAIVaultRate_;\r\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the VAI Vault infos\r\n     * @param vault_ The address of the VAI Vault\r\n     * @param releaseStartBlock_ The start block of release to VAI Vault\r\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\r\n     */\r\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) public onlyAdmin {\r\n        vaiVaultAddress = vault_;\r\n        releaseStartBlock = releaseStartBlock_;\r\n        minReleaseAmount = minReleaseAmount_;\r\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\r\n    }\r\n\r\n    /**\r\n     * @notice Set XVS speed for a single market\r\n     * @param vToken The market whose XVS speed to update\r\n     * @param venusSpeed New XVS speed for market\r\n     */\r\n    function _setVenusSpeed(VToken vToken, uint venusSpeed) public {\r\n        require(adminOrInitializing(), \"only admin can set venus speed\");\r\n        setVenusSpeedInternal(vToken, venusSpeed);\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() public view returns (VToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the XVS token\r\n     * @return The address of XVS\r\n     */\r\n    function getXVSAddress() public view returns (address) {\r\n        return 0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63;\r\n    }\r\n\r\n    /*** VAI functions ***/\r\n\r\n    /**\r\n     * @notice Set the minted VAI amount of the `owner`\r\n     * @param owner The address of the account to set\r\n     * @param amount The amount of VAI to set to the account\r\n     * @return The number of minted VAI by `owner`\r\n     */\r\n    function setMintedVAIOf(address owner, uint amount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\r\n        // Check caller is vaiController\r\n        if (msg.sender != address(vaiController)) {\r\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\r\n        }\r\n        mintedVAIs[owner] = amount;\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to VAI Vault\r\n     */\r\n    function releaseToVault() public {\r\n        if(releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\r\n            return;\r\n        }\r\n\r\n        XVS xvs = XVS(getXVSAddress());\r\n\r\n        uint256 xvsBalance = xvs.balanceOf(address(this));\r\n        if(xvsBalance == 0) {\r\n            return;\r\n        }\r\n\r\n\r\n        uint256 actualAmount;\r\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\r\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\r\n        uint256 _releaseAmount = mul_(venusVAIVaultRate, deltaBlocks);\r\n\r\n        if (_releaseAmount < minReleaseAmount) {\r\n            return;\r\n        }\r\n\r\n        if (xvsBalance >= _releaseAmount) {\r\n            actualAmount = _releaseAmount;\r\n        } else {\r\n            actualAmount = xvsBalance;\r\n        }\r\n\r\n        releaseStartBlock = getBlockNumber();\r\n\r\n        xvs.transfer(vaiVaultAddress, actualAmount);\r\n        emit DistributedVAIVaultVenus(actualAmount);\r\n\r\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\r\n    }\r\n}\r\n"
    },
    "contracts/ComptrollerG5.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\nimport \"./Unitroller.sol\";\r\nimport \"./Governance/XVS.sol\";\r\nimport \"./VAI/VAI.sol\";\r\n\r\n/**\r\n * @title Venus's Comptroller Contract\r\n * @author Venus\r\n */\r\ncontract ComptrollerG5 is ComptrollerV5Storage, ComptrollerInterfaceG2, ComptrollerErrorReporter, ExponentialNoError {\r\n    /// @notice Emitted when an admin supports a market\r\n    event MarketListed(VToken vToken);\r\n\r\n    /// @notice Emitted when an account enters a market\r\n    event MarketEntered(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when an account exits a market\r\n    event MarketExited(VToken vToken, address account);\r\n\r\n    /// @notice Emitted when close factor is changed by admin\r\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\r\n\r\n    /// @notice Emitted when a collateral factor is changed by admin\r\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\r\n\r\n    /// @notice Emitted when liquidation incentive is changed by admin\r\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\r\n\r\n    /// @notice Emitted when price oracle is changed\r\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\r\n\r\n    /// @notice Emitted when VAI Vault info is changed\r\n    event NewVAIVaultInfo(address vault_, uint releaseStartBlock_, uint releaseInterval_);\r\n\r\n    /// @notice Emitted when pause guardian is changed\r\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n    /// @notice Emitted when an action is paused globally\r\n    event ActionPaused(string action, bool pauseState);\r\n\r\n    /// @notice Emitted when an action is paused on a market\r\n    event ActionPaused(VToken vToken, string action, bool pauseState);\r\n\r\n    /// @notice Emitted when Venus VAI Vault rate is changed\r\n    event NewVenusVAIVaultRate(uint oldVenusVAIVaultRate, uint newVenusVAIVaultRate);\r\n\r\n    /// @notice Emitted when a new Venus speed is calculated for a market\r\n    event VenusSpeedUpdated(VToken indexed vToken, uint newSpeed);\r\n\r\n    /// @notice Emitted when XVS is distributed to a supplier\r\n    event DistributedSupplierVenus(VToken indexed vToken, address indexed supplier, uint venusDelta, uint venusSupplyIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a borrower\r\n    event DistributedBorrowerVenus(VToken indexed vToken, address indexed borrower, uint venusDelta, uint venusBorrowIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to a VAI minter\r\n    event DistributedVAIMinterVenus(address indexed vaiMinter, uint venusDelta, uint venusVAIMintIndex);\r\n\r\n    /// @notice Emitted when XVS is distributed to VAI Vault\r\n    event DistributedVAIVaultVenus(uint amount);\r\n\r\n    /// @notice Emitted when VAIController is changed\r\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\r\n\r\n    /// @notice Emitted when VAI mint rate is changed by admin\r\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\r\n\r\n    /// @notice Emitted when protocol state is changed by admin\r\n    event ActionProtocolPaused(bool state);\r\n\r\n    /// @notice Emitted when borrow cap for a vToken is changed\r\n    event NewBorrowCap(VToken indexed vToken, uint newBorrowCap);\r\n\r\n    /// @notice Emitted when borrow cap guardian is changed\r\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\r\n\r\n    /// @notice Emitted when treasury guardian is changed\r\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\r\n\r\n    /// @notice Emitted when treasury address is changed\r\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\r\n\r\n    /// @notice Emitted when treasury percent is changed\r\n    event NewTreasuryPercent(uint oldTreasuryPercent, uint newTreasuryPercent);\r\n\r\n    /// @notice Emitted when Venus is granted by admin\r\n    event VenusGranted(address recipient, uint amount);\r\n\r\n    /// @notice The initial Venus index for a market\r\n    uint224 public constant venusInitialIndex = 1e36;\r\n\r\n    // closeFactorMantissa must be strictly greater than this value\r\n    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n    // closeFactorMantissa must not exceed this value\r\n    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    // No collateralFactorMantissa may exceed this value\r\n    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyProtocolAllowed {\r\n        require(!protocolPaused, \"protocol is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyListedMarket(VToken vToken) {\r\n        require(markets[address(vToken)].isListed, \"venus market is not listed\");\r\n        _;\r\n    }\r\n\r\n    modifier validPauseState(bool state) {\r\n        require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can\");\r\n        require(msg.sender == admin || state == true, \"only admin can unpause\");\r\n        _;\r\n    }\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\r\n        return accountAssets[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given account is entered in the given asset\r\n     * @param account The address of the account to check\r\n     * @param vToken The vToken to check\r\n     * @return True if the account is in the asset, otherwise false.\r\n     */\r\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\r\n        return markets[address(vToken)].accountMembership[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Add assets to be included in account liquidity calculation\r\n     * @param vTokens The list of addresses of the vToken markets to be enabled\r\n     * @return Success indicator for whether each corresponding market was entered\r\n     */\r\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory) {\r\n        uint len = vTokens.length;\r\n\r\n        uint[] memory results = new uint[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            results[i] = uint(addToMarketInternal(VToken(vTokens[i]), msg.sender));\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n     * @param vToken The market to enter\r\n     * @param borrower The address of the account to modify\r\n     * @return Success indicator for whether the market was entered\r\n     */\r\n    function addToMarketInternal(VToken vToken, address borrower) internal returns (Error) {\r\n        Market storage marketToJoin = markets[address(vToken)];\r\n\r\n        if (!marketToJoin.isListed) {\r\n            // market is not listed, cannot join\r\n            return Error.MARKET_NOT_LISTED;\r\n        }\r\n\r\n        if (marketToJoin.accountMembership[borrower]) {\r\n            // already joined\r\n            return Error.NO_ERROR;\r\n        }\r\n\r\n        // survived the gauntlet, add to list\r\n        // NOTE: we store these somewhat redundantly as a significant optimization\r\n        //  this avoids having to iterate through the list for the most common use cases\r\n        //  that is, only when we need to perform liquidity checks\r\n        //  and not whenever we want to check if an account is in a particular market\r\n        marketToJoin.accountMembership[borrower] = true;\r\n        accountAssets[borrower].push(vToken);\r\n\r\n        emit MarketEntered(vToken, borrower);\r\n\r\n        return Error.NO_ERROR;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes asset from sender's account liquidity calculation\r\n     * @dev Sender must not have an outstanding borrow balance in the asset,\r\n     *  or be providing necessary collateral for an outstanding borrow.\r\n     * @param vTokenAddress The address of the asset to be removed\r\n     * @return Whether or not the account successfully exited the market\r\n     */\r\n    function exitMarket(address vTokenAddress) external returns (uint) {\r\n        VToken vToken = VToken(vTokenAddress);\r\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\r\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\r\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\r\n\r\n        /* Fail if the sender has a borrow balance */\r\n        if (amountOwed != 0) {\r\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\r\n        }\r\n\r\n        /* Fail if the sender is not permitted to redeem all of their tokens */\r\n        uint allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\r\n        }\r\n\r\n        Market storage marketToExit = markets[address(vToken)];\r\n\r\n        /* Return true if the sender is not already ‘in’ the market */\r\n        if (!marketToExit.accountMembership[msg.sender]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Set vToken account membership to false */\r\n        delete marketToExit.accountMembership[msg.sender];\r\n\r\n        /* Delete vToken from the account’s list of assets */\r\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\r\n        VToken[] storage userAssetList = accountAssets[msg.sender];\r\n        uint len = userAssetList.length;\r\n        uint i;\r\n        for (; i < len; i++) {\r\n            if (userAssetList[i] == vToken) {\r\n                userAssetList[i] = userAssetList[len - 1];\r\n                userAssetList.length--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // We *must* have found the asset in the list or our redundant data structure is broken\r\n        assert(i < len);\r\n\r\n        emit MarketExited(vToken, msg.sender);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to mint tokens in the given market\r\n     * @param vToken The market to verify the mint against\r\n     * @param minter The account which would get the minted tokens\r\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function mintAllowed(address vToken, address minter, uint mintAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintGuardianPaused[vToken], \"mint is paused\");\r\n\r\n        // Shh - currently unused\r\n        mintAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, minter);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates mint and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being minted\r\n     * @param minter The address minting the tokens\r\n     * @param actualMintAmount The amount of the underlying asset being minted\r\n     * @param mintTokens The number of tokens being minted\r\n     */\r\n    function mintVerify(address vToken, address minter, uint actualMintAmount, uint mintTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        minter;\r\n        actualMintAmount;\r\n        mintTokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n     * @param vToken The market to verify the redeem against\r\n     * @param redeemer The account which would redeem the tokens\r\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\r\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external onlyProtocolAllowed returns (uint) {\r\n        uint allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, redeemer);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function redeemAllowedInternal(address vToken, address redeemer, uint redeemTokens) internal view returns (uint) {\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n        if (!markets[vToken].accountMembership[redeemer]) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, VToken(vToken), redeemTokens, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates redeem and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being redeemed\r\n     * @param redeemer The address redeeming the tokens\r\n     * @param redeemAmount The amount of the underlying asset being redeemed\r\n     * @param redeemTokens The number of tokens being redeemed\r\n     */\r\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        redeemer;\r\n\r\n        // Require tokens is zero or amount is also zero\r\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n     * @param vToken The market to verify the borrow against\r\n     * @param borrower The account which would borrow the asset\r\n     * @param borrowAmount The amount of underlying the account would borrow\r\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!borrowGuardianPaused[vToken], \"borrow is paused\");\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (!markets[vToken].accountMembership[borrower]) {\r\n            // only vTokens may call borrowAllowed if borrower not in market\r\n            require(msg.sender == vToken, \"sender must be vToken\");\r\n\r\n            // attempt to add borrower to the market\r\n            Error err = addToMarketInternal(VToken(vToken), borrower);\r\n            if (err != Error.NO_ERROR) {\r\n                return uint(err);\r\n            }\r\n        }\r\n\r\n        if (oracle.getUnderlyingPrice(VToken(vToken)) == 0) {\r\n            return uint(Error.PRICE_ERROR);\r\n        }\r\n\r\n        uint borrowCap = borrowCaps[vToken];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint totalBorrows = VToken(vToken).totalBorrows();\r\n            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(vToken), 0, borrowAmount);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall != 0) {\r\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates borrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset whose underlying is being borrowed\r\n     * @param borrower The address borrowing the underlying\r\n     * @param borrowAmount The amount of the underlying asset requested to borrow\r\n     */\r\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        borrower;\r\n        borrowAmount;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n     * @param vToken The market to verify the repay against\r\n     * @param payer The account which would repay the asset\r\n     * @param borrower The account which would repay the asset\r\n     * @param repayAmount The amount of the underlying asset the account would repay\r\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function repayBorrowAllowed(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        payer;\r\n        borrower;\r\n        repayAmount;\r\n\r\n        if (!markets[vToken].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        Exp memory borrowIndex = Exp({mantissa: VToken(vToken).borrowIndex()});\r\n        updateVenusBorrowIndex(vToken, borrowIndex);\r\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being repaid\r\n     * @param payer The address repaying the borrow\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function repayBorrowVerify(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint borrowerIndex) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        payer;\r\n        borrower;\r\n        actualRepayAmount;\r\n        borrowerIndex;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the liquidation should be allowed to occur\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param repayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowAllowed(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external onlyProtocolAllowed returns (uint) {\r\n        // Shh - currently unused\r\n        liquidator;\r\n\r\n        if (!(markets[vTokenBorrowed].isListed || address(vTokenBorrowed) == address(vaiController)) || !markets[vTokenCollateral].isListed) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        /* The borrower must have shortfall in order to be liquidatable */\r\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(0), 0, 0);\r\n        if (err != Error.NO_ERROR) {\r\n            return uint(err);\r\n        }\r\n        if (shortfall == 0) {\r\n            return uint(Error.INSUFFICIENT_SHORTFALL);\r\n        }\r\n\r\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n        uint borrowBalance;\r\n        if (address(vTokenBorrowed) != address(vaiController)) {\r\n            borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\r\n        } else {\r\n            borrowBalance = mintedVAIs[borrower];\r\n        }\r\n\r\n        uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\r\n        if (repayAmount > maxClose) {\r\n            return uint(Error.TOO_MUCH_REPAY);\r\n        }\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param actualRepayAmount The amount of underlying being repaid\r\n     */\r\n    function liquidateBorrowVerify(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint actualRepayAmount,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenBorrowed;\r\n        vTokenCollateral;\r\n        liquidator;\r\n        borrower;\r\n        actualRepayAmount;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the seizing of assets should be allowed to occur\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeAllowed(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!seizeGuardianPaused, \"seize is paused\");\r\n\r\n        // Shh - currently unused\r\n        seizeTokens;\r\n\r\n        // We've added VAIController as a borrowed token list check for seize\r\n        if (!markets[vTokenCollateral].isListed || !(markets[vTokenBorrowed].isListed || address(vTokenBorrowed) == address(vaiController))) {\r\n            return uint(Error.MARKET_NOT_LISTED);\r\n        }\r\n\r\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\r\n            return uint(Error.COMPTROLLER_MISMATCH);\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vTokenCollateral);\r\n        distributeSupplierVenus(vTokenCollateral, borrower);\r\n        distributeSupplierVenus(vTokenCollateral, liquidator);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates seize and reverts on rejection. May emit logs.\r\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\r\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\r\n     * @param liquidator The address repaying the borrow and seizing the collateral\r\n     * @param borrower The address of the borrower\r\n     * @param seizeTokens The number of collateral tokens to seize\r\n     */\r\n    function seizeVerify(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external {\r\n        // Shh - currently unused\r\n        vTokenCollateral;\r\n        vTokenBorrowed;\r\n        liquidator;\r\n        borrower;\r\n        seizeTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n     * @param vToken The market to verify the transfer against\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n     */\r\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!transferGuardianPaused, \"transfer is paused\");\r\n\r\n        // Currently the only consideration is whether or not\r\n        //  the src is allowed to redeem this many tokens\r\n        uint allowed = redeemAllowedInternal(vToken, src, transferTokens);\r\n        if (allowed != uint(Error.NO_ERROR)) {\r\n            return allowed;\r\n        }\r\n\r\n        // Keep the flywheel moving\r\n        updateVenusSupplyIndex(vToken);\r\n        distributeSupplierVenus(vToken, src);\r\n        distributeSupplierVenus(vToken, dst);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Validates transfer and reverts on rejection. May emit logs.\r\n     * @param vToken Asset being transferred\r\n     * @param src The account which sources the tokens\r\n     * @param dst The account which receives the tokens\r\n     * @param transferTokens The number of vTokens to transfer\r\n     */\r\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external {\r\n        // Shh - currently unused\r\n        vToken;\r\n        src;\r\n        dst;\r\n        transferTokens;\r\n\r\n        // Shh - we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            maxAssets = maxAssets;\r\n        }\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountLiquidityLocalVars {\r\n        uint sumCollateral;\r\n        uint sumBorrowPlusEffects;\r\n        uint vTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the current account liquidity wrt collateral requirements\r\n     * @return (possible error code (semi-opaque),\r\n                account liquidity in excess of collateral requirements,\r\n     *          account shortfall below collateral requirements)\r\n     */\r\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(0), 0, 0);\r\n\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidity(\r\n        address account,\r\n        address vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) public view returns (uint, uint, uint) {\r\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, VToken(vTokenModify), redeemTokens, borrowAmount);\r\n        return (uint(err), liquidity, shortfall);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param vTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @dev Note that we calculate the exchangeRateStored for each collateral vToken using stored data,\r\n     *  without calculating accumulated interest.\r\n     * @return (possible error code,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n    function getHypotheticalAccountLiquidityInternal(\r\n        address account,\r\n        VToken vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) internal view returns (Error, uint, uint) {\r\n\r\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n\r\n        // For each asset the account is in\r\n        VToken[] memory assets = accountAssets[account];\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            VToken asset = assets[i];\r\n\r\n            // Read the balances and exchange rate from the vToken\r\n            (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\r\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                return (Error.SNAPSHOT_ERROR, 0, 0);\r\n            }\r\n            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                return (Error.PRICE_ERROR, 0, 0);\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\r\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\r\n\r\n            // sumCollateral += tokensToDenom * vTokenBalance\r\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.vTokenBalance, vars.sumCollateral);\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n\r\n            // Calculate effects of interacting with vTokenModify\r\n            if (asset == vTokenModify) {\r\n                // redeem effect\r\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\r\n\r\n                // borrow effect\r\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\r\n            }\r\n        }\r\n\r\n        vars.sumBorrowPlusEffects = add_(vars.sumBorrowPlusEffects, mintedVAIs[account]);\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\r\n     * @param vTokenBorrowed The address of the borrowed vToken\r\n     * @param vTokenCollateral The address of the collateral vToken\r\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\r\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateCalculateSeizeTokens(address vTokenBorrowed, address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(VToken(vTokenBorrowed));\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(VToken(vTokenCollateral));\r\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n\r\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\r\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\r\n        ratio = div_(numerator, denominator);\r\n\r\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\r\n     * @param vTokenCollateral The address of the collateral vToken\r\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\r\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\r\n     */\r\n    function liquidateVAICalculateSeizeTokens(address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = 1e18;  // Note: this is VAI\r\n        uint priceCollateralMantissa = oracle.getUnderlyingPrice(VToken(vTokenCollateral));\r\n        if (priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n\r\n        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\r\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\r\n        ratio = div_(numerator, denominator);\r\n\r\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new price oracle for the comptroller\r\n      * @dev Admin function to set a new price oracle\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\r\n        }\r\n\r\n        // Track the old oracle for the comptroller\r\n        PriceOracle oldOracle = oracle;\r\n\r\n        // Set comptroller's oracle to newOracle\r\n        oracle = newOracle;\r\n\r\n        // Emit NewPriceOracle(oldOracle, newOracle)\r\n        emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the closeFactor used when liquidating borrows\r\n      * @dev Admin function to set closeFactor\r\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure\r\n      */\r\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n    \trequire(msg.sender == admin, \"only admin can set close factor\");\r\n\r\n        uint oldCloseFactorMantissa = closeFactorMantissa;\r\n        closeFactorMantissa = newCloseFactorMantissa;\r\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets the collateralFactor for a market\r\n      * @dev Admin function to set per-market collateralFactor\r\n      * @param vToken The market to set the factor on\r\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\r\n        }\r\n\r\n        // Verify market is listed\r\n        Market storage market = markets[address(vToken)];\r\n        if (!market.isListed) {\r\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\r\n        }\r\n\r\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\r\n\r\n        // Check collateral factor <= 0.9\r\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\r\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\r\n        }\r\n\r\n        // If collateral factor != 0, fail if price == 0\r\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\r\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\r\n        }\r\n\r\n        // Set market's collateral factor to new collateral factor, remember old value\r\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n        // Emit event with asset, old collateral factor, and new collateral factor\r\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets liquidationIncentive\r\n      * @dev Admin function to set liquidationIncentive\r\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n      */\r\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for use in log\r\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n        // Set liquidation incentive to new incentive\r\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n        // Emit event with old incentive, new incentive\r\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Add the market to the markets mapping and set it as listed\r\n      * @dev Admin function to set isListed and add support for the market\r\n      * @param vToken The address of the market (token) to list\r\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n      */\r\n    function _supportMarket(VToken vToken) external returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n        }\r\n\r\n        if (markets[address(vToken)].isListed) {\r\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n        }\r\n\r\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\r\n\r\n        // Note that isVenus is not in active use anymore\r\n        markets[address(vToken)] = Market({isListed: true, isVenus: false, collateralFactorMantissa: 0});\r\n\r\n        _addMarketInternal(vToken);\r\n\r\n        emit MarketListed(vToken);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _addMarketInternal(VToken vToken) internal {\r\n        for (uint i = 0; i < allMarkets.length; i ++) {\r\n            require(allMarkets[i] != vToken, \"market already added\");\r\n        }\r\n        allMarkets.push(vToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Pause Guardian\r\n     * @param newPauseGuardian The address of the new Pause Guardian\r\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n     */\r\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value for inclusion in log\r\n        address oldPauseGuardian = pauseGuardian;\r\n\r\n        // Store pauseGuardian with value newPauseGuardian\r\n        pauseGuardian = newPauseGuardian;\r\n\r\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\r\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Set the given borrow caps for the given vToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\r\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\r\n      * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\r\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\r\n      */\r\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint[] calldata newBorrowCaps) external {\r\n        require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\r\n\r\n        uint numMarkets = vTokens.length;\r\n        uint numBorrowCaps = newBorrowCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\r\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to change the Borrow Cap Guardian\r\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\r\n     */\r\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external onlyAdmin {\r\n        // Save current value for inclusion in log\r\n        address oldBorrowCapGuardian = borrowCapGuardian;\r\n\r\n        // Store borrowCapGuardian with value newBorrowCapGuardian\r\n        borrowCapGuardian = newBorrowCapGuardian;\r\n\r\n        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\r\n        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\r\n    }\r\n\r\n    /**\r\n     * @notice Set whole protocol pause/unpause state\r\n     */\r\n    function _setProtocolPaused(bool state) public validPauseState(state) returns(bool) {\r\n        protocolPaused = state;\r\n        emit ActionProtocolPaused(state);\r\n        return state;\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new VAI controller\r\n      * @dev Admin function to set a new VAI controller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAICONTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        VAIControllerInterface oldRate = vaiController;\r\n        vaiController = vaiController_;\r\n        emit NewVAIController(oldRate, vaiController_);\r\n    }\r\n\r\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_VAI_MINT_RATE_CHECK);\r\n        }\r\n\r\n        uint oldVAIMintRate = vaiMintRate;\r\n        vaiMintRate = newVAIMintRate;\r\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setTreasuryData(address newTreasuryGuardian, address newTreasuryAddress, uint newTreasuryPercent) external returns (uint) {\r\n        // Check caller is admin\r\n        if (!(msg.sender == admin || msg.sender == treasuryGuardian)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_TREASURY_OWNER_CHECK);\r\n        }\r\n\r\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\r\n\r\n        address oldTreasuryGuardian = treasuryGuardian;\r\n        address oldTreasuryAddress = treasuryAddress;\r\n        uint oldTreasuryPercent = treasuryPercent;\r\n\r\n        treasuryGuardian = newTreasuryGuardian;\r\n        treasuryAddress = newTreasuryAddress;\r\n        treasuryPercent = newTreasuryPercent;\r\n\r\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\r\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\r\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _become(Unitroller unitroller) public {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\r\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checks caller is admin, or this contract is becoming the new implementation\r\n     */\r\n    function adminOrInitializing() internal view returns (bool) {\r\n        return msg.sender == admin || msg.sender == comptrollerImplementation;\r\n    }\r\n\r\n    /*** Venus Distribution ***/\r\n\r\n    function setVenusSpeedInternal(VToken vToken, uint venusSpeed) internal {\r\n        uint currentVenusSpeed = venusSpeeds[address(vToken)];\r\n        if (currentVenusSpeed != 0) {\r\n            // note that XVS speed could be set to 0 to halt liquidity rewards for a market\r\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n            updateVenusSupplyIndex(address(vToken));\r\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n        } else if (venusSpeed != 0) {\r\n            // Add the XVS market\r\n            Market storage market = markets[address(vToken)];\r\n            require(market.isListed == true, \"venus market is not listed\");\r\n\r\n            if (venusSupplyState[address(vToken)].index == 0 && venusSupplyState[address(vToken)].block == 0) {\r\n                venusSupplyState[address(vToken)] = VenusMarketState({\r\n                    index: venusInitialIndex,\r\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n            }\r\n\r\n\r\n        if (venusBorrowState[address(vToken)].index == 0 && venusBorrowState[address(vToken)].block == 0) {\r\n                venusBorrowState[address(vToken)] = VenusMarketState({\r\n                    index: venusInitialIndex,\r\n                    block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\r\n                });\r\n            }\r\n        }\r\n\r\n        if (currentVenusSpeed != venusSpeed) {\r\n            venusSpeeds[address(vToken)] = venusSpeed;\r\n            emit VenusSpeedUpdated(vToken, venusSpeed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the supply index\r\n     * @param vToken The market whose supply index to update\r\n     */\r\n    function updateVenusSupplyIndex(address vToken) internal {\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        uint supplySpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\r\n        if (deltaBlocks > 0 && supplySpeed > 0) {\r\n            uint supplyTokens = VToken(vToken).totalSupply();\r\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\r\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\r\n            venusSupplyState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue XVS to the market by updating the borrow index\r\n     * @param vToken The market whose borrow index to update\r\n     */\r\n    function updateVenusBorrowIndex(address vToken, Exp memory marketBorrowIndex) internal {\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        uint borrowSpeed = venusSpeeds[vToken];\r\n        uint blockNumber = getBlockNumber();\r\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\r\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\r\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\r\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\r\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\r\n            venusBorrowState[vToken] = VenusMarketState({\r\n                index: safe224(index.mantissa, \"new index overflows\"),\r\n                block: safe32(blockNumber, \"block number overflows\")\r\n            });\r\n        } else if (deltaBlocks > 0) {\r\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a supplier and possibly transfer it to them\r\n     * @param vToken The market in which the supplier is interacting\r\n     * @param supplier The address of the supplier to distribute XVS to\r\n     */\r\n    function distributeSupplierVenus(address vToken, address supplier) internal {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\r\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\r\n        Double memory supplierIndex = Double({mantissa: venusSupplierIndex[vToken][supplier]});\r\n        venusSupplierIndex[vToken][supplier] = supplyIndex.mantissa;\r\n\r\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\r\n            supplierIndex.mantissa = venusInitialIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\r\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\r\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\r\n        uint supplierAccrued = add_(venusAccrued[supplier], supplierDelta);\r\n        venusAccrued[supplier] = supplierAccrued;\r\n        emit DistributedSupplierVenus(VToken(vToken), supplier, supplierDelta, supplyIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a borrower and possibly transfer it to them\r\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vToken The market in which the borrower is interacting\r\n     * @param borrower The address of the borrower to distribute XVS to\r\n     */\r\n    function distributeBorrowerVenus(address vToken, address borrower, Exp memory marketBorrowIndex) internal {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\r\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\r\n        Double memory borrowerIndex = Double({mantissa: venusBorrowerIndex[vToken][borrower]});\r\n        venusBorrowerIndex[vToken][borrower] = borrowIndex.mantissa;\r\n\r\n        if (borrowerIndex.mantissa > 0) {\r\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\r\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\r\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\r\n            uint borrowerAccrued = add_(venusAccrued[borrower], borrowerDelta);\r\n            venusAccrued[borrower] = borrowerAccrued;\r\n            emit DistributedBorrowerVenus(VToken(vToken), borrower, borrowerDelta, borrowIndex.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate XVS accrued by a VAI minter and possibly transfer it to them\r\n     * @dev VAI minters will not begin to accrue until after the first interaction with the protocol.\r\n     * @param vaiMinter The address of the VAI minter to distribute XVS to\r\n     */\r\n    function distributeVAIMinterVenus(address vaiMinter) public {\r\n        if (address(vaiVaultAddress) != address(0)) {\r\n            releaseToVault();\r\n        }\r\n\r\n        if (address(vaiController) != address(0)) {\r\n            uint vaiMinterAccrued;\r\n            uint vaiMinterDelta;\r\n            uint vaiMintIndexMantissa;\r\n            uint err;\r\n            (err, vaiMinterAccrued, vaiMinterDelta, vaiMintIndexMantissa) = vaiController.calcDistributeVAIMinterVenus(vaiMinter);\r\n            if (err == uint(Error.NO_ERROR)) {\r\n                venusAccrued[vaiMinter] = vaiMinterAccrued;\r\n                emit DistributedVAIMinterVenus(vaiMinter, vaiMinterDelta, vaiMintIndexMantissa);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in all markets and VAI\r\n     * @param holder The address to claim XVS for\r\n     */\r\n    function claimVenus(address holder) public {\r\n        return claimVenus(holder, allMarkets);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all the xvs accrued by holder in the specified markets\r\n     * @param holder The address to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     */\r\n    function claimVenus(address holder, VToken[] memory vTokens) public {\r\n        address[] memory holders = new address[](1);\r\n        holders[0] = holder;\r\n        claimVenus(holders, vTokens, true, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all xvs accrued by the holders\r\n     * @param holders The addresses to claim XVS for\r\n     * @param vTokens The list of markets to claim XVS in\r\n     * @param borrowers Whether or not to claim XVS earned by borrowing\r\n     * @param suppliers Whether or not to claim XVS earned by supplying\r\n     */\r\n    function claimVenus(address[] memory holders, VToken[] memory vTokens, bool borrowers, bool suppliers) public {\r\n        uint j;\r\n        if(address(vaiController) != address(0)) {\r\n            vaiController.updateVenusVAIMintIndex();\r\n        }\r\n        for (j = 0; j < holders.length; j++) {\r\n            distributeVAIMinterVenus(holders[j]);\r\n            venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\r\n        }\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            VToken vToken = vTokens[i];\r\n            require(markets[address(vToken)].isListed, \"not listed market\");\r\n            if (borrowers) {\r\n                Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n                updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeBorrowerVenus(address(vToken), holders[j], borrowIndex);\r\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\r\n                }\r\n            }\r\n            if (suppliers) {\r\n                updateVenusSupplyIndex(address(vToken));\r\n                for (j = 0; j < holders.length; j++) {\r\n                    distributeSupplierVenus(address(vToken), holders[j]);\r\n                    venusAccrued[holders[j]] = grantXVSInternal(holders[j], venusAccrued[holders[j]]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to the user\r\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all.\r\n     * @param user The address of the user to transfer XVS to\r\n     * @param amount The amount of XVS to (possibly) transfer\r\n     * @return The amount of XVS which was NOT transferred to the user\r\n     */\r\n    function grantXVSInternal(address user, uint amount) internal returns (uint) {\r\n        XVS xvs = XVS(getXVSAddress());\r\n        uint venusRemaining = xvs.balanceOf(address(this));\r\n        if (amount > 0 && amount <= venusRemaining) {\r\n            xvs.transfer(user, amount);\r\n            return 0;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /*** Venus Distribution Admin ***/\r\n\r\n    /**\r\n     * @notice Transfer XVS to the recipient\r\n     * @dev Note: If there is not enough XVS, we do not perform the transfer all.\r\n     * @param recipient The address of the recipient to transfer XVS to\r\n     * @param amount The amount of XVS to (possibly) transfer\r\n     */\r\n    function _grantXVS(address recipient, uint amount) public {\r\n        require(adminOrInitializing(), \"only admin can grant xvs\");\r\n        uint amountLeft = grantXVSInternal(recipient, amount);\r\n        require(amountLeft == 0, \"insufficient xvs for grant\");\r\n        emit VenusGranted(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the amount of XVS distributed per block to VAI Vault\r\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\r\n     */\r\n    function _setVenusVAIVaultRate(uint venusVAIVaultRate_) public onlyAdmin {\r\n        uint oldVenusVAIVaultRate = venusVAIVaultRate;\r\n        venusVAIVaultRate = venusVAIVaultRate_;\r\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the VAI Vault infos\r\n     * @param vault_ The address of the VAI Vault\r\n     * @param releaseStartBlock_ The start block of release to VAI Vault\r\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\r\n     */\r\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) public onlyAdmin {\r\n        vaiVaultAddress = vault_;\r\n        releaseStartBlock = releaseStartBlock_;\r\n        minReleaseAmount = minReleaseAmount_;\r\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\r\n    }\r\n\r\n    /**\r\n     * @notice Set XVS speed for a single market\r\n     * @param vToken The market whose XVS speed to update\r\n     * @param venusSpeed New XVS speed for market\r\n     */\r\n    function _setVenusSpeed(VToken vToken, uint venusSpeed) public {\r\n        require(adminOrInitializing(), \"only admin can set venus speed\");\r\n        setVenusSpeedInternal(vToken, venusSpeed);\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() public view returns (VToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the XVS token\r\n     * @return The address of XVS\r\n     */\r\n    function getXVSAddress() public view returns (address) {\r\n        return 0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63;\r\n    }\r\n\r\n    /*** VAI functions ***/\r\n\r\n    /**\r\n     * @notice Set the minted VAI amount of the `owner`\r\n     * @param owner The address of the account to set\r\n     * @param amount The amount of VAI to set to the account\r\n     * @return The number of minted VAI by `owner`\r\n     */\r\n    function setMintedVAIOf(address owner, uint amount) external onlyProtocolAllowed returns (uint) {\r\n        // Pausing is a very serious situation - we revert to sound the alarms\r\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\r\n        // Check caller is vaiController\r\n        if (msg.sender != address(vaiController)) {\r\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\r\n        }\r\n        mintedVAIs[owner] = amount;\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer XVS to VAI Vault\r\n     */\r\n    function releaseToVault() public {\r\n        if(releaseStartBlock == 0 || getBlockNumber() < releaseStartBlock) {\r\n            return;\r\n        }\r\n\r\n        XVS xvs = XVS(getXVSAddress());\r\n\r\n        uint256 xvsBalance = xvs.balanceOf(address(this));\r\n        if(xvsBalance == 0) {\r\n            return;\r\n        }\r\n\r\n\r\n        uint256 actualAmount;\r\n        uint256 deltaBlocks = sub_(getBlockNumber(), releaseStartBlock);\r\n        // releaseAmount = venusVAIVaultRate * deltaBlocks\r\n        uint256 _releaseAmount = mul_(venusVAIVaultRate, deltaBlocks);\r\n\r\n        if (_releaseAmount < minReleaseAmount) {\r\n            return;\r\n        }\r\n\r\n        if (xvsBalance >= _releaseAmount) {\r\n            actualAmount = _releaseAmount;\r\n        } else {\r\n            actualAmount = xvsBalance;\r\n        }\r\n\r\n        releaseStartBlock = getBlockNumber();\r\n\r\n        xvs.transfer(vaiVaultAddress, actualAmount);\r\n        emit DistributedVAIVaultVenus(actualAmount);\r\n\r\n        IVAIVault(vaiVaultAddress).updatePendingRewards();\r\n    }\r\n}\r\n"
    },
    "contracts/ComptrollerInterface.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\nimport \"./PriceOracle.sol\";\r\n\r\ncontract ComptrollerInterfaceG1 {\r\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\r\n    bool public constant isComptroller = true;\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory);\r\n    function exitMarket(address vToken) external returns (uint);\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    function mintAllowed(address vToken, address minter, uint mintAmount) external returns (uint);\r\n    function mintVerify(address vToken, address minter, uint mintAmount, uint mintTokens) external;\r\n\r\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external returns (uint);\r\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\r\n\r\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external returns (uint);\r\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external;\r\n\r\n    function repayBorrowAllowed(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function repayBorrowVerify(\r\n        address vToken,\r\n        address payer,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint borrowerIndex) external;\r\n\r\n    function liquidateBorrowAllowed(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount) external returns (uint);\r\n    function liquidateBorrowVerify(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        address liquidator,\r\n        address borrower,\r\n        uint repayAmount,\r\n        uint seizeTokens) external;\r\n\r\n    function seizeAllowed(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external returns (uint);\r\n    function seizeVerify(\r\n        address vTokenCollateral,\r\n        address vTokenBorrowed,\r\n        address liquidator,\r\n        address borrower,\r\n        uint seizeTokens) external;\r\n\r\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external returns (uint);\r\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external;\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address vTokenBorrowed,\r\n        address vTokenCollateral,\r\n        uint repayAmount) external view returns (uint, uint);\r\n    function setMintedVAIOf(address owner, uint amount) external returns (uint);\r\n}\r\n\r\ncontract ComptrollerInterfaceG2 is ComptrollerInterfaceG1 {\r\n    function liquidateVAICalculateSeizeTokens(\r\n        address vTokenCollateral,\r\n        uint repayAmount) external view returns (uint, uint);\r\n}\r\n\r\ncontract ComptrollerInterface is ComptrollerInterfaceG2 {\r\n    function markets(address) external view returns (bool, uint);\r\n    function oracle() external view returns (PriceOracle);\r\n    function getAccountLiquidity(address) external view returns (uint, uint, uint);\r\n    function getAssetsIn(address) external view returns (VToken[] memory);\r\n    function claimVenus(address) external;\r\n    function venusAccrued(address) external view returns (uint);\r\n    function venusSpeeds(address) external view returns (uint);\r\n    function getAllMarkets() external view returns (VToken[] memory);\r\n    function venusSupplierIndex(address, address) external view returns (uint);\r\n    function venusInitialIndex() external view returns (uint224);\r\n    function venusBorrowerIndex(address, address) external view returns (uint);\r\n    function venusBorrowState(address) external view returns (uint224, uint32);\r\n    function venusSupplyState(address) external view returns (uint224, uint32);\r\n}\r\n\r\ninterface IVAIVault {\r\n    function updatePendingRewards() external;\r\n}\r\n\r\ninterface IComptroller {\r\n    function liquidationIncentiveMantissa() external view returns (uint);\r\n    /*** Treasury Data ***/\r\n    function treasuryAddress() external view returns (address);\r\n    function treasuryPercent() external view returns (uint);\r\n}\r\n"
    },
    "contracts/ComptrollerLensInterface.sol": {
      "content": "pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./VToken.sol\";\r\n\r\ninterface ComptrollerLensInterface {\r\n    function liquidateCalculateSeizeTokens(\r\n        address comptroller, \r\n        address vTokenBorrowed, \r\n        address vTokenCollateral, \r\n        uint actualRepayAmount\r\n    ) external view returns (uint, uint);\r\n    function liquidateVAICalculateSeizeTokens(\r\n        address comptroller,\r\n        address vTokenCollateral, \r\n        uint actualRepayAmount\r\n    ) external view returns (uint, uint);\r\n    function getHypotheticalAccountLiquidity(\r\n        address comptroller,\r\n        address account,\r\n        VToken vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) external view returns (uint, uint, uint);\r\n}\r\n"
    },
    "contracts/ComptrollerStorage.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"./VAIControllerInterface.sol\";\r\nimport \"./ComptrollerLensInterface.sol\";\r\n\r\ncontract UnitrollerAdminStorage {\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active brains of Unitroller\r\n    */\r\n    address public comptrollerImplementation;\r\n\r\n    /**\r\n    * @notice Pending brains of Unitroller\r\n    */\r\n    address public pendingComptrollerImplementation;\r\n}\r\n\r\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\r\n\r\n    /**\r\n     * @notice Oracle which gives the price of any given asset\r\n     */\r\n    PriceOracle public oracle;\r\n\r\n    /**\r\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\r\n     */\r\n    uint public closeFactorMantissa;\r\n\r\n    /**\r\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\r\n     */\r\n    uint public liquidationIncentiveMantissa;\r\n\r\n    /**\r\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\r\n     */\r\n    uint public maxAssets;\r\n\r\n    /**\r\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\r\n     */\r\n    mapping(address => VToken[]) public accountAssets;\r\n\r\n    struct Market {\r\n        /// @notice Whether or not this market is listed\r\n        bool isListed;\r\n\r\n        /**\r\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\r\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\r\n         *  Must be between 0 and 1, and stored as a mantissa.\r\n         */\r\n        uint collateralFactorMantissa;\r\n\r\n        /// @notice Per-market mapping of \"accounts in this asset\"\r\n        mapping(address => bool) accountMembership;\r\n\r\n        /// @notice Whether or not this market receives XVS\r\n        bool isVenus;\r\n    }\r\n\r\n    /**\r\n     * @notice Official mapping of vTokens -> Market metadata\r\n     * @dev Used e.g. to determine if a market is supported\r\n     */\r\n    mapping(address => Market) public markets;\r\n\r\n    /**\r\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\r\n     */\r\n    address public pauseGuardian;\r\n\r\n    /// @notice Whether minting is paused (deprecated, superseded by actionPaused)\r\n    bool private _mintGuardianPaused;\r\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\r\n    bool private _borrowGuardianPaused;\r\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\r\n    bool internal transferGuardianPaused;\r\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\r\n    bool internal seizeGuardianPaused;\r\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\r\n    mapping(address => bool) internal mintGuardianPaused;\r\n    /// @notice Whether borrowing is paused (deprecated, superseded by actionPaused)\r\n    mapping(address => bool) internal borrowGuardianPaused;\r\n\r\n    struct VenusMarketState {\r\n        /// @notice The market's last updated venusBorrowIndex or venusSupplyIndex\r\n        uint224 index;\r\n\r\n        /// @notice The block number the index was last updated at\r\n        uint32 block;\r\n    }\r\n\r\n    /// @notice A list of all markets\r\n    VToken[] public allMarkets;\r\n\r\n    /// @notice The rate at which the flywheel distributes XVS, per block\r\n    uint public venusRate;\r\n\r\n    /// @notice The portion of venusRate that each market currently receives\r\n    mapping(address => uint) public venusSpeeds;\r\n\r\n    /// @notice The Venus market supply state for each market\r\n    mapping(address => VenusMarketState) public venusSupplyState;\r\n\r\n    /// @notice The Venus market borrow state for each market\r\n    mapping(address => VenusMarketState) public venusBorrowState;\r\n\r\n    /// @notice The Venus supply index for each market for each supplier as of the last time they accrued XVS\r\n    mapping(address => mapping(address => uint)) public venusSupplierIndex;\r\n\r\n    /// @notice The Venus borrow index for each market for each borrower as of the last time they accrued XVS\r\n    mapping(address => mapping(address => uint)) public venusBorrowerIndex;\r\n\r\n    /// @notice The XVS accrued but not yet transferred to each user\r\n    mapping(address => uint) public venusAccrued;\r\n\r\n    /// @notice The Address of VAIController\r\n    VAIControllerInterface public vaiController;\r\n\r\n    /// @notice The minted VAI amount to each user\r\n    mapping(address => uint) public mintedVAIs;\r\n\r\n    /// @notice VAI Mint Rate as a percentage\r\n    uint public vaiMintRate;\r\n\r\n    /**\r\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\r\n     */\r\n    bool public mintVAIGuardianPaused;\r\n    bool public repayVAIGuardianPaused;\r\n\r\n    /**\r\n     * @notice Pause/Unpause whole protocol actions\r\n     */\r\n    bool public protocolPaused;\r\n\r\n    /// @notice The rate at which the flywheel distributes XVS to VAI Minters, per block (deprecated)\r\n    uint private venusVAIRate;\r\n}\r\n\r\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\r\n    /// @notice The rate at which the flywheel distributes XVS to VAI Vault, per block\r\n    uint public venusVAIVaultRate;\r\n\r\n    // address of VAI Vault\r\n    address public vaiVaultAddress;\r\n\r\n    // start block of release to VAI Vault\r\n    uint256 public releaseStartBlock;\r\n\r\n    // minimum release amount to VAI Vault\r\n    uint256 public minReleaseAmount;\r\n}\r\n\r\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\r\n    /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\r\n    address public borrowCapGuardian;\r\n\r\n    /// @notice Borrow caps enforced by borrowAllowed for each vToken address. Defaults to zero which corresponds to unlimited borrowing.\r\n    mapping(address => uint) public borrowCaps;\r\n}\r\n\r\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\r\n    /// @notice Treasury Guardian address\r\n    address public treasuryGuardian;\r\n\r\n    /// @notice Treasury address\r\n    address public treasuryAddress;\r\n\r\n    /// @notice Fee percent of accrued interest with decimal 18\r\n    uint256 public treasuryPercent;\r\n}\r\n\r\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\r\n    /// @notice The portion of XVS that each contributor receives per block (deprecated)\r\n    mapping(address => uint) private venusContributorSpeeds;\r\n\r\n    /// @notice Last block at which a contributor's XVS rewards have been allocated (deprecated)\r\n    mapping(address => uint) private lastContributorBlock;\r\n}\r\n\r\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\r\n    address public liquidatorContract;\r\n}\r\n\r\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\r\n    ComptrollerLensInterface public comptrollerLens;\r\n}\r\n\r\ncontract ComptrollerV8Storage is ComptrollerV7Storage {\r\n    \r\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\r\n    mapping(address => uint256) public supplyCaps;\r\n}\r\n    \r\ncontract ComptrollerV9Storage is ComptrollerV8Storage {\r\n    /// @notice AccessControlManager address\r\n    address accessControl;\r\n\r\n    enum Action {\r\n        MINT,\r\n        REDEEM,\r\n        BORROW,\r\n        REPAY,\r\n        SEIZE,\r\n        LIQUIDATE,\r\n        TRANSFER,\r\n        ENTER_MARKET,\r\n        EXIT_MARKET\r\n    }\r\n\r\n    /// @notice True if a certain action is paused on a certain market\r\n    mapping (address => mapping(uint => bool)) internal _actionPaused;\r\n}\r\n"
    },
    "contracts/Context.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n  // Empty internal constructor, to prevent people from mistakenly deploying\r\n  // an instance of this contract, which should be used via inheritance.\r\n  constructor () internal { }\r\n\r\n  function _msgSender() internal view returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}"
    },
    "contracts/DAIInterestRateModelV2.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./JumpRateModel.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n/**\r\n  * @title Venus's DAIInterestRateModel Contract (version 2)\r\n  * @author Venus (modified by Dharma Labs)\r\n  * @notice The parameterized model described in section 2.4 of the original Venus Protocol whitepaper.\r\n  * Version 2 modifies the original interest rate model by increasing the \"gap\" or slope of the model prior\r\n  * to the \"kink\" from 0.05% to 2% with the goal of \"smoothing out\" interest rate changes as the utilization\r\n  * rate increases.\r\n  */\r\ncontract DAIInterestRateModelV2 is JumpRateModel {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * @notice The additional margin per block separating the base borrow rate from the roof (2% / block).\r\n     * Note that this value has been increased from the original value of 0.05% per block.\r\n     */\r\n    uint public constant gapPerBlock = 2e16 / blocksPerYear;\r\n\r\n    /**\r\n     * @notice The assumed (1 - reserve factor) used to calculate the minimum borrow rate (reserve factor = 0.05)\r\n     */\r\n    uint public constant assumedOneMinusReserveFactorMantissa = 0.95e18;\r\n\r\n    PotLike pot;\r\n    JugLike jug;\r\n\r\n    /**\r\n     * @notice Construct an interest rate model\r\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\r\n     * @param kink_ The utilization point at which the jump multiplier is applied\r\n     * @param pot_ The address of the Dai pot (where DSR is earned)\r\n     * @param jug_ The address of the Dai jug (where SF is kept)\r\n     */\r\n    constructor(uint jumpMultiplierPerYear, uint kink_, address pot_, address jug_) JumpRateModel(0, 0, jumpMultiplierPerYear, kink_) public {\r\n        pot = PotLike(pot_);\r\n        jug = JugLike(jug_);\r\n        poke();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current supply interest rate per block including the Dai savings rate\r\n     * @param cash The total amount of cash the market has\r\n     * @param borrows The total amount of borrows the market has outstanding\r\n     * @param reserves The total amnount of reserves the market has\r\n     * @param reserveFactorMantissa The current reserve factor the market has\r\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\r\n     */\r\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view returns (uint) {\r\n        uint protocolRate = super.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa);\r\n\r\n        uint underlying = cash.add(borrows).sub(reserves);\r\n        if (underlying == 0) {\r\n            return protocolRate;\r\n        } else {\r\n            uint cashRate = cash.mul(dsrPerBlock()).div(underlying);\r\n            return cashRate.add(protocolRate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the Dai savings rate per block\r\n     * @return The Dai savings rate per block (as a percentage, and scaled by 1e18)\r\n     */\r\n    function dsrPerBlock() public view returns (uint) {\r\n        return pot\r\n            .dsr().sub(1e27)  // scaled 1e27 aka RAY, and includes an extra \"ONE\" before subraction\r\n            .div(1e9) // descale to 1e18\r\n            .mul(3); // 3 seconds per block\r\n    }\r\n\r\n    /**\r\n     * @notice Resets the baseRate and multiplier per block based on the stability fee and Dai savings rate\r\n     */\r\n    function poke() public {\r\n        (uint duty, ) = jug.ilks(\"BNB-A\");\r\n        uint stabilityFeePerBlock = duty.add(jug.base()).sub(1e27).mul(1e18).div(1e27).mul(3);\r\n\r\n        // We ensure the minimum borrow rate >= DSR / (1 - reserve factor)\r\n        baseRatePerBlock = dsrPerBlock().mul(1e18).div(assumedOneMinusReserveFactorMantissa);\r\n\r\n        // The roof borrow rate is max(base rate, stability fee) + gap, from which we derive the slope\r\n        if (baseRatePerBlock < stabilityFeePerBlock) {\r\n            multiplierPerBlock = stabilityFeePerBlock.sub(baseRatePerBlock).add(gapPerBlock).mul(1e18).div(kink);\r\n        } else {\r\n            multiplierPerBlock = gapPerBlock.mul(1e18).div(kink);\r\n        }\r\n\r\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\r\n    }\r\n}\r\n\r\n\r\n/*** Maker Interfaces ***/\r\n\r\ncontract PotLike {\r\n    function chi() external view returns (uint);\r\n    function dsr() external view returns (uint);\r\n    function rho() external view returns (uint);\r\n    function pie(address) external view returns (uint);\r\n    function drip() external returns (uint);\r\n    function join(uint) external;\r\n    function exit(uint) external;\r\n}\r\n\r\ncontract JugLike {\r\n    // --- Data ---\r\n    struct Ilk {\r\n        uint256 duty;\r\n        uint256  rho;\r\n    }\r\n\r\n   mapping (bytes32 => Ilk) public ilks;\r\n   uint256 public base;\r\n}\r\n"
    },
    "contracts/EIP20Interface.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title BEP 20 Token Standard Interface\r\n *  https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface EIP20Interface {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n      * @notice Get the total number of tokens in circulation\r\n      * @return The supply of tokens\r\n      */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return Whether or not the transfer succeeded\r\n      */\r\n    function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return Whether or not the transfer succeeded\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved (-1 means infinite)\r\n      * @return Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return The number of tokens allowed to be spent (-1 means infinite)\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n"
    },
    "contracts/EIP20NonStandardInterface.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title EIP20NonStandardInterface\r\n * @dev Version of BEP20 with no return values for `transfer` and `transferFrom`\r\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n */\r\ninterface EIP20NonStandardInterface {\r\n\r\n    /**\r\n     * @notice Get the total number of tokens in circulation\r\n     * @return The supply of tokens\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the BEP-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transfer(address dst, uint256 amount) external;\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the BEP-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external;\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved\r\n      * @return Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return The number of tokens allowed to be spent\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n"
    },
    "contracts/ErrorReporter.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\ncontract ComptrollerErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        COMPTROLLER_MISMATCH,\r\n        INSUFFICIENT_SHORTFALL,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INVALID_CLOSE_FACTOR,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        INVALID_LIQUIDATION_INCENTIVE,\r\n        MARKET_NOT_ENTERED, // no longer possible\r\n        MARKET_NOT_LISTED,\r\n        MARKET_ALREADY_LISTED,\r\n        MATH_ERROR,\r\n        NONZERO_BORROW_BALANCE,\r\n        PRICE_ERROR,\r\n        REJECTION,\r\n        SNAPSHOT_ERROR,\r\n        TOO_MANY_ASSETS,\r\n        TOO_MUCH_REPAY,\r\n        INSUFFICIENT_BALANCE_FOR_VAI\r\n    }\r\n\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        EXIT_MARKET_BALANCE_OWED,\r\n        EXIT_MARKET_REJECTION,\r\n        SET_CLOSE_FACTOR_OWNER_CHECK,\r\n        SET_CLOSE_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\r\n        SET_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\r\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_PRICE_ORACLE_OWNER_CHECK,\r\n        SUPPORT_MARKET_EXISTS,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\r\n        SET_VAI_MINT_RATE_CHECK,\r\n        SET_VAICONTROLLER_OWNER_CHECK,\r\n        SET_MINTED_VAI_REJECTION,\r\n        SET_TREASURY_OWNER_CHECK\r\n    }\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\ncontract TokenErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        BAD_INPUT,\r\n        COMPTROLLER_REJECTION,\r\n        COMPTROLLER_CALCULATION_ERROR,\r\n        INTEREST_RATE_MODEL_ERROR,\r\n        INVALID_ACCOUNT_PAIR,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        INVALID_COLLATERAL_FACTOR,\r\n        MATH_ERROR,\r\n        MARKET_NOT_FRESH,\r\n        MARKET_NOT_LISTED,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_IN_FAILED,\r\n        TOKEN_TRANSFER_OUT_FAILED,\r\n        TOKEN_PRICE_ERROR\r\n    }\r\n\r\n    /*\r\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\r\n     *       This is because FailureInfo grows significantly faster, and\r\n     *       the order of Error has some meaning, while the order of FailureInfo\r\n     *       is entirely arbitrary.\r\n     */\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\r\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_ACCRUE_INTEREST_FAILED,\r\n        BORROW_CASH_NOT_AVAILABLE,\r\n        BORROW_FRESHNESS_CHECK,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        BORROW_MARKET_NOT_LISTED,\r\n        BORROW_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\r\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\r\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\r\n        LIQUIDATE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\r\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\r\n        LIQUIDATE_FRESHNESS_CHECK,\r\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\r\n        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\r\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\r\n        LIQUIDATE_SEIZE_TOO_MUCH,\r\n        MINT_ACCRUE_INTEREST_FAILED,\r\n        MINT_COMPTROLLER_REJECTION,\r\n        MINT_EXCHANGE_CALCULATION_FAILED,\r\n        MINT_EXCHANGE_RATE_READ_FAILED,\r\n        MINT_FRESHNESS_CHECK,\r\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        MINT_TRANSFER_IN_FAILED,\r\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\r\n        REDEEM_ACCRUE_INTEREST_FAILED,\r\n        REDEEM_COMPTROLLER_REJECTION,\r\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\r\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\r\n        REDEEM_FRESHNESS_CHECK,\r\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\r\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\r\n        REDUCE_RESERVES_ADMIN_CHECK,\r\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\r\n        REDUCE_RESERVES_FRESH_CHECK,\r\n        REDUCE_RESERVES_VALIDATION,\r\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_COMPTROLLER_REJECTION,\r\n        REPAY_BORROW_FRESHNESS_CHECK,\r\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n        SET_COLLATERAL_FACTOR_VALIDATION,\r\n        SET_COMPTROLLER_OWNER_CHECK,\r\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\r\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\r\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_MAX_ASSETS_OWNER_CHECK,\r\n        SET_ORACLE_MARKET_NOT_LISTED,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\r\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\r\n        SET_RESERVE_FACTOR_FRESH_CHECK,\r\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\r\n        TRANSFER_COMPTROLLER_REJECTION,\r\n        TRANSFER_NOT_ALLOWED,\r\n        TRANSFER_NOT_ENOUGH,\r\n        TRANSFER_TOO_MUCH,\r\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\r\n        ADD_RESERVES_FRESH_CHECK,\r\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\r\n        TOKEN_GET_UNDERLYING_PRICE_ERROR,\r\n        REPAY_VAI_COMPTROLLER_REJECTION,\r\n        REPAY_VAI_FRESHNESS_CHECK,\r\n        VAI_MINT_EXCHANGE_CALCULATION_FAILED,\r\n        SFT_MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n        REDEEM_FEE_CALCULATION_FAILED\r\n    }\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n\r\ncontract VAIControllerErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED,\r\n        REJECTION,\r\n        SNAPSHOT_ERROR,\r\n        PRICE_ERROR,\r\n        MATH_ERROR,\r\n        INSUFFICIENT_BALANCE_FOR_VAI\r\n    }\r\n\r\n    enum FailureInfo {\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\r\n        SET_COMPTROLLER_OWNER_CHECK,\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        VAI_MINT_REJECTION,\r\n        VAI_BURN_REJECTION,\r\n        VAI_LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\r\n        VAI_LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\r\n        VAI_LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\r\n        VAI_LIQUIDATE_COMPTROLLER_REJECTION,\r\n        VAI_LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\r\n        VAI_LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\r\n        VAI_LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\r\n        VAI_LIQUIDATE_FRESHNESS_CHECK,\r\n        VAI_LIQUIDATE_LIQUIDATOR_IS_BORROWER,\r\n        VAI_LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\r\n        VAI_LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\r\n        VAI_LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\r\n        VAI_LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\r\n        VAI_LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\r\n        VAI_LIQUIDATE_SEIZE_TOO_MUCH,\r\n        MINT_FEE_CALCULATION_FAILED,\r\n        SET_TREASURY_OWNER_CHECK\r\n    }\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}"
    },
    "contracts/Exponential.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./CarefulMath.sol\";\r\nimport \"./ExponentialNoError.sol\";\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author Venus\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract Exponential is CarefulMath, ExponentialNoError {\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint num, uint denom) internal pure returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\r\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\r\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mulScalarTruncate(Exp memory a, uint scalar) internal pure returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(product));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (MathError, uint) {\r\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return addUInt(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint scalar) internal pure returns (MathError, Exp memory) {\r\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\r\n        /*\r\n          We are doing this as:\r\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\r\n\r\n          How it works:\r\n          Exp = a / b;\r\n          Scalar = s;\r\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\r\n     */\r\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) internal pure returns (MathError, uint) {\r\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, truncate(fraction));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\r\n\r\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n        if (err0 != MathError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n        if (err1 != MathError.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == MathError.NO_ERROR);\r\n\r\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\r\n     */\r\n    function mulExp(uint a, uint b) internal pure returns (MathError, Exp memory) {\r\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies three exponentials, returning a new exponential.\r\n     */\r\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) internal pure returns (MathError, Exp memory) {\r\n        (MathError err, Exp memory ab) = mulExp(a, b);\r\n        if (err != MathError.NO_ERROR) {\r\n            return (err, ab);\r\n        }\r\n        return mulExp(ab, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n}\r\n"
    },
    "contracts/ExponentialNoError.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author Compound\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract ExponentialNoError {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return truncate(product);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return add_(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp > right Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n}\r\n"
    },
    "contracts/Governance/GovernorAlpha.sol": {
      "content": "pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract GovernorAlpha {\r\n    /// @notice The name of this contract\r\n    string public constant name = \"Venus Governor Alpha\";\r\n\r\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\r\n    function quorumVotes() public pure returns (uint) { return 600000e18; } // 600,000 = 2% of XVS\r\n\r\n    /// @notice The number of votes required in order for a voter to become a proposer\r\n    function proposalThreshold() public pure returns (uint) { return 300000e18; } // 300,000 = 1% of XVS\r\n\r\n    /// @notice The maximum number of actions that can be included in a proposal\r\n    function proposalMaxOperations() public pure returns (uint) { return 10; } // 10 actions\r\n\r\n    /// @notice The delay before voting on a proposal may take place, once proposed\r\n    function votingDelay() public pure returns (uint) { return 1; } // 1 block\r\n\r\n    /// @notice The duration of voting on a proposal, in blocks\r\n    function votingPeriod() public pure returns (uint) { return 60 * 60 * 24 * 3 / 3; } // ~3 days in blocks (assuming 3s blocks)\r\n\r\n    /// @notice The address of the Venus Protocol Timelock\r\n    TimelockInterface public timelock;\r\n\r\n    /// @notice The address of the Venus governance token\r\n    XVSInterface public xvs;\r\n\r\n    /// @notice The address of the Governor Guardian\r\n    address public guardian;\r\n\r\n    /// @notice The total number of proposals\r\n    uint public proposalCount;\r\n\r\n    struct Proposal {\r\n        /// @notice Unique id for looking up a proposal\r\n        uint id;\r\n\r\n        /// @notice Creator of the proposal\r\n        address proposer;\r\n\r\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\r\n        uint eta;\r\n\r\n        /// @notice the ordered list of target addresses for calls to be made\r\n        address[] targets;\r\n\r\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\r\n        uint[] values;\r\n\r\n        /// @notice The ordered list of function signatures to be called\r\n        string[] signatures;\r\n\r\n        /// @notice The ordered list of calldata to be passed to each call\r\n        bytes[] calldatas;\r\n\r\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\r\n        uint startBlock;\r\n\r\n        /// @notice The block at which voting ends: votes must be cast prior to this block\r\n        uint endBlock;\r\n\r\n        /// @notice Current number of votes in favor of this proposal\r\n        uint forVotes;\r\n\r\n        /// @notice Current number of votes in opposition to this proposal\r\n        uint againstVotes;\r\n\r\n        /// @notice Flag marking whether the proposal has been canceled\r\n        bool canceled;\r\n\r\n        /// @notice Flag marking whether the proposal has been executed\r\n        bool executed;\r\n\r\n        /// @notice Receipts of ballots for the entire set of voters\r\n        mapping (address => Receipt) receipts;\r\n    }\r\n\r\n    /// @notice Ballot receipt record for a voter\r\n    struct Receipt {\r\n        /// @notice Whether or not a vote has been cast\r\n        bool hasVoted;\r\n\r\n        /// @notice Whether or not the voter supports the proposal\r\n        bool support;\r\n\r\n        /// @notice The number of votes the voter had, which were cast\r\n        uint96 votes;\r\n    }\r\n\r\n    /// @notice Possible states that a proposal may be in\r\n    enum ProposalState {\r\n        Pending,\r\n        Active,\r\n        Canceled,\r\n        Defeated,\r\n        Succeeded,\r\n        Queued,\r\n        Expired,\r\n        Executed\r\n    }\r\n\r\n    /// @notice The official record of all proposals ever proposed\r\n    mapping (uint => Proposal) public proposals;\r\n\r\n    /// @notice The latest proposal for each proposer\r\n    mapping (address => uint) public latestProposalIds;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\r\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\r\n\r\n    /// @notice An event emitted when a new proposal is created\r\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\r\n\r\n    /// @notice An event emitted when a vote has been cast on a proposal\r\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\r\n\r\n    /// @notice An event emitted when a proposal has been canceled\r\n    event ProposalCanceled(uint id);\r\n\r\n    /// @notice An event emitted when a proposal has been queued in the Timelock\r\n    event ProposalQueued(uint id, uint eta);\r\n\r\n    /// @notice An event emitted when a proposal has been executed in the Timelock\r\n    event ProposalExecuted(uint id);\r\n\r\n    constructor(address timelock_, address xvs_, address guardian_) public {\r\n        timelock = TimelockInterface(timelock_);\r\n        xvs = XVSInterface(xvs_);\r\n        guardian = guardian_;\r\n    }\r\n\r\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\r\n        require(xvs.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\r\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\r\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\r\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\r\n\r\n        uint latestProposalId = latestProposalIds[msg.sender];\r\n        if (latestProposalId != 0) {\r\n          ProposalState proposersLatestProposalState = state(latestProposalId);\r\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: found an already active proposal\");\r\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: found an already pending proposal\");\r\n        }\r\n\r\n        uint startBlock = add256(block.number, votingDelay());\r\n        uint endBlock = add256(startBlock, votingPeriod());\r\n\r\n        proposalCount++;\r\n        Proposal memory newProposal = Proposal({\r\n            id: proposalCount,\r\n            proposer: msg.sender,\r\n            eta: 0,\r\n            targets: targets,\r\n            values: values,\r\n            signatures: signatures,\r\n            calldatas: calldatas,\r\n            startBlock: startBlock,\r\n            endBlock: endBlock,\r\n            forVotes: 0,\r\n            againstVotes: 0,\r\n            canceled: false,\r\n            executed: false\r\n        });\r\n\r\n        proposals[newProposal.id] = newProposal;\r\n        latestProposalIds[newProposal.proposer] = newProposal.id;\r\n\r\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\r\n        return newProposal.id;\r\n    }\r\n\r\n    function queue(uint proposalId) public {\r\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        uint eta = add256(block.timestamp, timelock.delay());\r\n        for (uint i = 0; i < proposal.targets.length; i++) {\r\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\r\n        }\r\n        proposal.eta = eta;\r\n        emit ProposalQueued(proposalId, eta);\r\n    }\r\n\r\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\r\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\r\n        timelock.queueTransaction(target, value, signature, data, eta);\r\n    }\r\n\r\n    function execute(uint proposalId) public payable {\r\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        proposal.executed = true;\r\n        for (uint i = 0; i < proposal.targets.length; i++) {\r\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\r\n        }\r\n        emit ProposalExecuted(proposalId);\r\n    }\r\n\r\n    function cancel(uint proposalId) public {\r\n        ProposalState state = state(proposalId);\r\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(msg.sender == guardian || xvs.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\r\n\r\n        proposal.canceled = true;\r\n        for (uint i = 0; i < proposal.targets.length; i++) {\r\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\r\n        }\r\n\r\n        emit ProposalCanceled(proposalId);\r\n    }\r\n\r\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\r\n        Proposal storage p = proposals[proposalId];\r\n        return (p.targets, p.values, p.signatures, p.calldatas);\r\n    }\r\n\r\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\r\n        return proposals[proposalId].receipts[voter];\r\n    }\r\n\r\n    function state(uint proposalId) public view returns (ProposalState) {\r\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        if (proposal.canceled) {\r\n            return ProposalState.Canceled;\r\n        } else if (block.number <= proposal.startBlock) {\r\n            return ProposalState.Pending;\r\n        } else if (block.number <= proposal.endBlock) {\r\n            return ProposalState.Active;\r\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\r\n            return ProposalState.Defeated;\r\n        } else if (proposal.eta == 0) {\r\n            return ProposalState.Succeeded;\r\n        } else if (proposal.executed) {\r\n            return ProposalState.Executed;\r\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\r\n            return ProposalState.Expired;\r\n        } else {\r\n            return ProposalState.Queued;\r\n        }\r\n    }\r\n\r\n    function castVote(uint proposalId, bool support) public {\r\n        return _castVote(msg.sender, proposalId, support);\r\n    }\r\n\r\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\r\n        return _castVote(signatory, proposalId, support);\r\n    }\r\n\r\n    function _castVote(address voter, uint proposalId, bool support) internal {\r\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\r\n        Proposal storage proposal = proposals[proposalId];\r\n        Receipt storage receipt = proposal.receipts[voter];\r\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\r\n        uint96 votes = xvs.getPriorVotes(voter, proposal.startBlock);\r\n\r\n        if (support) {\r\n            proposal.forVotes = add256(proposal.forVotes, votes);\r\n        } else {\r\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\r\n        }\r\n\r\n        receipt.hasVoted = true;\r\n        receipt.support = support;\r\n        receipt.votes = votes;\r\n\r\n        emit VoteCast(voter, proposalId, support, votes);\r\n    }\r\n\r\n    function __acceptAdmin() public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\r\n        timelock.acceptAdmin();\r\n    }\r\n\r\n    function __abdicate() public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\r\n        guardian = address(0);\r\n    }\r\n\r\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\r\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\r\n    }\r\n\r\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\r\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\r\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\r\n    }\r\n\r\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        require(b <= a, \"subtraction underflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n\r\ninterface TimelockInterface {\r\n    function delay() external view returns (uint);\r\n    function GRACE_PERIOD() external view returns (uint);\r\n    function acceptAdmin() external;\r\n    function queuedTransactions(bytes32 hash) external view returns (bool);\r\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\r\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\r\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\r\n}\r\n\r\ninterface XVSInterface {\r\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\r\n}\r\n"
    },
    "contracts/Governance/SXP.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'SXP' 'Swipe' BEP20 token contract\r\n//\r\n// Symbol      : SXP\r\n// Name        : Swipe\r\n// Total supply: 289,714,926.000000000000000000\r\n// Decimals    : 18\r\n// Website     : https://swipe.io\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\nimport \"../SafeMath.sol\";\r\nimport \"../Ownable.sol\";\r\nimport \"../BEP20Interface.sol\";\r\n\r\ncontract Tokenlock is Ownable {\r\n    /// @notice Indicates if token is locked\r\n    uint8 isLocked = 0;\r\n\r\n    event Freezed();\r\n    event UnFreezed();\r\n\r\n    modifier validLock {\r\n        require(isLocked == 0, \"Token is locked\");\r\n        _;\r\n    }\r\n\r\n    function freeze() public onlyOwner {\r\n        isLocked = 1;\r\n\r\n        emit Freezed();\r\n    }\r\n\r\n    function unfreeze() public onlyOwner {\r\n        isLocked = 0;\r\n\r\n        emit UnFreezed();\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Limit users in blacklist\r\n// ----------------------------------------------------------------------------\r\ncontract UserLock is Ownable {\r\n    mapping(address => bool) blacklist;\r\n\r\n    event LockUser(address indexed who);\r\n    event UnlockUser(address indexed who);\r\n\r\n    modifier permissionCheck {\r\n        require(!blacklist[msg.sender], \"Blocked user\");\r\n        _;\r\n    }\r\n\r\n    function lockUser(address who) public onlyOwner {\r\n        blacklist[who] = true;\r\n\r\n        emit LockUser(who);\r\n    }\r\n\r\n    function unlockUser(address who) public onlyOwner {\r\n        blacklist[who] = false;\r\n\r\n        emit UnlockUser(who);\r\n    }\r\n}\r\n\r\ncontract SXP is BEP20Interface, Tokenlock, UserLock {\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Official record of token balances for each account\r\n    mapping (address => uint256) private _balances;\r\n\r\n    /// @notice Allowance amounts on behalf of others\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    /// @notice Total number of tokens in circulation\r\n    uint256 private _totalSupply;\r\n\r\n    /// @notice BEP-20 token decimals for this token\r\n    uint8 private _decimals;\r\n\r\n    /// @notice BEP-20 token symbol for this token\r\n    string private _symbol;\r\n\r\n    /// @notice BEP-20 token name for this token\r\n    string private _name;\r\n\r\n    /// @notice A record of each accounts delegate\r\n    mapping (address => address) public delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint256) public nonces;\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\r\n\r\n    /// @notice The standard BEP-20 transfer event\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @notice The standard BEP-20 approval event\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /**\r\n     * @notice Construct a new SXP token\r\n     * @param account The initial account to grant all the tokens\r\n     */\r\n    constructor(address account) public {\r\n        _name = \"Swipe\";\r\n        _symbol = \"SXP\";\r\n        _decimals = 18;\r\n        _totalSupply = 289714926e18;\r\n        _balances[account] = _totalSupply;\r\n\r\n        emit Transfer(address(0), account, _totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n    */\r\n    function getOwner() external view returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n    */\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n    */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n    */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total supply.\r\n    */\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens held by the `account`\r\n     * @param account The address of the account to get the balance of\r\n     * @return The number of tokens held\r\n     */\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param recipient The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address recipient, uint256 amount) external validLock permissionCheck returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\r\n     * @param owner The address of the account holding the funds\r\n     * @param spender The address of the account spending the funds\r\n     * @return The number of tokens approved\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint256 amount) external validLock permissionCheck returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the spender to transferFrom(...) with the amount.\r\n     * @dev receiveApproval(...) is executed.\r\n     * @param amount The number of tokens that are approved\r\n     * @param data The data to pass to receiveApproval(...)\r\n     * @return true\r\n     */\r\n    function approveAndCall(address spender, uint256 amount, bytes memory data) public validLock permissionCheck returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        ApproveAndCallFallBack(spender).receiveApproval(_msgSender(), amount, address(this), data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param sender The address of the source account\r\n     * @param recipient The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external validLock permissionCheck returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        address spender = _msgSender();\r\n        uint256 spenderAllowance = _allowances[sender][spender];\r\n        if (spenderAllowance != uint256(-1)) {\r\n            _approve(sender, spender, spenderAllowance.sub(amount, \"The transfer amount exceeds allowance\"));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically increases the allowance granted to `spender` by the caller\r\n     * @dev This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {BEP20-approve}.\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param addedValue The additional number of tokens to allow which may be spent\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public validLock permissionCheck returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue, \"The increased allowance overflows\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Atomically increases the allowance granted to `spender` by the caller\r\n     * @dev This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {BEP20-approve}.\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param subtractedValue The subtractional number of tokens to allow which may be spent\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public validLock permissionCheck returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"The decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Destroy the amount of tokens from the sender, reducing the total supply.\r\n     * @dev The amount must be greater than balance, total supply.\r\n     * @param amount The number of tokens that are burnt\r\n     * @return true\r\n     */\r\n    function burn(uint256 amount) public validLock permissionCheck returns (bool) {\r\n        _burn(_msgSender(), amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) public validLock permissionCheck {\r\n        return _delegate(_msgSender(), delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) public validLock permissionCheck {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(_name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"Invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"Invalid nonce\");\r\n        require(now <= expiry, \"The signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint96) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? ceil96(checkpoints[account][nCheckpoints - 1].votes) : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\r\n        require(blockNumber < block.number, \"Not determined yet\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return ceil96(checkpoints[account][nCheckpoints - 1].votes);\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return ceil96(cp.votes);\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return ceil96(checkpoints[account][lower].votes);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"Cannot transfer from the zero address\");\r\n        require(recipient != address(0), \"Cannot transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"The transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount, \"The balance overflows\");\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _moveDelegates(delegates[sender], delegates[recipient], amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"Cannot approve from the zero address\");\r\n        require(spender != address(0), \"Cannot approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"Cannot burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"The burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _moveDelegates(delegates[account], address(0), amount);\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = delegates[delegator];\r\n        uint256 delegatorBalance = _balances[delegator];\r\n        delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint256 srcRepNew = srcRepOld.sub(amount, \"The vote amount underflows\");\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint256 dstRepNew = dstRepOld.add(amount, \"The vote amount overflows\");\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) internal {\r\n      uint32 blockNumber = safe32(block.number, \"The block number exceeds 32 bits\");\r\n\r\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n      } else {\r\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n          numCheckpoints[delegatee] = nCheckpoints + 1;\r\n      }\r\n\r\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function ceil96(uint256 n) internal pure returns (uint96) {\r\n        if (n >= 2**96) {\r\n            return uint96(-1);\r\n        }\r\n        return uint96(n);\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint256) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n"
    },
    "contracts/Governance/XVS.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Should be owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(owner, newOwner);\r\n    }\r\n}\r\n\r\ncontract Tokenlock is Owned {\r\n    /// @notice Indicates if token is locked\r\n    uint8 isLocked = 0;\r\n\r\n    event Freezed();\r\n    event UnFreezed();\r\n\r\n    modifier validLock {\r\n        require(isLocked == 0, \"Token is locked\");\r\n        _;\r\n    }\r\n\r\n    function freeze() public onlyOwner {\r\n        isLocked = 1;\r\n\r\n        emit Freezed();\r\n    }\r\n\r\n    function unfreeze() public onlyOwner {\r\n        isLocked = 0;\r\n\r\n        emit UnFreezed();\r\n    }\r\n}\r\n\r\ncontract XVS is Tokenlock {\r\n    /// @notice BEP-20 token name for this token\r\n    string public constant name = \"Venus\";\r\n\r\n    /// @notice BEP-20 token symbol for this token\r\n    string public constant symbol = \"XVS\";\r\n\r\n    /// @notice BEP-20 token decimals for this token\r\n    uint8 public constant decimals = 18;\r\n\r\n    /// @notice Total number of tokens in circulation\r\n    uint public constant totalSupply = 30000000e18; // 30 million XVS\r\n\r\n    /// @notice Allowance amounts on behalf of others\r\n    mapping (address => mapping (address => uint96)) internal allowances;\r\n\r\n    /// @notice Official record of token balances for each account\r\n    mapping (address => uint96) internal balances;\r\n\r\n    /// @notice A record of each accounts delegate\r\n    mapping (address => address) public delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint96 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    /// @notice The standard BEP-20 transfer event\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @notice The standard BEP-20 approval event\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /**\r\n     * @notice Construct a new XVS token\r\n     * @param account The initial account to grant all the tokens\r\n     */\r\n    constructor(address account) public {\r\n        balances[account] = uint96(totalSupply);\r\n        emit Transfer(address(0), account, totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\r\n     * @param account The address of the account holding the funds\r\n     * @param spender The address of the account spending the funds\r\n     * @return The number of tokens approved\r\n     */\r\n    function allowance(address account, address spender) external view returns (uint) {\r\n        return allowances[account][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint rawAmount) external validLock returns (bool) {\r\n        uint96 amount;\r\n        if (rawAmount == uint(-1)) {\r\n            amount = uint96(-1);\r\n        } else {\r\n            amount = safe96(rawAmount, \"XVS::approve: amount exceeds 96 bits\");\r\n        }\r\n\r\n        allowances[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens held by the `account`\r\n     * @param account The address of the account to get the balance of\r\n     * @return The number of tokens held\r\n     */\r\n    function balanceOf(address account) external view returns (uint) {\r\n        return balances[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param rawAmount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint rawAmount) external validLock returns (bool) {\r\n        uint96 amount = safe96(rawAmount, \"XVS::transfer: amount exceeds 96 bits\");\r\n        _transferTokens(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param rawAmount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint rawAmount) external validLock returns (bool) {\r\n        address spender = msg.sender;\r\n        uint96 spenderAllowance = allowances[src][spender];\r\n        uint96 amount = safe96(rawAmount, \"XVS::approve: amount exceeds 96 bits\");\r\n\r\n        if (spender != src && spenderAllowance != uint96(-1)) {\r\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"XVS::transferFrom: transfer amount exceeds spender allowance\");\r\n            allowances[src][spender] = newAllowance;\r\n\r\n            emit Approval(src, spender, newAllowance);\r\n        }\r\n\r\n        _transferTokens(src, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) public validLock {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public validLock {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"XVS::delegateBySig: invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"XVS::delegateBySig: invalid nonce\");\r\n        require(now <= expiry, \"XVS::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint96) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\r\n        require(blockNumber < block.number, \"XVS::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = delegates[delegator];\r\n        uint96 delegatorBalance = balances[delegator];\r\n        delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _transferTokens(address src, address dst, uint96 amount) internal {\r\n        require(src != address(0), \"XVS::_transferTokens: cannot transfer from the zero address\");\r\n        require(dst != address(0), \"XVS::_transferTokens: cannot transfer to the zero address\");\r\n\r\n        balances[src] = sub96(balances[src], amount, \"XVS::_transferTokens: transfer amount exceeds balance\");\r\n        balances[dst] = add96(balances[dst], amount, \"XVS::_transferTokens: transfer amount overflows\");\r\n        emit Transfer(src, dst, amount);\r\n\r\n        _moveDelegates(delegates[src], delegates[dst], amount);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"XVS::_moveVotes: vote amount underflows\");\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint96 dstRepNew = add96(dstRepOld, amount, \"XVS::_moveVotes: vote amount overflows\");\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\r\n      uint32 blockNumber = safe32(block.number, \"XVS::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n      } else {\r\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n          numCheckpoints[delegatee] = nCheckpoints + 1;\r\n      }\r\n\r\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\r\n        require(n < 2**96, errorMessage);\r\n        return uint96(n);\r\n    }\r\n\r\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        uint96 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n"
    },
    "contracts/IAccessControlManager.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\ninterface IAccessControlManager {\r\n   /**\r\n     * @notice Verifies if the given account can call a praticular contract's function\r\n     * @dev Since the contract is calling itself this function, we can get contracts address with msg.sender\r\n     * @param account address (eoa or contract) for which call permissions will be checked\r\n     * @param functionSig signature e.g. \"functionName(uint,bool)\"\r\n     * @return false if the user account cannot call the particular contract function\r\n     *\r\n     */\r\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Gives a function call permission to one single account\r\n     * @dev this function can be called only from Role Admin or DEFAULT_ADMIN_ROLE\r\n     * \t\tMay emit a {RoleGranted} event.\r\n     * @param contractAddress address of contract for which call permissions will be granted\r\n     * @param functionSig signature e.g. \"functionName(uint,bool)\"\r\n     */\r\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\r\n\r\n    /**\r\n     * @notice Revokes an account's permission to a particular function call\r\n     * @dev this function can be called only from Role Admin or DEFAULT_ADMIN_ROLE\r\n     * \t\tMay emit a {RoleRevoked} event.\r\n     * @param contractAddress address of contract for which call permissions will be revoked\r\n     * @param functionSig signature e.g. \"functionName(uint,bool)\"\r\n     */\r\n    function revokeCallPermission(address contractAddress, string calldata functionSig, address accountToRevoke) external;\r\n}"
    },
    "contracts/InterestRateModel.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/**\r\n  * @title Venus's InterestRateModel Interface\r\n  * @author Venus\r\n  */\r\ncontract InterestRateModel {\r\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\r\n    bool public constant isInterestRateModel = true;\r\n\r\n    /**\r\n      * @notice Calculates the current borrow interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amnount of reserves the market has\r\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);\r\n\r\n    /**\r\n      * @notice Calculates the current supply interest rate per block\r\n      * @param cash The total amount of cash the market has\r\n      * @param borrows The total amount of borrows the market has outstanding\r\n      * @param reserves The total amnount of reserves the market has\r\n      * @param reserveFactorMantissa The current reserve factor the market has\r\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\r\n      */\r\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);\r\n\r\n}\r\n"
    },
    "contracts/JumpRateModel.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./InterestRateModel.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n/**\r\n  * @title Venus's JumpRateModel Contract\r\n  * @author Venus\r\n  */\r\ncontract JumpRateModel is InterestRateModel {\r\n    using SafeMath for uint;\r\n\r\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\r\n\r\n    /**\r\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\r\n     */\r\n    uint public constant blocksPerYear = 60 * 60 * 24 * 365 / 3; // (assuming 3s blocks)\r\n\r\n    /**\r\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\r\n     */\r\n    uint public multiplierPerBlock;\r\n\r\n    /**\r\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\r\n     */\r\n    uint public baseRatePerBlock;\r\n\r\n    /**\r\n     * @notice The multiplierPerBlock after hitting a specified utilization point\r\n     */\r\n    uint public jumpMultiplierPerBlock;\r\n\r\n    /**\r\n     * @notice The utilization point at which the jump multiplier is applied\r\n     */\r\n    uint public kink;\r\n\r\n    /**\r\n     * @notice Construct an interest rate model\r\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\r\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\r\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\r\n     * @param kink_ The utilization point at which the jump multiplier is applied\r\n     */\r\n    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) public {\r\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\r\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\r\n        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\r\n        kink = kink_;\r\n\r\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market (currently unused)\r\n     * @return The utilization rate as a mantissa between [0, 1e18]\r\n     */\r\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\r\n        // Utilization rate is 0 when there are no borrows\r\n        if (borrows == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) public view returns (uint) {\r\n        uint util = utilizationRate(cash, borrows, reserves);\r\n\r\n        if (util <= kink) {\r\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\r\n        } else {\r\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\r\n            uint excessUtil = util.sub(kink);\r\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current supply rate per block\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @param reserveFactorMantissa The current reserve factor for the market\r\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view returns (uint) {\r\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\r\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\r\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\r\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\r\n    }\r\n}\r\n"
    },
    "contracts/Lens/ComptrollerLens.sol": {
      "content": "pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../VBep20.sol\";\r\nimport \"../VToken.sol\";\r\nimport \"../EIP20Interface.sol\";\r\nimport \"../PriceOracle.sol\";\r\nimport \"../ErrorReporter.sol\";\r\nimport \"../Comptroller.sol\";\r\n\r\ncontract ComptrollerLens is ComptrollerLensInterface, ComptrollerErrorReporter, ExponentialNoError {\r\n    /** liquidate seize calculation **/\r\n    function liquidateCalculateSeizeTokens(\r\n        address comptroller, \r\n        address vTokenBorrowed, \r\n        address vTokenCollateral, \r\n        uint actualRepayAmount\r\n    ) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = Comptroller(comptroller).oracle().getUnderlyingPrice(VToken(vTokenBorrowed));\r\n        uint priceCollateralMantissa = Comptroller(comptroller).oracle().getUnderlyingPrice(VToken(vTokenCollateral));\r\n        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n\r\n        numerator = mul_(Exp({mantissa: Comptroller(comptroller).liquidationIncentiveMantissa()}), Exp({mantissa: priceBorrowedMantissa}));\r\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\r\n        ratio = div_(numerator, denominator);\r\n\r\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n\r\n    function liquidateVAICalculateSeizeTokens(\r\n        address comptroller,\r\n        address vTokenCollateral, \r\n        uint actualRepayAmount\r\n    ) external view returns (uint, uint) {\r\n        /* Read oracle prices for borrowed and collateral markets */\r\n        uint priceBorrowedMantissa = 1e18;  // Note: this is VAI\r\n        uint priceCollateralMantissa = Comptroller(comptroller).oracle().getUnderlyingPrice(VToken(vTokenCollateral));\r\n        if (priceCollateralMantissa == 0) {\r\n            return (uint(Error.PRICE_ERROR), 0);\r\n        }\r\n\r\n        /*\r\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint exchangeRateMantissa = VToken(vTokenCollateral).exchangeRateStored(); // Note: reverts on error\r\n        uint seizeTokens;\r\n        Exp memory numerator;\r\n        Exp memory denominator;\r\n        Exp memory ratio;\r\n\r\n        numerator = mul_(Exp({mantissa: Comptroller(comptroller).liquidationIncentiveMantissa()}), Exp({mantissa: priceBorrowedMantissa}));\r\n        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\r\n        ratio = div_(numerator, denominator);\r\n\r\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n\r\n        return (uint(Error.NO_ERROR), seizeTokens);\r\n    }\r\n\r\n    /** liquidity calculation **/\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountLiquidityLocalVars {\r\n        uint sumCollateral;\r\n        uint sumBorrowPlusEffects;\r\n        uint vTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    function getHypotheticalAccountLiquidity(\r\n        address comptroller,\r\n        address account,\r\n        VToken vTokenModify,\r\n        uint redeemTokens,\r\n        uint borrowAmount) external view returns (uint, uint, uint) {\r\n\r\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n\r\n        // For each asset the account is in\r\n        VToken[] memory assets = Comptroller(comptroller).getAssetsIn(account);\r\n        uint assetsCount = assets.length;\r\n        for (uint i = 0; i < assetsCount; ++i) {\r\n            VToken asset = assets[i];\r\n\r\n            // Read the balances and exchange rate from the vToken\r\n            (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\r\n            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                return (uint(Error.SNAPSHOT_ERROR), 0, 0);\r\n            }\r\n            (, uint collateralFactorMantissa,) = Comptroller(comptroller).markets(address(asset));\r\n            vars.collateralFactor = Exp({mantissa: collateralFactorMantissa});\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            vars.oraclePriceMantissa = Comptroller(comptroller).oracle().getUnderlyingPrice(asset);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                return (uint(Error.PRICE_ERROR), 0, 0);\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\r\n            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\r\n\r\n            // sumCollateral += tokensToDenom * vTokenBalance\r\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.vTokenBalance, vars.sumCollateral);\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n\r\n            // Calculate effects of interacting with vTokenModify\r\n            if (asset == vTokenModify) {\r\n                // redeem effect\r\n                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\r\n\r\n                // borrow effect\r\n                // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\r\n            }\r\n        }\r\n\r\n        vars.sumBorrowPlusEffects = add_(vars.sumBorrowPlusEffects, Comptroller(comptroller).mintedVAIs(account));\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n            return (uint(Error.NO_ERROR), vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n        } else {\r\n            return (uint(Error.NO_ERROR), 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n"
    },
    "contracts/Lens/InterestRateModelLens.sol": {
      "content": "pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../InterestRateModel.sol\";\r\nimport \"../SafeMath.sol\";\r\n\r\ncontract InterestRateModelLens {\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    struct SimulationResponse {\r\n        uint256[] borrowSimulation;\r\n        uint256[] supplySimulation;\r\n    }\r\n\r\n    function getSimulationResponse(uint referenceAmountInWei, address interestRateModel, uint reserveFactorMantissa) external view returns (SimulationResponse memory){\r\n\r\n        InterestRateModel ir = InterestRateModel(interestRateModel);\r\n\r\n        uint256[] memory borrowSimulation = new uint256[](100);\r\n        uint256[] memory supplySimulation = new uint256[](100);\r\n\r\n        uint borrow = referenceAmountInWei;\r\n        uint reserves = 0;\r\n\r\n        for(uint percent_Factor = 1; percent_Factor <= 100; ++percent_Factor)\r\n        {\r\n            uint cash = (percent_Factor.mul(referenceAmountInWei)).div(1e2);\r\n            uint256 borrowRate = ir.getBorrowRate(cash, borrow, reserves);\r\n            borrowSimulation[percent_Factor-1] = borrowRate;\r\n\r\n            uint256 supplyRate = ir.getSupplyRate(cash, borrow, reserves, reserveFactorMantissa);\r\n            supplySimulation[percent_Factor-1] = supplyRate;\r\n        }\r\n\r\n        return SimulationResponse({\r\n            borrowSimulation: borrowSimulation,\r\n            supplySimulation: supplySimulation\r\n        });\r\n    }\r\n \r\n}"
    },
    "contracts/Lens/SnapshotLens.sol": {
      "content": "pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../VToken.sol\";\r\nimport \"../SafeMath.sol\";\r\nimport \"../Comptroller.sol\";\r\nimport \"../EIP20Interface.sol\";\r\nimport \"../VBep20.sol\";\r\n\r\ncontract SnapshotLens is ExponentialNoError {\r\n    using SafeMath for uint256;\r\n\r\n    struct AccountSnapshot {\r\n        address account;\r\n        string assetName;\r\n        address vTokenAddress;\r\n        address underlyingAssetAddress;\r\n        uint256 supply;\r\n        uint256 supplyInUsd;\r\n        uint256 collateral;\r\n        uint256 borrows;\r\n        uint256 borrowsInUsd;\r\n        uint256 assetPrice;\r\n        uint256 accruedInterest;\r\n        uint vTokenDecimals;\r\n        uint underlyingDecimals;\r\n        uint exchangeRate;\r\n        bool isACollateral;\r\n    }\r\n\r\n    /** Snapshot calculation **/\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account snapshot.\r\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountSnapshotLocalVars {\r\n        uint collateral;\r\n        uint vTokenBalance;\r\n        uint borrowBalance;\r\n        uint borrowsInUsd;\r\n        uint balanceOfUnderlying;\r\n        uint supplyInUsd;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp collateralFactor;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n        bool isACollateral;\r\n    }\r\n\r\n    function getAccountSnapshot(\r\n        address payable account,\r\n        address comptrollerAddress\r\n    )  public returns (AccountSnapshot[] memory) {\r\n\r\n        // For each asset the account is in\r\n        VToken[] memory assets = Comptroller(comptrollerAddress).getAllMarkets();\r\n        AccountSnapshot[] memory accountSnapshots = new AccountSnapshot[](assets.length);\r\n        for (uint256 i = 0; i < assets.length; ++i){\r\n            accountSnapshots[i] = getAccountSnapshot(account, comptrollerAddress, assets[i]);\r\n        }\r\n        return accountSnapshots;\r\n    }\r\n\r\n    function isACollateral(address account, address asset, address comptrollerAddress) public view returns (bool){\r\n        VToken[] memory assetsAsCollateral = Comptroller(comptrollerAddress).getAssetsIn(account);\r\n        for(uint256 j = 0; j < assetsAsCollateral.length ; ++j){\r\n            if(address(assetsAsCollateral[j]) == asset){\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function getAccountSnapshot(\r\n        address payable account,\r\n        address comptrollerAddress,\r\n        VToken vToken\r\n    ) public returns (AccountSnapshot memory) {\r\n\r\n        AccountSnapshotLocalVars memory vars; // Holds all our calculation results\r\n        uint oErr;\r\n\r\n        // Read the balances and exchange rate from the vToken\r\n        (oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = vToken.getAccountSnapshot(account);\r\n        require(oErr == 0, \"Snapshot Error\");\r\n        vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n        Comptroller comptrollerInstance = Comptroller(comptrollerAddress);\r\n\r\n        (, uint collateralFactorMantissa,) = comptrollerInstance.markets(address(vToken));\r\n        vars.collateralFactor = Exp({mantissa: collateralFactorMantissa});\r\n\r\n        // Get the normalized price of the asset\r\n        vars.oraclePriceMantissa = comptrollerInstance.oracle().getUnderlyingPrice(vToken);\r\n        vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n        // Pre-compute a conversion factor from tokens -> bnb (normalized price value)\r\n        vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\r\n\r\n        //Collateral = tokensToDenom * vTokenBalance\r\n        vars.collateral = mul_ScalarTruncate(vars.tokensToDenom, vars.vTokenBalance);\r\n\r\n        vars.balanceOfUnderlying = vToken.balanceOfUnderlying(account);\r\n        vars.supplyInUsd = mul_ScalarTruncate(vars.oraclePrice, vars.balanceOfUnderlying);\r\n\r\n        vars.borrowsInUsd = mul_ScalarTruncate(vars.oraclePrice, vars.borrowBalance);\r\n\r\n        address underlyingAssetAddress;\r\n        uint underlyingDecimals;\r\n\r\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\r\n            underlyingAssetAddress = address(0);\r\n            underlyingDecimals = 18;\r\n        } else {\r\n            VBep20 vBep20 = VBep20(address(vToken));\r\n            underlyingAssetAddress = vBep20.underlying();\r\n            underlyingDecimals = EIP20Interface(vBep20.underlying()).decimals();\r\n        }\r\n\r\n        vars.isACollateral = isACollateral(account, address(vToken), comptrollerAddress);\r\n\r\n        return AccountSnapshot({\r\n            account: account,\r\n            assetName: vToken.name(),\r\n            vTokenAddress: address(vToken),\r\n            underlyingAssetAddress: underlyingAssetAddress,\r\n            supply: vars.balanceOfUnderlying,\r\n            supplyInUsd: vars.supplyInUsd,\r\n            collateral: vars.collateral,\r\n            borrows: vars.borrowBalance,\r\n            borrowsInUsd: vars.borrowsInUsd,\r\n            assetPrice: vars.oraclePriceMantissa,\r\n            accruedInterest: vToken.borrowIndex(),\r\n            vTokenDecimals: vToken.decimals(),\r\n            underlyingDecimals: underlyingDecimals,\r\n            exchangeRate: vToken.exchangeRateCurrent(),\r\n            isACollateral: vars.isACollateral\r\n        });\r\n    }\r\n\r\n    // utilities\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n}\r\n"
    },
    "contracts/Lens/VenusLens.sol": {
      "content": "pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../VBep20.sol\";\r\nimport \"../VToken.sol\";\r\nimport \"../PriceOracle.sol\";\r\nimport \"../EIP20Interface.sol\";\r\nimport \"../Governance/GovernorAlpha.sol\";\r\nimport \"../Governance/XVS.sol\";\r\nimport \"../ComptrollerInterface.sol\";\r\nimport \"../SafeMath.sol\";\r\n\r\ncontract VenusLens is ExponentialNoError {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /// @notice Blocks Per Day\r\n    uint public constant BLOCKS_PER_DAY = 28800;\r\n\r\n    struct VenusMarketState {\r\n        uint224 index;\r\n        uint32 block;\r\n    }\r\n\r\n    struct VTokenMetadata {\r\n        address vToken;\r\n        uint exchangeRateCurrent;\r\n        uint supplyRatePerBlock;\r\n        uint borrowRatePerBlock;\r\n        uint reserveFactorMantissa;\r\n        uint totalBorrows;\r\n        uint totalReserves;\r\n        uint totalSupply;\r\n        uint totalCash;\r\n        bool isListed;\r\n        uint collateralFactorMantissa;\r\n        address underlyingAssetAddress;\r\n        uint vTokenDecimals;\r\n        uint underlyingDecimals;\r\n        uint venusSupplySpeed;\r\n        uint venusBorrowSpeed;\r\n        uint dailySupplyXvs;\r\n        uint dailyBorrowXvs;\r\n    }\r\n\r\n    function vTokenMetadata(VToken vToken) public returns (VTokenMetadata memory) {\r\n        uint exchangeRateCurrent = vToken.exchangeRateCurrent();\r\n        address comptrollerAddress = address(vToken.comptroller());\r\n        ComptrollerInterface comptroller = ComptrollerInterface(comptrollerAddress);\r\n        (bool isListed, uint collateralFactorMantissa) = comptroller.markets(address(vToken));\r\n        address underlyingAssetAddress;\r\n        uint underlyingDecimals;\r\n\r\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\r\n            underlyingAssetAddress = address(0);\r\n            underlyingDecimals = 18;\r\n        } else {\r\n            VBep20 vBep20 = VBep20(address(vToken));\r\n            underlyingAssetAddress = vBep20.underlying();\r\n            underlyingDecimals = EIP20Interface(vBep20.underlying()).decimals();\r\n        }\r\n\r\n        uint venusSpeedPerBlock = comptroller.venusSpeeds(address(vToken));\r\n\r\n        return VTokenMetadata({\r\n            vToken: address(vToken),\r\n            exchangeRateCurrent: exchangeRateCurrent,\r\n            supplyRatePerBlock: vToken.supplyRatePerBlock(),\r\n            borrowRatePerBlock: vToken.borrowRatePerBlock(),\r\n            reserveFactorMantissa: vToken.reserveFactorMantissa(),\r\n            totalBorrows: vToken.totalBorrows(),\r\n            totalReserves: vToken.totalReserves(),\r\n            totalSupply: vToken.totalSupply(),\r\n            totalCash: vToken.getCash(),\r\n            isListed: isListed,\r\n            collateralFactorMantissa: collateralFactorMantissa,\r\n            underlyingAssetAddress: underlyingAssetAddress,\r\n            vTokenDecimals: vToken.decimals(),\r\n            underlyingDecimals: underlyingDecimals,\r\n            venusSupplySpeed: venusSpeedPerBlock,\r\n            venusBorrowSpeed: venusSpeedPerBlock,\r\n            dailySupplyXvs: venusSpeedPerBlock.mul(BLOCKS_PER_DAY),\r\n            dailyBorrowXvs: venusSpeedPerBlock.mul(BLOCKS_PER_DAY)\r\n        });\r\n    }\r\n\r\n    function vTokenMetadataAll(VToken[] calldata vTokens) external returns (VTokenMetadata[] memory) {\r\n        uint vTokenCount = vTokens.length;\r\n        VTokenMetadata[] memory res = new VTokenMetadata[](vTokenCount);\r\n        for (uint i = 0; i < vTokenCount; i++) {\r\n            res[i] = vTokenMetadata(vTokens[i]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function getDailyXVS(address payable account, address comptrollerAddress) external returns (uint) {\r\n        ComptrollerInterface comptrollerInstance = ComptrollerInterface(comptrollerAddress);\r\n        VToken[] memory vTokens = comptrollerInstance.getAllMarkets();\r\n        uint dailyXvsPerAccount = 0;\r\n        \r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            VToken vToken = vTokens[i];\r\n            if (!compareStrings(vToken.symbol(), \"vUST\") && !compareStrings(vToken.symbol(), \"vLUNA\")) {\r\n\r\n                VTokenMetadata memory metaDataItem = vTokenMetadata(vToken);\r\n\r\n                //get balanceOfUnderlying and borrowBalanceCurrent from vTokenBalance\r\n                VTokenBalances memory vTokenBalanceInfo = vTokenBalances(vToken, account);\r\n\r\n                VTokenUnderlyingPrice memory underlyingPriceResponse = vTokenUnderlyingPrice(vToken);\r\n                uint underlyingPrice = underlyingPriceResponse.underlyingPrice;\r\n                Exp memory underlyingPriceMantissa = Exp({mantissa: underlyingPrice});\r\n\r\n                //get dailyXvsSupplyMarket\r\n                uint dailyXvsSupplyMarket = 0;\r\n                uint supplyInUsd = mul_ScalarTruncate(underlyingPriceMantissa, vTokenBalanceInfo.balanceOfUnderlying);\r\n                uint marketTotalSupply = (metaDataItem.totalSupply.mul(metaDataItem.exchangeRateCurrent)).div(1e18);\r\n                uint marketTotalSupplyInUsd = mul_ScalarTruncate(underlyingPriceMantissa, marketTotalSupply);\r\n\r\n                if(marketTotalSupplyInUsd > 0) {\r\n                    dailyXvsSupplyMarket = (metaDataItem.dailySupplyXvs.mul(supplyInUsd)).div(marketTotalSupplyInUsd);\r\n                }\r\n\r\n                //get dailyXvsBorrowMarket\r\n                uint dailyXvsBorrowMarket = 0;\r\n                uint borrowsInUsd = mul_ScalarTruncate(underlyingPriceMantissa, vTokenBalanceInfo.borrowBalanceCurrent);\r\n                uint marketTotalBorrowsInUsd = mul_ScalarTruncate(underlyingPriceMantissa, metaDataItem.totalBorrows);\r\n\r\n                if(marketTotalBorrowsInUsd > 0){\r\n                    dailyXvsBorrowMarket = (metaDataItem.dailyBorrowXvs.mul(borrowsInUsd)).div(marketTotalBorrowsInUsd);\r\n                }\r\n\r\n                dailyXvsPerAccount += dailyXvsSupplyMarket + dailyXvsBorrowMarket;\r\n            }\r\n        }\r\n\r\n        return dailyXvsPerAccount;\r\n    }\r\n\r\n    struct VTokenBalances {\r\n        address vToken;\r\n        uint balanceOf;\r\n        uint borrowBalanceCurrent;\r\n        uint balanceOfUnderlying;\r\n        uint tokenBalance;\r\n        uint tokenAllowance;\r\n    }\r\n\r\n    function vTokenBalances(VToken vToken, address payable account) public returns (VTokenBalances memory) {\r\n        uint balanceOf = vToken.balanceOf(account);\r\n        uint borrowBalanceCurrent = vToken.borrowBalanceCurrent(account);\r\n        uint balanceOfUnderlying = vToken.balanceOfUnderlying(account);\r\n        uint tokenBalance;\r\n        uint tokenAllowance;\r\n\r\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\r\n            tokenBalance = account.balance;\r\n            tokenAllowance = account.balance;\r\n        } else {\r\n            VBep20 vBep20 = VBep20(address(vToken));\r\n            EIP20Interface underlying = EIP20Interface(vBep20.underlying());\r\n            tokenBalance = underlying.balanceOf(account);\r\n            tokenAllowance = underlying.allowance(account, address(vToken));\r\n        }\r\n\r\n        return VTokenBalances({\r\n            vToken: address(vToken),\r\n            balanceOf: balanceOf,\r\n            borrowBalanceCurrent: borrowBalanceCurrent,\r\n            balanceOfUnderlying: balanceOfUnderlying,\r\n            tokenBalance: tokenBalance,\r\n            tokenAllowance: tokenAllowance\r\n        });\r\n    }\r\n\r\n    function vTokenBalancesAll(VToken[] calldata vTokens, address payable account) external returns (VTokenBalances[] memory) {\r\n        uint vTokenCount = vTokens.length;\r\n        VTokenBalances[] memory res = new VTokenBalances[](vTokenCount);\r\n        for (uint i = 0; i < vTokenCount; i++) {\r\n            res[i] = vTokenBalances(vTokens[i], account);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct VTokenUnderlyingPrice {\r\n        address vToken;\r\n        uint underlyingPrice;\r\n    }\r\n\r\n    function vTokenUnderlyingPrice(VToken vToken) public view returns (VTokenUnderlyingPrice memory) {\r\n        ComptrollerInterface comptroller = ComptrollerInterface(address(vToken.comptroller()));\r\n        PriceOracle priceOracle = comptroller.oracle();\r\n\r\n        return VTokenUnderlyingPrice({\r\n            vToken: address(vToken),\r\n            underlyingPrice: priceOracle.getUnderlyingPrice(vToken)\r\n        });\r\n    }\r\n\r\n    function vTokenUnderlyingPriceAll(VToken[] calldata vTokens) external view returns (VTokenUnderlyingPrice[] memory) {\r\n        uint vTokenCount = vTokens.length;\r\n        VTokenUnderlyingPrice[] memory res = new VTokenUnderlyingPrice[](vTokenCount);\r\n        for (uint i = 0; i < vTokenCount; i++) {\r\n            res[i] = vTokenUnderlyingPrice(vTokens[i]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct AccountLimits {\r\n        VToken[] markets;\r\n        uint liquidity;\r\n        uint shortfall;\r\n    }\r\n\r\n    function getAccountLimits(ComptrollerInterface comptroller, address account) public view returns (AccountLimits memory) {\r\n        (uint errorCode, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(account);\r\n        require(errorCode == 0, \"account liquidity error\");\r\n\r\n        return AccountLimits({\r\n            markets: comptroller.getAssetsIn(account),\r\n            liquidity: liquidity,\r\n            shortfall: shortfall\r\n        });\r\n    }\r\n\r\n    struct GovReceipt {\r\n        uint proposalId;\r\n        bool hasVoted;\r\n        bool support;\r\n        uint96 votes;\r\n    }\r\n\r\n    function getGovReceipts(GovernorAlpha governor, address voter, uint[] memory proposalIds) public view returns (GovReceipt[] memory) {\r\n        uint proposalCount = proposalIds.length;\r\n        GovReceipt[] memory res = new GovReceipt[](proposalCount);\r\n        for (uint i = 0; i < proposalCount; i++) {\r\n            GovernorAlpha.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\r\n            res[i] = GovReceipt({\r\n                proposalId: proposalIds[i],\r\n                hasVoted: receipt.hasVoted,\r\n                support: receipt.support,\r\n                votes: receipt.votes\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct GovProposal {\r\n        uint proposalId;\r\n        address proposer;\r\n        uint eta;\r\n        address[] targets;\r\n        uint[] values;\r\n        string[] signatures;\r\n        bytes[] calldatas;\r\n        uint startBlock;\r\n        uint endBlock;\r\n        uint forVotes;\r\n        uint againstVotes;\r\n        bool canceled;\r\n        bool executed;\r\n    }\r\n\r\n    function setProposal(GovProposal memory res, GovernorAlpha governor, uint proposalId) internal view {\r\n        (\r\n            ,\r\n            address proposer,\r\n            uint eta,\r\n            uint startBlock,\r\n            uint endBlock,\r\n            uint forVotes,\r\n            uint againstVotes,\r\n            bool canceled,\r\n            bool executed\r\n        ) = governor.proposals(proposalId);\r\n        res.proposalId = proposalId;\r\n        res.proposer = proposer;\r\n        res.eta = eta;\r\n        res.startBlock = startBlock;\r\n        res.endBlock = endBlock;\r\n        res.forVotes = forVotes;\r\n        res.againstVotes = againstVotes;\r\n        res.canceled = canceled;\r\n        res.executed = executed;\r\n    }\r\n\r\n    function getGovProposals(GovernorAlpha governor, uint[] calldata proposalIds) external view returns (GovProposal[] memory) {\r\n        GovProposal[] memory res = new GovProposal[](proposalIds.length);\r\n        for (uint i = 0; i < proposalIds.length; i++) {\r\n            (\r\n                address[] memory targets,\r\n                uint[] memory values,\r\n                string[] memory signatures,\r\n                bytes[] memory calldatas\r\n            ) = governor.getActions(proposalIds[i]);\r\n            res[i] = GovProposal({\r\n                proposalId: 0,\r\n                proposer: address(0),\r\n                eta: 0,\r\n                targets: targets,\r\n                values: values,\r\n                signatures: signatures,\r\n                calldatas: calldatas,\r\n                startBlock: 0,\r\n                endBlock: 0,\r\n                forVotes: 0,\r\n                againstVotes: 0,\r\n                canceled: false,\r\n                executed: false\r\n            });\r\n            setProposal(res[i], governor, proposalIds[i]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    struct XVSBalanceMetadata {\r\n        uint balance;\r\n        uint votes;\r\n        address delegate;\r\n    }\r\n\r\n    function getXVSBalanceMetadata(XVS xvs, address account) external view returns (XVSBalanceMetadata memory) {\r\n        return XVSBalanceMetadata({\r\n            balance: xvs.balanceOf(account),\r\n            votes: uint256(xvs.getCurrentVotes(account)),\r\n            delegate: xvs.delegates(account)\r\n        });\r\n    }\r\n\r\n    struct XVSBalanceMetadataExt {\r\n        uint balance;\r\n        uint votes;\r\n        address delegate;\r\n        uint allocated;\r\n    }\r\n\r\n    function getXVSBalanceMetadataExt(XVS xvs, ComptrollerInterface comptroller, address account) external returns (XVSBalanceMetadataExt memory) {\r\n        uint balance = xvs.balanceOf(account);\r\n        comptroller.claimVenus(account);\r\n        uint newBalance = xvs.balanceOf(account);\r\n        uint accrued = comptroller.venusAccrued(account);\r\n        uint total = add_(accrued, newBalance, \"sum xvs total\");\r\n        uint allocated = sub_(total, balance, \"sub allocated\");\r\n\r\n        return XVSBalanceMetadataExt({\r\n            balance: balance,\r\n            votes: uint256(xvs.getCurrentVotes(account)),\r\n            delegate: xvs.delegates(account),\r\n            allocated: allocated\r\n        });\r\n    }\r\n\r\n    struct VenusVotes {\r\n        uint blockNumber;\r\n        uint votes;\r\n    }\r\n\r\n    function getVenusVotes(XVS xvs, address account, uint32[] calldata blockNumbers) external view returns (VenusVotes[] memory) {\r\n        VenusVotes[] memory res = new VenusVotes[](blockNumbers.length);\r\n        for (uint i = 0; i < blockNumbers.length; i++) {\r\n            res[i] = VenusVotes({\r\n                blockNumber: uint256(blockNumbers[i]),\r\n                votes: uint256(xvs.getPriorVotes(account, blockNumbers[i]))\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // calculate the accurate pending Venus rewards without touching any storage\r\n    function updateVenusSupplyIndex(VenusMarketState memory supplyState, address vToken, ComptrollerInterface comptroller) internal view {\r\n        uint supplySpeed = comptroller.venusSpeeds(vToken);\r\n        uint blockNumber = block.number;\r\n        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\r\n        if (deltaBlocks > 0 && supplySpeed > 0) {\r\n            uint supplyTokens = VToken(vToken).totalSupply();\r\n            uint venusAccrued = mul_(deltaBlocks, supplySpeed);\r\n            Double memory ratio = supplyTokens > 0 ? fraction(venusAccrued, supplyTokens) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\r\n            supplyState.index = safe224(index.mantissa, \"new index overflows\");\r\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\r\n        } else if (deltaBlocks > 0) {\r\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    function updateVenusBorrowIndex(VenusMarketState memory borrowState, address vToken, Exp memory marketBorrowIndex, ComptrollerInterface comptroller) internal view {\r\n        uint borrowSpeed = comptroller.venusSpeeds(vToken);\r\n        uint blockNumber = block.number;\r\n        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\r\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\r\n            uint borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\r\n            uint venusAccrued = mul_(deltaBlocks, borrowSpeed);\r\n            Double memory ratio = borrowAmount > 0 ? fraction(venusAccrued, borrowAmount) : Double({mantissa: 0});\r\n            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\r\n            borrowState.index = safe224(index.mantissa, \"new index overflows\");\r\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\r\n        } else if (deltaBlocks > 0) {\r\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\r\n        }\r\n    }\r\n\r\n    function distributeSupplierVenus(\r\n        VenusMarketState memory supplyState, \r\n        address vToken, \r\n        address supplier, \r\n        ComptrollerInterface comptroller\r\n    ) internal view returns (uint) {\r\n        Double memory supplyIndex = Double({mantissa: supplyState.index});\r\n        Double memory supplierIndex = Double({mantissa: comptroller.venusSupplierIndex(vToken, supplier)});\r\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\r\n            supplierIndex.mantissa = comptroller.venusInitialIndex();\r\n        }\r\n        \r\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\r\n        uint supplierTokens = VToken(vToken).balanceOf(supplier);\r\n        uint supplierDelta = mul_(supplierTokens, deltaIndex);\r\n        return supplierDelta;\r\n    }\r\n\r\n    function distributeBorrowerVenus(\r\n        VenusMarketState memory borrowState, \r\n        address vToken, \r\n        address borrower, \r\n        Exp memory marketBorrowIndex, \r\n        ComptrollerInterface comptroller\r\n    ) internal view returns (uint) {\r\n        Double memory borrowIndex = Double({mantissa: borrowState.index});\r\n        Double memory borrowerIndex = Double({mantissa: comptroller.venusBorrowerIndex(vToken, borrower)});\r\n        if (borrowerIndex.mantissa > 0) {\r\n            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\r\n            uint borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\r\n            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\r\n            return borrowerDelta;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    struct ClaimVenusLocalVariables {\r\n        uint totalRewards;\r\n        uint224 borrowIndex;\r\n        uint32 borrowBlock;\r\n        uint224 supplyIndex;\r\n        uint32 supplyBlock;\r\n    }\r\n\r\n    function pendingVenus(address holder, ComptrollerInterface comptroller) external view returns (uint) {\r\n        VToken[] memory vTokens = comptroller.getAllMarkets();\r\n        ClaimVenusLocalVariables memory vars;\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            (vars.borrowIndex, vars.borrowBlock) = comptroller.venusBorrowState(address(vTokens[i]));\r\n            VenusMarketState memory borrowState = VenusMarketState({\r\n                index: vars.borrowIndex,\r\n                block: vars.borrowBlock\r\n            });\r\n\r\n            (vars.supplyIndex, vars.supplyBlock) = comptroller.venusSupplyState(address(vTokens[i]));\r\n            VenusMarketState memory supplyState = VenusMarketState({\r\n                index: vars.supplyIndex,\r\n                block: vars.supplyBlock\r\n            });\r\n\r\n            Exp memory borrowIndex = Exp({mantissa: vTokens[i].borrowIndex()});\r\n            updateVenusBorrowIndex(borrowState, address(vTokens[i]), borrowIndex, comptroller);\r\n            uint reward = distributeBorrowerVenus(borrowState, address(vTokens[i]), holder, borrowIndex, comptroller);\r\n            vars.totalRewards = add_(vars.totalRewards, reward);\r\n\r\n            updateVenusSupplyIndex(supplyState, address(vTokens[i]), comptroller);\r\n            reward = distributeSupplierVenus(supplyState, address(vTokens[i]), holder, comptroller);\r\n            vars.totalRewards = add_(vars.totalRewards, reward);\r\n        }\r\n        return add_(comptroller.venusAccrued(holder), vars.totalRewards);\r\n    }\r\n\r\n    // utilities\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n}"
    },
    "contracts/Liquidator.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./VAIControllerInterface.sol\";\r\nimport \"./VBNB.sol\";\r\nimport \"./VBep20.sol\";\r\nimport \"./Utils/ReentrancyGuard.sol\";\r\nimport \"./Utils/WithAdmin.sol\";\r\nimport \"./Utils/SafeMath.sol\";\r\nimport \"./Utils/IBEP20.sol\";\r\nimport \"./Utils/SafeBEP20.sol\";\r\n\r\ncontract Liquidator is WithAdmin, ReentrancyGuard {\r\n\r\n    /// @notice Address of vBNB contract.\r\n    VBNB public vBnb;\r\n\r\n    /// @notice Address of Venus Unitroller contract.\r\n    IComptroller comptroller;\r\n\r\n    /// @notice Address of VAIUnitroller contract.\r\n    VAIControllerInterface vaiController;\r\n\r\n    /// @notice Address of Venus Treasury.\r\n    address public treasury;\r\n\r\n    /// @notice Percent of seized amount that goes to treasury.\r\n    uint256 public treasuryPercentMantissa;\r\n\r\n    /// @notice Emitted when once changes the percent of the seized amount\r\n    ///         that goes to treasury.\r\n    event NewLiquidationTreasuryPercent(uint256 oldPercent, uint256 newPercent);\r\n\r\n    /// @notice Event emitted when a borrow is liquidated\r\n    event LiquidateBorrowedTokens(address liquidator, address borrower, uint256 repayAmount, address vTokenCollateral, uint256 seizeTokensForTreasury, uint256 seizeTokensForLiquidator);\r\n\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    constructor(\r\n        address admin_,\r\n        address payable vBnb_,\r\n        address comptroller_,\r\n        address vaiController_,\r\n        address treasury_,\r\n        uint256 treasuryPercentMantissa_\r\n    )\r\n        public\r\n        WithAdmin(admin_)\r\n        ReentrancyGuard()\r\n    {\r\n        ensureNonzeroAddress(admin_);\r\n        ensureNonzeroAddress(vBnb_);\r\n        ensureNonzeroAddress(comptroller_);\r\n        ensureNonzeroAddress(vaiController_);\r\n        ensureNonzeroAddress(treasury_);\r\n        vBnb = VBNB(vBnb_);\r\n        comptroller = IComptroller(comptroller_);\r\n        vaiController = VAIControllerInterface(vaiController_);\r\n        treasury = treasury_;\r\n        treasuryPercentMantissa = treasuryPercentMantissa_;\r\n    }\r\n\r\n    /// @notice Liquidates a borrow and splits the seized amount between treasury and\r\n    ///         liquidator. The liquidators should use this interface instead of calling\r\n    ///         vToken.liquidateBorrow(...) directly.\r\n    /// @dev For BNB borrows msg.value should be equal to repayAmount; otherwise msg.value\r\n    ///      should be zero.\r\n    /// @param vToken Borrowed vToken\r\n    /// @param borrower The address of the borrower\r\n    /// @param repayAmount The amount to repay on behalf of the borrower\r\n    /// @param vTokenCollateral The collateral to seize\r\n    function liquidateBorrow(\r\n        address vToken,\r\n        address borrower,\r\n        uint256 repayAmount,\r\n        VToken vTokenCollateral\r\n    )\r\n        external\r\n        payable\r\n        nonReentrant\r\n    {\r\n        ensureNonzeroAddress(borrower);\r\n        uint256 ourBalanceBefore = vTokenCollateral.balanceOf(address(this));\r\n        if (vToken == address(vBnb)) {\r\n            require(repayAmount == msg.value, \"wrong amount\");\r\n            vBnb.liquidateBorrow.value(msg.value)(borrower, vTokenCollateral);\r\n        } else {\r\n            require(msg.value == 0, \"you shouldn't pay for this\");\r\n            if (vToken == address(vaiController)) {\r\n                _liquidateVAI(borrower, repayAmount, vTokenCollateral);\r\n            } else {\r\n                _liquidateBep20(VBep20(vToken), borrower, repayAmount, vTokenCollateral);\r\n            }\r\n        }\r\n        uint256 ourBalanceAfter = vTokenCollateral.balanceOf(address(this));\r\n        uint256 seizedAmount = ourBalanceAfter.sub(ourBalanceBefore);\r\n        (uint256 ours, uint256 theirs) = _distributeLiquidationIncentive(vTokenCollateral, seizedAmount);\r\n        emit LiquidateBorrowedTokens(msg.sender, borrower, repayAmount, address(vTokenCollateral), ours, theirs);\r\n    }\r\n\r\n    /// @notice Sets the new percent of the seized amount that goes to treasury. Should\r\n    ///         be less than or equal to comptroller.liquidationIncentiveMantissa().sub(1e18).\r\n    /// @param newTreasuryPercentMantissa New treasury percent (scaled by 10^18).\r\n    function setTreasuryPercent(uint256 newTreasuryPercentMantissa) external onlyAdmin {\r\n        require(\r\n            newTreasuryPercentMantissa <= comptroller.liquidationIncentiveMantissa().sub(1e18),\r\n            \"appetite too big\"\r\n        );\r\n        emit NewLiquidationTreasuryPercent(treasuryPercentMantissa, newTreasuryPercentMantissa);\r\n        treasuryPercentMantissa = newTreasuryPercentMantissa;\r\n    }\r\n\r\n    /// @dev Transfers BEP20 tokens to self, then approves vToken to take these tokens.\r\n    function _liquidateBep20(\r\n        VBep20 vToken,\r\n        address borrower,\r\n        uint256 repayAmount,\r\n        VToken vTokenCollateral\r\n    )\r\n        internal\r\n    {\r\n        IBEP20 borrowedToken = IBEP20(vToken.underlying());\r\n        uint256 actualRepayAmount = _transferBep20(borrowedToken, msg.sender, address(this), repayAmount);\r\n        borrowedToken.safeApprove(address(vToken), 0);\r\n        borrowedToken.safeApprove(address(vToken), actualRepayAmount);\r\n        requireNoError(\r\n            vToken.liquidateBorrow(borrower, actualRepayAmount, vTokenCollateral),\r\n            \"failed to liquidate\"\r\n        );\r\n    }\r\n\r\n    /// @dev Transfers BEP20 tokens to self, then approves vai to take these tokens.\r\n    function _liquidateVAI(address borrower, uint256 repayAmount, VToken vTokenCollateral)\r\n        internal\r\n    {\r\n        IBEP20 vai = IBEP20(vaiController.getVAIAddress());\r\n        vai.safeTransferFrom(msg.sender, address(this), repayAmount);\r\n        vai.safeApprove(address(vaiController), repayAmount);\r\n\r\n        (uint err,) = vaiController.liquidateVAI(borrower, repayAmount, vTokenCollateral);\r\n        requireNoError(err, \"failed to liquidate\");\r\n    }\r\n\r\n    /// @dev Splits the received vTokens between the liquidator and treasury.\r\n    function _distributeLiquidationIncentive(VToken vTokenCollateral, uint256 siezedAmount)\r\n        internal returns (uint256 ours, uint256 theirs)\r\n    {\r\n        (ours, theirs) = _splitLiquidationIncentive(siezedAmount);\r\n        require(\r\n            vTokenCollateral.transfer(msg.sender, theirs),\r\n            \"failed to transfer to liquidator\"\r\n        );\r\n        require(\r\n            vTokenCollateral.transfer(treasury, ours),\r\n            \"failed to transfer to treasury\"\r\n        );\r\n        return (ours, theirs);\r\n    }\r\n\r\n    /// @dev Transfers tokens and returns the actual transfer amount\r\n    function _transferBep20(IBEP20 token, address from, address to, uint256 amount)\r\n        internal\r\n        returns (uint256 actualAmount)\r\n    {\r\n        uint256 prevBalance = token.balanceOf(to);\r\n        token.safeTransferFrom(from, to, amount);\r\n        return token.balanceOf(to).sub(prevBalance);\r\n    }\r\n\r\n    /// @dev Computes the amounts that would go to treasury and to the liquidator.\r\n    function _splitLiquidationIncentive(uint256 seizedAmount)\r\n        internal\r\n        view\r\n        returns (uint256 ours, uint256 theirs)\r\n    {\r\n        uint256 totalIncentive = comptroller.liquidationIncentiveMantissa();\r\n        uint256 seizedForRepayment = seizedAmount.mul(1e18).div(totalIncentive);\r\n        ours = seizedForRepayment.mul(treasuryPercentMantissa).div(1e18);\r\n        theirs = seizedAmount.sub(ours);\r\n        return (ours, theirs);\r\n    }\r\n\r\n    function requireNoError(uint errCode, string memory message) internal pure {\r\n        if (errCode == uint(0)) {\r\n            return;\r\n        }\r\n\r\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\r\n        uint i;\r\n\r\n        for (i = 0; i < bytes(message).length; i++) {\r\n            fullMessage[i] = bytes(message)[i];\r\n        }\r\n\r\n        fullMessage[i+0] = byte(uint8(32));\r\n        fullMessage[i+1] = byte(uint8(40));\r\n        fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));\r\n        fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));\r\n        fullMessage[i+4] = byte(uint8(41));\r\n\r\n        revert(string(fullMessage));\r\n    }\r\n\r\n    function ensureNonzeroAddress(address addr) internal pure {\r\n        require(addr != address(0), \"address should be nonzero\");\r\n    }\r\n}\r\n"
    },
    "contracts/Maximillion.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VBNB.sol\";\r\n\r\n/**\r\n * @title Venus's Maximillion Contract\r\n * @author Venus\r\n */\r\ncontract Maximillion {\r\n    /**\r\n     * @notice The default vBnb market to repay in\r\n     */\r\n    VBNB public vBnb;\r\n\r\n    /**\r\n     * @notice Construct a Maximillion to repay max in a VBNB market\r\n     */\r\n    constructor(VBNB vBnb_) public {\r\n        vBnb = vBnb_;\r\n    }\r\n\r\n    /**\r\n     * @notice msg.sender sends BNB to repay an account's borrow in the vBnb market\r\n     * @dev The provided BNB is applied towards the borrow balance, any excess is refunded\r\n     * @param borrower The address of the borrower account to repay on behalf of\r\n     */\r\n    function repayBehalf(address borrower) public payable {\r\n        repayBehalfExplicit(borrower, vBnb);\r\n    }\r\n\r\n    /**\r\n     * @notice msg.sender sends BNB to repay an account's borrow in a vBnb market\r\n     * @dev The provided BNB is applied towards the borrow balance, any excess is refunded\r\n     * @param borrower The address of the borrower account to repay on behalf of\r\n     * @param vBnb_ The address of the vBnb contract to repay in\r\n     */\r\n    function repayBehalfExplicit(address borrower, VBNB vBnb_) public payable {\r\n        uint received = msg.value;\r\n        uint borrows = vBnb_.borrowBalanceCurrent(borrower);\r\n        if (received > borrows) {\r\n            vBnb_.repayBorrowBehalf.value(borrows)(borrower);\r\n            msg.sender.transfer(received - borrows);\r\n        } else {\r\n            vBnb_.repayBorrowBehalf.value(received)(borrower);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Ownable.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor () internal {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n"
    },
    "contracts/PriceOracle.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\n\r\ncontract PriceOracle {\r\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\r\n    bool public constant isPriceOracle = true;\r\n\r\n    /**\r\n      * @notice Get the underlying price of a vToken asset\r\n      * @param vToken The vToken to get the underlying price of\r\n      * @return The underlying asset price mantissa (scaled by 1e18).\r\n      *  Zero means the price is unavailable.\r\n      */\r\n    function getUnderlyingPrice(VToken vToken) external view returns (uint);\r\n}\r\n"
    },
    "contracts/PriceOracleProxy.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VBep20.sol\";\r\nimport \"./VToken.sol\";\r\nimport \"./PriceOracle.sol\";\r\n\r\ninterface V1PriceOracleInterface {\r\n    function assetPrices(address asset) external view returns (uint);\r\n}\r\n\r\ncontract PriceOracleProxy is PriceOracle {\r\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\r\n    bool public constant isPriceOracle = true;\r\n\r\n    /// @notice The v1 price oracle, which will continue to serve prices for v1 assets\r\n    V1PriceOracleInterface public v1PriceOracle;\r\n\r\n    /// @notice Address of the guardian, which may set the SAI price once\r\n    address public guardian;\r\n\r\n    /// @notice Address of the vBnb contract, which has a constant price\r\n    address public vBnbAddress;\r\n\r\n    /// @notice Address of the vUSDC contract, which we hand pick a key for\r\n    address public vUsdcAddress;\r\n\r\n    /// @notice Address of the vUSDT contract, which uses the vUSDC price\r\n    address public vUsdtAddress;\r\n\r\n    /// @notice Address of the vSAI contract, which may have its price set\r\n    address public vSaiAddress;\r\n\r\n    /// @notice Address of the vDAI contract, which we hand pick a key for\r\n    address public vDaiAddress;\r\n\r\n    /// @notice Handpicked key for USDC\r\n    address public constant usdcOracleKey = address(1);\r\n\r\n    /// @notice Handpicked key for DAI\r\n    address public constant daiOracleKey = address(2);\r\n\r\n    /// @notice Frozen SAI price (or 0 if not set yet)\r\n    uint public saiPrice;\r\n\r\n    /**\r\n     * @param guardian_ The address of the guardian, which may set the SAI price once\r\n     * @param v1PriceOracle_ The address of the v1 price oracle, which will continue to operate and hold prices for collateral assets\r\n     * @param vBnbAddress_ The address of vBNB, which will return a constant 1e18, since all prices relative to bnb\r\n     * @param vUsdcAddress_ The address of vUSDC, which will be read from a special oracle key\r\n     * @param vSaiAddress_ The address of vSAI, which may be read directly from storage\r\n     * @param vDaiAddress_ The address of vDAI, which will be read from a special oracle key\r\n     * @param vUsdtAddress_ The address of vUSDT, which uses the vUSDC price\r\n     */\r\n    constructor(address guardian_,\r\n                address v1PriceOracle_,\r\n                address vBnbAddress_,\r\n                address vUsdcAddress_,\r\n                address vSaiAddress_,\r\n                address vDaiAddress_,\r\n                address vUsdtAddress_) public {\r\n        guardian = guardian_;\r\n        v1PriceOracle = V1PriceOracleInterface(v1PriceOracle_);\r\n\r\n        vBnbAddress = vBnbAddress_;\r\n        vUsdcAddress = vUsdcAddress_;\r\n        vSaiAddress = vSaiAddress_;\r\n        vDaiAddress = vDaiAddress_;\r\n        vUsdtAddress = vUsdtAddress_;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying price of a listed vToken asset\r\n     * @param vToken The vToken to get the underlying price of\r\n     * @return The underlying asset price mantissa (scaled by 1e18)\r\n     */\r\n    function getUnderlyingPrice(VToken vToken) public view returns (uint) {\r\n        address vTokenAddress = address(vToken);\r\n\r\n        if (vTokenAddress == vBnbAddress) {\r\n            // bnb always worth 1\r\n            return 1e18;\r\n        }\r\n\r\n        if (vTokenAddress == vUsdcAddress || vTokenAddress == vUsdtAddress) {\r\n            return v1PriceOracle.assetPrices(usdcOracleKey);\r\n        }\r\n\r\n        if (vTokenAddress == vDaiAddress) {\r\n            return v1PriceOracle.assetPrices(daiOracleKey);\r\n        }\r\n\r\n        if (vTokenAddress == vSaiAddress) {\r\n            // use the frozen SAI price if set, otherwise use the DAI price\r\n            return saiPrice > 0 ? saiPrice : v1PriceOracle.assetPrices(daiOracleKey);\r\n        }\r\n\r\n        // otherwise just read from v1 oracle\r\n        address underlying = VBep20(vTokenAddress).underlying();\r\n        return v1PriceOracle.assetPrices(underlying);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the price of SAI, permanently\r\n     * @param price The price for SAI\r\n     */\r\n    function setSaiPrice(uint price) public {\r\n        require(msg.sender == guardian, \"only guardian may set the SAI price\");\r\n        require(saiPrice == 0, \"SAI price may only be set once\");\r\n        require(price < 0.1e18, \"SAI price must be < 0.1 BNB\");\r\n        saiPrice = price;\r\n    }\r\n}\r\n"
    },
    "contracts/Reservoir.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @title Reservoir Contract\r\n * @notice Distributes a token to a different contract at a fixed rate.\r\n * @dev This contract must be poked via the `drip()` function every so often.\r\n * @author Venus\r\n */\r\ncontract Reservoir {\r\n\r\n  /// @notice The block number when the Reservoir started (immutable)\r\n  uint public dripStart;\r\n\r\n  /// @notice Tokens per block that to drip to target (immutable)\r\n  uint public dripRate;\r\n\r\n  /// @notice Reference to token to drip (immutable)\r\n  EIP20Interface public token;\r\n\r\n  /// @notice Target to receive dripped tokens (immutable)\r\n  address public target;\r\n\r\n  /// @notice Amount that has already been dripped\r\n  uint public dripped;\r\n\r\n  /**\r\n    * @notice Constructs a Reservoir\r\n    * @param dripRate_ Numer of tokens per block to drip\r\n    * @param token_ The token to drip\r\n    * @param target_ The recipient of dripped tokens\r\n    */\r\n  constructor(uint dripRate_, EIP20Interface token_, address target_) public {\r\n    dripStart = block.number;\r\n    dripRate = dripRate_;\r\n    token = token_;\r\n    target = target_;\r\n    dripped = 0;\r\n  }\r\n\r\n  /**\r\n    * @notice Drips the maximum amount of tokens to match the drip rate since inception\r\n    * @dev Note: this will only drip up to the amount of tokens available.\r\n    * @return The amount of tokens dripped in this call\r\n    */\r\n  function drip() public returns (uint) {\r\n    // First, read storage into memory\r\n    EIP20Interface token_ = token;\r\n    uint reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call\r\n    uint dripRate_ = dripRate;\r\n    uint dripStart_ = dripStart;\r\n    uint dripped_ = dripped;\r\n    address target_ = target;\r\n    uint blockNumber_ = block.number;\r\n\r\n    // Next, calculate intermediate values\r\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"dripTotal overflow\");\r\n    uint deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\r\n    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\r\n    uint drippedNext_ = add(dripped_, toDrip_, \"tautological\");\r\n\r\n    // Finally, write new `dripped` value and transfer tokens to target\r\n    dripped = drippedNext_;\r\n    token_.transfer(target_, toDrip_);\r\n\r\n    return toDrip_;\r\n  }\r\n\r\n  /* Internal helper functions for safe math */\r\n\r\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c >= a, errorMessage);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    require(b <= a, errorMessage);\r\n    uint c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    require(c / a == b, errorMessage);\r\n    return c;\r\n  }\r\n\r\n  function min(uint a, uint b) internal pure returns (uint) {\r\n    if (a <= b) {\r\n      return a;\r\n    } else {\r\n      return b;\r\n    }\r\n  }\r\n}\r\n\r\nimport \"./EIP20Interface.sol\";\r\n"
    },
    "contracts/SafeMath.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return add(a, b, \"SafeMath: addition overflow\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, errorMessage);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n"
    },
    "contracts/SimplePriceOracle.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./PriceOracle.sol\";\r\nimport \"./VBep20.sol\";\r\n\r\ncontract SimplePriceOracle is PriceOracle {\r\n    mapping(address => uint) prices;\r\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\r\n\r\n    function getUnderlyingPrice(VToken vToken) public view returns (uint) {\r\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\r\n            return 1e18;\r\n        } else if (compareStrings(vToken.symbol(), \"VAI\")) {\r\n            return prices[address(vToken)];\r\n        } else {\r\n            return prices[address(VBep20(address(vToken)).underlying())];\r\n        }\r\n    }\r\n\r\n    function setUnderlyingPrice(VToken vToken, uint underlyingPriceMantissa) public {\r\n        address asset = address(VBep20(address(vToken)).underlying());\r\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\r\n        prices[asset] = underlyingPriceMantissa;\r\n    }\r\n\r\n    function setDirectPrice(address asset, uint price) public {\r\n        emit PricePosted(asset, prices[asset], price, price);\r\n        prices[asset] = price;\r\n    }\r\n\r\n    // v1 price oracle interface for use as backing of proxy\r\n    function assetPrices(address asset) external view returns (uint) {\r\n        return prices[asset];\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n}\r\n"
    },
    "contracts/test/BEP20.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../SafeMath.sol\";\r\n\r\ninterface BEP20Base {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function balanceOf(address who) external view returns (uint256);\r\n}\r\n\r\ncontract BEP20 is BEP20Base {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ncontract BEP20NS is BEP20Base {\r\n    function transfer(address to, uint256 value) external;\r\n    function transferFrom(address from, address to, uint256 value) external;\r\n}\r\n\r\n/**\r\n * @title Standard BEP20 token\r\n * @dev Implementation of the basic standard token.\r\n *  See https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is BEP20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\r\n        totalSupply = _initialAmount;\r\n        balanceOf[msg.sender] = _initialAmount;\r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _decimalUnits;\r\n    }\r\n\r\n    function transfer(address dst, uint256 amount) external returns (bool) {\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount, \"Insufficient balance\");\r\n        balanceOf[dst] = balanceOf[dst].add(amount, \"Balance overflow\");\r\n        emit Transfer(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\r\n        allowance[src][msg.sender] = allowance[src][msg.sender].sub(amount, \"Insufficient allowance\");\r\n        balanceOf[src] = balanceOf[src].sub(amount, \"Insufficient balance\");\r\n        balanceOf[dst] = balanceOf[dst].add(amount, \"Balance overflow\");\r\n        emit Transfer(src, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 amount) external returns (bool) {\r\n        allowance[msg.sender][_spender] = amount;\r\n        emit Approval(msg.sender, _spender, amount);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Non-Standard BEP20 token\r\n * @dev Version of BEP20 with no return values for `transfer` and `transferFrom`\r\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n */\r\ncontract NonStandardToken is BEP20NS {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    uint256 public totalSupply;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\r\n        totalSupply = _initialAmount;\r\n        balanceOf[msg.sender] = _initialAmount;\r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _decimalUnits;\r\n    }\r\n\r\n    function transfer(address dst, uint256 amount) external {\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount, \"Insufficient balance\");\r\n        balanceOf[dst] = balanceOf[dst].add(amount, \"Balance overflow\");\r\n        emit Transfer(msg.sender, dst, amount);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 amount) external {\r\n        allowance[src][msg.sender] = allowance[src][msg.sender].sub(amount, \"Insufficient allowance\");\r\n        balanceOf[src] = balanceOf[src].sub(amount, \"Insufficient balance\");\r\n        balanceOf[dst] = balanceOf[dst].add(amount, \"Balance overflow\");\r\n        emit Transfer(src, dst, amount);\r\n    }\r\n\r\n    function approve(address _spender, uint256 amount) external returns (bool) {\r\n        allowance[msg.sender][_spender] = amount;\r\n        emit Approval(msg.sender, _spender, amount);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract BEP20Harness is StandardToken {\r\n    // To support testing, we can specify addresses for which transferFrom should fail and return false\r\n    mapping (address => bool) public failTransferFromAddresses;\r\n\r\n    // To support testing, we allow the contract to always fail `transfer`.\r\n    mapping (address => bool) public failTransferToAddresses;\r\n\r\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\r\n        StandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {}\r\n\r\n    function harnessSetFailTransferFromAddress(address src, bool _fail) public {\r\n        failTransferFromAddresses[src] = _fail;\r\n    }\r\n\r\n    function harnessSetFailTransferToAddress(address dst, bool _fail) public {\r\n        failTransferToAddresses[dst] = _fail;\r\n    }\r\n\r\n    function harnessSetBalance(address _account, uint _amount) public {\r\n        balanceOf[_account] = _amount;\r\n    }\r\n\r\n    function transfer(address dst, uint256 amount) external returns (bool success) {\r\n        // Added for testing purposes\r\n        if (failTransferToAddresses[dst]) {\r\n            return false;\r\n        }\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount, \"Insufficient balance\");\r\n        balanceOf[dst] = balanceOf[dst].add(amount, \"Balance overflow\");\r\n        emit Transfer(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success) {\r\n        // Added for testing purposes\r\n        if (failTransferFromAddresses[src]) {\r\n            return false;\r\n        }\r\n        allowance[src][msg.sender] = allowance[src][msg.sender].sub(amount, \"Insufficient allowance\");\r\n        balanceOf[src] = balanceOf[src].sub(amount, \"Insufficient balance\");\r\n        balanceOf[dst] = balanceOf[dst].add(amount, \"Balance overflow\");\r\n        emit Transfer(src, dst, amount);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/test/ComptrollerHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Comptroller.sol\";\r\nimport \"../PriceOracle.sol\";\r\n\r\ncontract ComptrollerKovan is Comptroller {\r\n  function getXVSAddress() public view returns (address) {\r\n    return 0x61460874a7196d6a22D1eE4922473664b3E95270;\r\n  }\r\n}\r\n\r\ncontract ComptrollerRopsten is Comptroller {\r\n  function getXVSAddress() public view returns (address) {\r\n    return 0x1Fe16De955718CFAb7A44605458AB023838C2793;\r\n  }\r\n}\r\n\r\ncontract ComptrollerHarness is Comptroller {\r\n    address xvsAddress;\r\n    address vXVSAddress;\r\n    uint public blockNumber;\r\n\r\n    constructor() Comptroller() public {}\r\n\r\n    function setVenusSupplyState(address vToken, uint224 index, uint32 blockNumber_) public {\r\n        venusSupplyState[vToken].index = index;\r\n        venusSupplyState[vToken].block = blockNumber_;\r\n    }\r\n\r\n    function setVenusBorrowState(address vToken, uint224 index, uint32 blockNumber_) public {\r\n        venusBorrowState[vToken].index = index;\r\n        venusBorrowState[vToken].block = blockNumber_;\r\n    }\r\n\r\n    function setVenusAccrued(address user, uint userAccrued) public {\r\n        venusAccrued[user] = userAccrued;\r\n    }\r\n\r\n    function setXVSAddress(address xvsAddress_) public {\r\n        xvsAddress = xvsAddress_;\r\n    }\r\n\r\n    function getXVSAddress() public view returns (address) {\r\n        return xvsAddress;\r\n    }\r\n\r\n    function setXVSVTokenAddress(address vXVSAddress_) public {\r\n        vXVSAddress = vXVSAddress_;\r\n    }\r\n\r\n    function getXVSVTokenAddress() public view returns (address) {\r\n        return vXVSAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the amount of XVS distributed per block\r\n     * @param venusRate_ The amount of XVS wei per block to distribute\r\n     */\r\n    function harnessSetVenusRate(uint venusRate_) public {\r\n        venusRate = venusRate_;\r\n    }\r\n\r\n    /**\r\n     * @notice Recalculate and update XVS speeds for all XVS markets\r\n     */\r\n    function harnessRefreshVenusSpeeds() public {\r\n        VToken[] memory allMarkets_ = allMarkets;\r\n\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            VToken vToken = allMarkets_[i];\r\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n            updateVenusSupplyIndex(address(vToken));\r\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n        }\r\n\r\n        Exp memory totalUtility = Exp({mantissa: 0});\r\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            VToken vToken = allMarkets_[i];\r\n            if (venusSpeeds[address(vToken)] > 0) {\r\n                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(vToken)});\r\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\r\n                utilities[i] = utility;\r\n                totalUtility = add_(totalUtility, utility);\r\n            }\r\n        }\r\n\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            VToken vToken = allMarkets[i];\r\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\r\n            setVenusSpeedInternal(vToken, newSpeed);\r\n        }\r\n    }\r\n\r\n    function setVenusBorrowerIndex(address vToken, address borrower, uint index) public {\r\n        venusBorrowerIndex[vToken][borrower] = index;\r\n    }\r\n\r\n    function setVenusSupplierIndex(address vToken, address supplier, uint index) public {\r\n        venusSupplierIndex[vToken][supplier] = index;\r\n    }\r\n\r\n    function harnessDistributeAllBorrowerVenus(address vToken, address borrower, uint marketBorrowIndexMantissa) public {\r\n        distributeBorrowerVenus(vToken, borrower, Exp({mantissa: marketBorrowIndexMantissa}));\r\n        venusAccrued[borrower] = grantXVSInternal(borrower, venusAccrued[borrower], 0, false);\r\n    }\r\n\r\n    function harnessDistributeAllSupplierVenus(address vToken, address supplier) public {\r\n        distributeSupplierVenus(vToken, supplier);\r\n        venusAccrued[supplier] = grantXVSInternal(supplier, venusAccrued[supplier], 0, false);\r\n    }\r\n\r\n    function harnessUpdateVenusBorrowIndex(address vToken, uint marketBorrowIndexMantissa) public {\r\n        updateVenusBorrowIndex(vToken, Exp({mantissa: marketBorrowIndexMantissa}));\r\n    }\r\n\r\n    function harnessUpdateVenusSupplyIndex(address vToken) public {\r\n        updateVenusSupplyIndex(vToken);\r\n    }\r\n\r\n    function harnessDistributeBorrowerVenus(address vToken, address borrower, uint marketBorrowIndexMantissa) public {\r\n        distributeBorrowerVenus(vToken, borrower, Exp({mantissa: marketBorrowIndexMantissa}));\r\n    }\r\n\r\n    function harnessDistributeSupplierVenus(address vToken, address supplier) public {\r\n        distributeSupplierVenus(vToken, supplier);\r\n    }\r\n\r\n    function harnessTransferVenus(address user, uint userAccrued, uint threshold) public returns (uint) {\r\n        if (userAccrued > 0 && userAccrued >= threshold) {\r\n            return grantXVSInternal(user, userAccrued, 0, false);\r\n        }\r\n        return userAccrued;\r\n    }\r\n\r\n    function harnessAddVenusMarkets(address[] memory vTokens) public {\r\n        for (uint i = 0; i < vTokens.length; i++) {\r\n            // temporarily set venusSpeed to 1 (will be fixed by `harnessRefreshVenusSpeeds`)\r\n            setVenusSpeedInternal(VToken(vTokens[i]), 1);\r\n        }\r\n    }\r\n\r\n    function harnessSetMintedVAIs(address user, uint amount) public {\r\n        mintedVAIs[user] = amount;\r\n    }\r\n\r\n    function harnessFastForward(uint blocks) public returns (uint) {\r\n        blockNumber += blocks;\r\n        return blockNumber;\r\n    }\r\n\r\n    function setBlockNumber(uint number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return blockNumber;\r\n    }\r\n\r\n    function getVenusMarkets() public view returns (address[] memory) {\r\n        uint m = allMarkets.length;\r\n        uint n = 0;\r\n        for (uint i = 0; i < m; i++) {\r\n            if (venusSpeeds[address(allMarkets[i])] > 0) {\r\n                n++;\r\n            }\r\n        }\r\n\r\n        address[] memory venusMarkets = new address[](n);\r\n        uint k = 0;\r\n        for (uint i = 0; i < m; i++) {\r\n            if (venusSpeeds[address(allMarkets[i])] > 0) {\r\n                venusMarkets[k++] = address(allMarkets[i]);\r\n            }\r\n        }\r\n        return venusMarkets;\r\n    }\r\n\r\n    function harnessSetReleaseStartBlock(uint startBlock) external {\r\n        releaseStartBlock = startBlock;\r\n    }\r\n}\r\n\r\ncontract ComptrollerBorked {\r\n    function _become(Unitroller unitroller) public {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\r\n        unitroller._acceptImplementation();\r\n    }\r\n}\r\n\r\ncontract BoolComptroller is ComptrollerInterface {\r\n    bool allowMint = true;\r\n    bool allowRedeem = true;\r\n    bool allowBorrow = true;\r\n    bool allowRepayBorrow = true;\r\n    bool allowLiquidateBorrow = true;\r\n    bool allowSeize = true;\r\n    bool allowTransfer = true;\r\n\r\n    bool verifyMint = true;\r\n    bool verifyRedeem = true;\r\n    bool verifyBorrow = true;\r\n    bool verifyRepayBorrow = true;\r\n    bool verifyLiquidateBorrow = true;\r\n    bool verifySeize = true;\r\n    bool verifyTransfer = true;\r\n    uint public liquidationIncentiveMantissa = 11e17;\r\n    bool failCalculateSeizeTokens;\r\n    uint calculatedSeizeTokens;\r\n\r\n    bool public protocolPaused = false;\r\n\r\n    mapping(address => uint) public mintedVAIs;\r\n    bool vaiFailCalculateSeizeTokens;\r\n    uint vaiCalculatedSeizeTokens;\r\n\r\n    uint noError = 0;\r\n    uint opaqueError = noError + 11; // an arbitrary, opaque error code\r\n\r\n    address public treasuryGuardian;\r\n    address public treasuryAddress;\r\n    uint public treasuryPercent;\r\n    address public liquidatorContract;\r\n\r\n    /*** Assets You Are In ***/\r\n\r\n    function enterMarkets(address[] calldata _vTokens) external returns (uint[] memory) {\r\n        _vTokens;\r\n        uint[] memory ret;\r\n        return ret;\r\n    }\r\n\r\n    function exitMarket(address _vToken) external returns (uint) {\r\n        _vToken;\r\n        return noError;\r\n    }\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    function mintAllowed(address _vToken, address _minter, uint _mintAmount) external returns (uint) {\r\n        _vToken;\r\n        _minter;\r\n        _mintAmount;\r\n        return allowMint ? noError : opaqueError;\r\n    }\r\n\r\n    function mintVerify(address _vToken, address _minter, uint _mintAmount, uint _mintTokens) external {\r\n        _vToken;\r\n        _minter;\r\n        _mintAmount;\r\n        _mintTokens;\r\n        require(verifyMint, \"mintVerify rejected mint\");\r\n    }\r\n\r\n    function redeemAllowed(address _vToken, address _redeemer, uint _redeemTokens) external returns (uint) {\r\n        _vToken;\r\n        _redeemer;\r\n        _redeemTokens;\r\n        return allowRedeem ? noError : opaqueError;\r\n    }\r\n\r\n    function redeemVerify(address _vToken, address _redeemer, uint _redeemAmount, uint _redeemTokens) external {\r\n        _vToken;\r\n        _redeemer;\r\n        _redeemAmount;\r\n        _redeemTokens;\r\n        require(verifyRedeem, \"redeemVerify rejected redeem\");\r\n    }\r\n\r\n    function borrowAllowed(address _vToken, address _borrower, uint _borrowAmount) external returns (uint) {\r\n        _vToken;\r\n        _borrower;\r\n        _borrowAmount;\r\n        return allowBorrow ? noError : opaqueError;\r\n    }\r\n\r\n    function borrowVerify(address _vToken, address _borrower, uint _borrowAmount) external {\r\n        _vToken;\r\n        _borrower;\r\n        _borrowAmount;\r\n        require(verifyBorrow, \"borrowVerify rejected borrow\");\r\n    }\r\n\r\n    function repayBorrowAllowed(\r\n        address _vToken,\r\n        address _payer,\r\n        address _borrower,\r\n        uint _repayAmount) external returns (uint) {\r\n        _vToken;\r\n        _payer;\r\n        _borrower;\r\n        _repayAmount;\r\n        return allowRepayBorrow ? noError : opaqueError;\r\n    }\r\n\r\n    function repayBorrowVerify(\r\n        address _vToken,\r\n        address _payer,\r\n        address _borrower,\r\n        uint _repayAmount,\r\n        uint _borrowerIndex) external {\r\n        _vToken;\r\n        _payer;\r\n        _borrower;\r\n        _repayAmount;\r\n        _borrowerIndex;\r\n        require(verifyRepayBorrow, \"repayBorrowVerify rejected repayBorrow\");\r\n    }\r\n\r\n    function _setLiquidatorContract(address liquidatorContract_) external {\r\n        liquidatorContract = liquidatorContract_;\r\n    }\r\n\r\n    function liquidateBorrowAllowed(\r\n        address _vTokenBorrowed,\r\n        address _vTokenCollateral,\r\n        address _liquidator,\r\n        address _borrower,\r\n        uint _repayAmount) external returns (uint) {\r\n        _vTokenBorrowed;\r\n        _vTokenCollateral;\r\n        _borrower;\r\n        _repayAmount;\r\n        if (liquidatorContract != address(0) && liquidatorContract != _liquidator) {\r\n            return opaqueError;\r\n        }\r\n        return allowLiquidateBorrow ? noError : opaqueError;\r\n    }\r\n\r\n    function liquidateBorrowVerify(\r\n        address _vTokenBorrowed,\r\n        address _vTokenCollateral,\r\n        address _liquidator,\r\n        address _borrower,\r\n        uint _repayAmount,\r\n        uint _seizeTokens) external {\r\n        _vTokenBorrowed;\r\n        _vTokenCollateral;\r\n        _liquidator;\r\n        _borrower;\r\n        _repayAmount;\r\n        _seizeTokens;\r\n        require(verifyLiquidateBorrow, \"liquidateBorrowVerify rejected liquidateBorrow\");\r\n    }\r\n\r\n    function seizeAllowed(\r\n        address _vTokenCollateral,\r\n        address _vTokenBorrowed,\r\n        address _borrower,\r\n        address _liquidator,\r\n        uint _seizeTokens) external returns (uint) {\r\n        _vTokenCollateral;\r\n        _vTokenBorrowed;\r\n        _liquidator;\r\n        _borrower;\r\n        _seizeTokens;\r\n        return allowSeize ? noError : opaqueError;\r\n    }\r\n\r\n    function seizeVerify(\r\n        address _vTokenCollateral,\r\n        address _vTokenBorrowed,\r\n        address _liquidator,\r\n        address _borrower,\r\n        uint _seizeTokens) external {\r\n        _vTokenCollateral;\r\n        _vTokenBorrowed;\r\n        _liquidator;\r\n        _borrower;\r\n        _seizeTokens;\r\n        require(verifySeize, \"seizeVerify rejected seize\");\r\n    }\r\n\r\n    function transferAllowed(\r\n        address _vToken,\r\n        address _src,\r\n        address _dst,\r\n        uint _transferTokens) external returns (uint) {\r\n        _vToken;\r\n        _src;\r\n        _dst;\r\n        _transferTokens;\r\n        return allowTransfer ? noError : opaqueError;\r\n    }\r\n\r\n    function transferVerify(\r\n        address _vToken,\r\n        address _src,\r\n        address _dst,\r\n        uint _transferTokens) external {\r\n        _vToken;\r\n        _src;\r\n        _dst;\r\n        _transferTokens;\r\n        require(verifyTransfer, \"transferVerify rejected transfer\");\r\n    }\r\n\r\n    /*** Special Liquidation Calculation ***/\r\n\r\n    function liquidateCalculateSeizeTokens(\r\n        address _vTokenBorrowed,\r\n        address _vTokenCollateral,\r\n        uint _repayAmount) external view returns (uint, uint) {\r\n        _vTokenBorrowed;\r\n        _vTokenCollateral;\r\n        _repayAmount;\r\n        return failCalculateSeizeTokens ? (opaqueError, 0) : (noError, calculatedSeizeTokens);\r\n    }\r\n\r\n    /*** Special Liquidation Calculation ***/\r\n\r\n    function liquidateVAICalculateSeizeTokens(\r\n        address _vTokenCollateral,\r\n        uint _repayAmount) external view returns (uint, uint) {\r\n        _vTokenCollateral;\r\n        _repayAmount;\r\n        return vaiFailCalculateSeizeTokens ? (opaqueError, 0) : (noError, vaiCalculatedSeizeTokens);\r\n    }\r\n\r\n    /**** Mock Settors ****/\r\n\r\n    /*** Policy Hooks ***/\r\n\r\n    function setMintAllowed(bool allowMint_) public {\r\n        allowMint = allowMint_;\r\n    }\r\n\r\n    function setMintVerify(bool verifyMint_) public {\r\n        verifyMint = verifyMint_;\r\n    }\r\n\r\n    function setRedeemAllowed(bool allowRedeem_) public {\r\n        allowRedeem = allowRedeem_;\r\n    }\r\n\r\n    function setRedeemVerify(bool verifyRedeem_) public {\r\n        verifyRedeem = verifyRedeem_;\r\n    }\r\n\r\n    function setBorrowAllowed(bool allowBorrow_) public {\r\n        allowBorrow = allowBorrow_;\r\n    }\r\n\r\n    function setBorrowVerify(bool verifyBorrow_) public {\r\n        verifyBorrow = verifyBorrow_;\r\n    }\r\n\r\n    function setRepayBorrowAllowed(bool allowRepayBorrow_) public {\r\n        allowRepayBorrow = allowRepayBorrow_;\r\n    }\r\n\r\n    function setRepayBorrowVerify(bool verifyRepayBorrow_) public {\r\n        verifyRepayBorrow = verifyRepayBorrow_;\r\n    }\r\n\r\n    function setLiquidateBorrowAllowed(bool allowLiquidateBorrow_) public {\r\n        allowLiquidateBorrow = allowLiquidateBorrow_;\r\n    }\r\n\r\n    function setLiquidateBorrowVerify(bool verifyLiquidateBorrow_) public {\r\n        verifyLiquidateBorrow = verifyLiquidateBorrow_;\r\n    }\r\n\r\n    function setSeizeAllowed(bool allowSeize_) public {\r\n        allowSeize = allowSeize_;\r\n    }\r\n\r\n    function setSeizeVerify(bool verifySeize_) public {\r\n        verifySeize = verifySeize_;\r\n    }\r\n\r\n    function setTransferAllowed(bool allowTransfer_) public {\r\n        allowTransfer = allowTransfer_;\r\n    }\r\n\r\n    function setTransferVerify(bool verifyTransfer_) public {\r\n        verifyTransfer = verifyTransfer_;\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n    function setAnnouncedLiquidationIncentiveMantissa(uint mantissa_) external {\r\n        liquidationIncentiveMantissa = mantissa_;\r\n    }\r\n\r\n    /*** Liquidity/Liquidation Calculations ***/\r\n\r\n    function setCalculatedSeizeTokens(uint seizeTokens_) public {\r\n        calculatedSeizeTokens = seizeTokens_;\r\n    }\r\n\r\n    function setFailCalculateSeizeTokens(bool shouldFail) public {\r\n        failCalculateSeizeTokens = shouldFail;\r\n    }\r\n\r\n    function setVAICalculatedSeizeTokens(uint vaiSeizeTokens_) public {\r\n        vaiCalculatedSeizeTokens = vaiSeizeTokens_;\r\n    }\r\n\r\n    function setVAIFailCalculateSeizeTokens(bool vaiShouldFail) public {\r\n        vaiFailCalculateSeizeTokens = vaiShouldFail;\r\n    }\r\n\r\n    function harnessSetMintedVAIOf(address owner, uint amount) external returns (uint) {\r\n        mintedVAIs[owner] = amount;\r\n        return noError;\r\n    }\r\n\r\n    // function mintedVAIs(address owner) external pure returns (uint) {\r\n    //     owner;\r\n    //     return 1e18;\r\n    // }\r\n\r\n    function setMintedVAIOf(address owner, uint amount) external returns (uint) {\r\n        owner;\r\n        amount;\r\n        return noError;\r\n    }\r\n\r\n    function vaiMintRate() external pure returns (uint) {\r\n        return 1e18;\r\n    }\r\n\r\n    function setTreasuryData(address treasuryGuardian_, address treasuryAddress_, uint treasuryPercent_) external {\r\n        treasuryGuardian = treasuryGuardian_;\r\n        treasuryAddress = treasuryAddress_;\r\n        treasuryPercent = treasuryPercent_;\r\n    }\r\n\r\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint[] calldata newSupplyCaps) external {\r\n\r\n    }\r\n\r\n    /*** Functions from ComptrollerInterface not implemented by BoolComptroller ***/\r\n\r\n    function markets(address) external view returns (bool, uint) { revert(); }\r\n    function oracle() external view returns (PriceOracle) { revert(); }\r\n    function getAccountLiquidity(address) external view returns (uint, uint, uint) { revert(); }\r\n    function getAssetsIn(address) external view returns (VToken[] memory) { revert(); }\r\n    function claimVenus(address) external { revert(); }\r\n    function venusAccrued(address) external view returns (uint) { revert(); }\r\n    function venusSpeeds(address) external view returns (uint) { revert(); }\r\n    function getAllMarkets() external view returns (VToken[] memory) { revert(); }\r\n    function venusSupplierIndex(address, address) external view returns (uint) { revert(); }\r\n    function venusInitialIndex() external view returns (uint224) { revert(); }\r\n    function venusBorrowerIndex(address, address) external view returns (uint) { revert(); }\r\n    function venusBorrowState(address) external view returns (uint224, uint32) { revert(); }\r\n    function venusSupplyState(address) external view returns (uint224, uint32) { revert(); }\r\n}\r\n\r\ncontract EchoTypesComptroller is UnitrollerAdminStorage {\r\n    function stringy(string memory s) public pure returns(string memory) {\r\n        return s;\r\n    }\r\n\r\n    function addresses(address a) public pure returns(address) {\r\n        return a;\r\n    }\r\n\r\n    function booly(bool b) public pure returns(bool) {\r\n        return b;\r\n    }\r\n\r\n    function listOInts(uint[] memory u) public pure returns(uint[] memory) {\r\n        return u;\r\n    }\r\n\r\n    function reverty() public pure {\r\n        require(false, \"gotcha sucka\");\r\n    }\r\n\r\n    function becomeBrains(address payable unitroller) public {\r\n        Unitroller(unitroller)._acceptImplementation();\r\n    }\r\n}\r\n"
    },
    "contracts/test/ComptrollerScenario.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Comptroller.sol\";\r\n\r\ncontract ComptrollerScenario is Comptroller {\r\n    uint public blockNumber;\r\n    address public xvsAddress;\r\n    address public vaiAddress;\r\n\r\n    constructor() Comptroller() public {}\r\n\r\n    function setXVSAddress(address xvsAddress_) public {\r\n        xvsAddress = xvsAddress_;\r\n    }\r\n\r\n    function getXVSAddress() public view returns (address) {\r\n        return xvsAddress;\r\n    }\r\n\r\n    function setVAIAddress(address vaiAddress_) public {\r\n        vaiAddress = vaiAddress_;\r\n    }\r\n\r\n    function getVAIAddress() public view returns (address) {\r\n        return vaiAddress;\r\n    }\r\n\r\n    function membershipLength(VToken vToken) public view returns (uint) {\r\n        return accountAssets[address(vToken)].length;\r\n    }\r\n\r\n    function fastForward(uint blocks) public returns (uint) {\r\n        blockNumber += blocks;\r\n\r\n        return blockNumber;\r\n    }\r\n\r\n    function setBlockNumber(uint number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return blockNumber;\r\n    }\r\n\r\n    function getVenusMarkets() public view returns (address[] memory) {\r\n        uint m = allMarkets.length;\r\n        uint n = 0;\r\n        for (uint i = 0; i < m; i++) {\r\n            if (markets[address(allMarkets[i])].isVenus) {\r\n                n++;\r\n            }\r\n        }\r\n\r\n        address[] memory venusMarkets = new address[](n);\r\n        uint k = 0;\r\n        for (uint i = 0; i < m; i++) {\r\n            if (markets[address(allMarkets[i])].isVenus) {\r\n                venusMarkets[k++] = address(allMarkets[i]);\r\n            }\r\n        }\r\n        return venusMarkets;\r\n    }\r\n\r\n    function unlist(VToken vToken) public {\r\n        markets[address(vToken)].isListed = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Recalculate and update XVS speeds for all XVS markets\r\n     */\r\n    function refreshVenusSpeeds() public {\r\n        VToken[] memory allMarkets_ = allMarkets;\r\n\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            VToken vToken = allMarkets_[i];\r\n            Exp memory borrowIndex = Exp({mantissa: vToken.borrowIndex()});\r\n            updateVenusSupplyIndex(address(vToken));\r\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\r\n        }\r\n\r\n        Exp memory totalUtility = Exp({mantissa: 0});\r\n        Exp[] memory utilities = new Exp[](allMarkets_.length);\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            VToken vToken = allMarkets_[i];\r\n            if (venusSpeeds[address(vToken)] > 0) {\r\n                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(vToken)});\r\n                Exp memory utility = mul_(assetPrice, vToken.totalBorrows());\r\n                utilities[i] = utility;\r\n                totalUtility = add_(totalUtility, utility);\r\n            }\r\n        }\r\n\r\n        for (uint i = 0; i < allMarkets_.length; i++) {\r\n            VToken vToken = allMarkets[i];\r\n            uint newSpeed = totalUtility.mantissa > 0 ? mul_(venusRate, div_(utilities[i], totalUtility)) : 0;\r\n            setVenusSpeedInternal(vToken, newSpeed);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/test/ComptrollerScenarioG1.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../ComptrollerG1.sol\";\r\n\r\ncontract ComptrollerScenarioG1 is ComptrollerG1 {\r\n    uint public blockNumber;\r\n    address public xvsAddress;\r\n    address public vaiAddress;\r\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\r\n    mapping(address => uint) public supplyCaps;\r\n\r\n    constructor() ComptrollerG1() public {}\r\n\r\n    function setXVSAddress(address xvsAddress_) public {\r\n        xvsAddress = xvsAddress_;\r\n    }\r\n\r\n    function getXVSAddress() public view returns (address) {\r\n        return xvsAddress;\r\n    }\r\n\r\n    function setVAIAddress(address vaiAddress_) public {\r\n        vaiAddress = vaiAddress_;\r\n    }\r\n\r\n    function getVAIAddress() public view returns (address) {\r\n        return vaiAddress;\r\n    }\r\n\r\n    function membershipLength(VToken vToken) public view returns (uint) {\r\n        return accountAssets[address(vToken)].length;\r\n    }\r\n\r\n    function fastForward(uint blocks) public returns (uint) {\r\n        blockNumber += blocks;\r\n\r\n        return blockNumber;\r\n    }\r\n\r\n    function setBlockNumber(uint number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return blockNumber;\r\n    }\r\n\r\n    function getVenusMarkets() public view returns (address[] memory) {\r\n        uint m = allMarkets.length;\r\n        uint n = 0;\r\n        for (uint i = 0; i < m; i++) {\r\n            if (markets[address(allMarkets[i])].isVenus) {\r\n                n++;\r\n            }\r\n        }\r\n\r\n        address[] memory venusMarkets = new address[](n);\r\n        uint k = 0;\r\n        for (uint i = 0; i < m; i++) {\r\n            if (markets[address(allMarkets[i])].isVenus) {\r\n                venusMarkets[k++] = address(allMarkets[i]);\r\n            }\r\n        }\r\n        return venusMarkets;\r\n    }\r\n\r\n    function unlist(VToken vToken) public {\r\n        markets[address(vToken)].isListed = false;\r\n    }\r\n\r\n    /**\r\n    * @notice Set the given supply caps for the given vToken markets. Supply that brings total Supply to or above supply cap will revert.\r\n    * @dev Admin function to set the supply caps. A supply cap of 0 corresponds to Minting NotAllowed.\r\n    * @param vTokens The addresses of the markets (tokens) to change the supply caps for\r\n    * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed.\r\n    */\r\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint[] calldata newSupplyCaps) external {\r\n        require(msg.sender == admin , \"only admin can set supply caps\");\r\n\r\n        uint numMarkets = vTokens.length;\r\n        uint numSupplyCaps = newSupplyCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/test/ComptrollerScenarioG2.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../ComptrollerG2.sol\";\r\n\r\ncontract ComptrollerScenarioG2 is ComptrollerG2 {\r\n    uint public blockNumber;\r\n    /// @notice Supply caps enforced by mintAllowed for each vToken address. Defaults to zero which corresponds to minting notAllowed\r\n    mapping(address => uint) public supplyCaps;\r\n\r\n    constructor() ComptrollerG2() public {}\r\n\r\n    function fastForward(uint blocks) public returns (uint) {\r\n        blockNumber += blocks;\r\n        return blockNumber;\r\n    }\r\n\r\n    function setBlockNumber(uint number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function membershipLength(VToken vToken) public view returns (uint) {\r\n        return accountAssets[address(vToken)].length;\r\n    }\r\n\r\n    function unlist(VToken vToken) public {\r\n        markets[address(vToken)].isListed = false;\r\n    }\r\n\r\n    function setVenusSpeed(address vToken, uint venusSpeed) public {\r\n        venusSpeeds[vToken] = venusSpeed;\r\n    }\r\n\r\n    /**\r\n    * @notice Set the given supply caps for the given vToken markets. Supply that brings total Supply to or above supply cap will revert.\r\n    * @dev Admin function to set the supply caps. A supply cap of 0 corresponds to Minting NotAllowed.\r\n    * @param vTokens The addresses of the markets (tokens) to change the supply caps for\r\n    * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed.\r\n    */\r\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint[] calldata newSupplyCaps) external {\r\n        require(msg.sender == admin , \"only admin can set supply caps\");\r\n\r\n        uint numMarkets = vTokens.length;\r\n        uint numSupplyCaps = newSupplyCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/test/ComptrollerScenarioG3.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../ComptrollerG3.sol\";\r\n\r\ncontract ComptrollerScenarioG3 is ComptrollerG3 {\r\n    uint public blockNumber;\r\n\r\n    constructor() ComptrollerG3() public {}\r\n\r\n    function fastForward(uint blocks) public returns (uint) {\r\n        blockNumber += blocks;\r\n        return blockNumber;\r\n    }\r\n\r\n    function setBlockNumber(uint number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function membershipLength(VToken vToken) public view returns (uint) {\r\n        return accountAssets[address(vToken)].length;\r\n    }\r\n\r\n    function unlist(VToken vToken) public {\r\n        markets[address(vToken)].isListed = false;\r\n    }\r\n\r\n    function setVenusSpeed(address vToken, uint venusSpeed) public {\r\n        venusSpeeds[vToken] = venusSpeed;\r\n    }\r\n}\r\n"
    },
    "contracts/test/ComptrollerScenarioG4.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../ComptrollerG4.sol\";\r\n\r\ncontract ComptrollerScenarioG4 is ComptrollerG4 {\r\n    uint public blockNumber;\r\n\r\n    constructor() ComptrollerG4() public {}\r\n\r\n    function fastForward(uint blocks) public returns (uint) {\r\n        blockNumber += blocks;\r\n        return blockNumber;\r\n    }\r\n\r\n    function setBlockNumber(uint number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function membershipLength(VToken vToken) public view returns (uint) {\r\n        return accountAssets[address(vToken)].length;\r\n    }\r\n\r\n    function unlist(VToken vToken) public {\r\n        markets[address(vToken)].isListed = false;\r\n    }\r\n\r\n    function setVenusSpeed(address vToken, uint venusSpeed) public {\r\n        venusSpeeds[vToken] = venusSpeed;\r\n    }\r\n}\r\n"
    },
    "contracts/test/ComptrollerScenarioG5.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../../contracts/ComptrollerG5.sol\";\r\n\r\ncontract ComptrollerScenarioG5 is ComptrollerG5 {\r\n    uint public blockNumber;\r\n\r\n    constructor() ComptrollerG5() public {}\r\n\r\n    function fastForward(uint blocks) public returns (uint) {\r\n        blockNumber += blocks;\r\n        return blockNumber;\r\n    }\r\n\r\n    function setBlockNumber(uint number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function membershipLength(VToken vToken) public view returns (uint) {\r\n        return accountAssets[address(vToken)].length;\r\n    }\r\n\r\n    function unlist(VToken vToken) public {\r\n        markets[address(vToken)].isListed = false;\r\n    }\r\n\r\n    function setVenusSpeed(address vToken, uint venusSpeed) public {\r\n        venusSpeeds[vToken] = venusSpeed;\r\n    }\r\n}\r\n"
    },
    "contracts/test/EvilToken.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./FaucetToken.sol\";\r\n\r\n/**\r\n  * @title The Venus Evil Test Token\r\n  * @author Venus\r\n  * @notice A simple test token that fails certain operations\r\n  */\r\ncontract EvilToken is FaucetToken {\r\n    bool public fail;\r\n\r\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\r\n        FaucetToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\r\n        fail = true;\r\n    }\r\n\r\n    function setFail(bool _fail) external {\r\n        fail = _fail;\r\n    }\r\n\r\n    function transfer(address dst, uint256 amount) external returns (bool) {\r\n        if (fail) {\r\n            return false;\r\n        }\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\r\n        balanceOf[dst] = balanceOf[dst].add(amount);\r\n        emit Transfer(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\r\n        if (fail) {\r\n            return false;\r\n        }\r\n        balanceOf[src] = balanceOf[src].sub(amount);\r\n        balanceOf[dst] = balanceOf[dst].add(amount);\r\n        allowance[src][msg.sender] = allowance[src][msg.sender].sub(amount);\r\n        emit Transfer(src, dst, amount);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/test/Fauceteer.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../EIP20NonStandardInterface.sol\";\r\n\r\n/**\r\n  * @title Fauceteer\r\n  * @author Venus\r\n  * @notice First computer program to be part of The Giving Pledge\r\n  */\r\ncontract Fauceteer {\r\n\r\n    /**\r\n      * @notice Drips some tokens to caller\r\n      * @dev We send 0.01% of our tokens to the caller. Over time, the amount will tend toward and eventually reach zero.\r\n      * @param token The token to drip. Note: if we have no balance in this token, function will revert.\r\n      */\r\n    function drip(EIP20NonStandardInterface token) public {\r\n        uint tokenBalance = token.balanceOf(address(this));\r\n        require(tokenBalance > 0, \"Fauceteer is empty\");\r\n        token.transfer(msg.sender, tokenBalance / 10000); // 0.01%\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                       // This is a non-standard BEP-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                      // This is a compliant BEP-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                      // This is an excessively non-compliant BEP-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n\r\n        require(success, \"Transfer returned false.\");\r\n    }\r\n}\r\n"
    },
    "contracts/test/FaucetToken.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./BEP20.sol\";\r\n\r\n/**\r\n * @title The Venus Faucet Test Token\r\n * @author Venus\r\n * @notice A simple test token that lets anyone get more of it.\r\n */\r\ncontract FaucetToken is StandardToken {\r\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\r\n        StandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\r\n    }\r\n\r\n    function allocateTo(address _owner, uint256 value) public {\r\n        balanceOf[_owner] += value;\r\n        totalSupply += value;\r\n        emit Transfer(address(this), _owner, value);\r\n    }\r\n}\r\n\r\n/**\r\n * @title The Venus Faucet Test Token (non-standard)\r\n * @author Venus\r\n * @notice A simple test token that lets anyone get more of it.\r\n */\r\ncontract FaucetNonStandardToken is NonStandardToken {\r\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\r\n        NonStandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\r\n    }\r\n\r\n    function allocateTo(address _owner, uint256 value) public {\r\n        balanceOf[_owner] += value;\r\n        totalSupply += value;\r\n        emit Transfer(address(this), _owner, value);\r\n    }\r\n}\r\n\r\n/**\r\n * @title The Venus Faucet Re-Entrant Test Token\r\n * @author Venus\r\n * @notice A test token that is malicious and tries to re-enter callers\r\n */\r\ncontract FaucetTokenReEntrantHarness {\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 totalSupply_;\r\n    mapping (address => mapping (address => uint256)) allowance_;\r\n    mapping (address => uint256) balanceOf_;\r\n\r\n    bytes public reEntryCallData;\r\n    string public reEntryFun;\r\n\r\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\r\n        totalSupply_ = _initialAmount;\r\n        balanceOf_[msg.sender] = _initialAmount;\r\n        name = _tokenName;\r\n        symbol = _tokenSymbol;\r\n        decimals = _decimalUnits;\r\n        reEntryCallData = _reEntryCallData;\r\n        reEntryFun = _reEntryFun;\r\n    }\r\n\r\n    modifier reEnter(string memory funName) {\r\n        string memory _reEntryFun = reEntryFun;\r\n        if (compareStrings(_reEntryFun, funName)) {\r\n            reEntryFun = \"\"; // Clear re-entry fun\r\n            (bool success, bytes memory returndata) = msg.sender.call(reEntryCallData);\r\n            assembly {\r\n                if eq(success, 0) {\r\n                    revert(add(returndata, 0x20), returndatasize())\r\n                }\r\n            }\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b)));\r\n    }\r\n\r\n    function allocateTo(address _owner, uint256 value) public {\r\n        balanceOf_[_owner] += value;\r\n        totalSupply_ += value;\r\n        emit Transfer(address(this), _owner, value);\r\n    }\r\n\r\n    function totalSupply() public reEnter(\"totalSupply\") returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public reEnter(\"allowance\") returns (uint256 remaining) {\r\n        return allowance_[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public reEnter(\"approve\") returns (bool success) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address owner) public reEnter(\"balanceOf\") returns (uint256 balance) {\r\n        return balanceOf_[owner];\r\n    }\r\n\r\n    function transfer(address dst, uint256 amount) public reEnter(\"transfer\") returns (bool success) {\r\n        _transfer(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 amount) public reEnter(\"transferFrom\") returns (bool success) {\r\n        _transfer(src, dst, amount);\r\n        _approve(src, msg.sender, allowance_[src][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(spender != address(0), \"sender should be valid address\");\r\n        require(owner != address(0), \"owner should be valid address\");\r\n        allowance_[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(address src, address dst, uint256 amount) internal {\r\n        require(dst != address(0), \"dst should be valid address\");\r\n        balanceOf_[src] = balanceOf_[src].sub(amount);\r\n        balanceOf_[dst] = balanceOf_[dst].add(amount);\r\n        emit Transfer(src, dst, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/test/FeeToken.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./FaucetToken.sol\";\r\n\r\n/**\r\n  * @title Fee Token\r\n  * @author Venus\r\n  * @notice A simple test token that charges fees on transfer. Used to mock USDT.\r\n  */\r\ncontract FeeToken is FaucetToken {\r\n    uint public basisPointFee;\r\n    address public owner;\r\n\r\n    constructor(\r\n        uint256 _initialAmount,\r\n        string memory _tokenName,\r\n        uint8 _decimalUnits,\r\n        string memory _tokenSymbol,\r\n        uint _basisPointFee,\r\n        address _owner\r\n    ) FaucetToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) public {\r\n        basisPointFee = _basisPointFee;\r\n        owner = _owner;\r\n    }\r\n\r\n    function transfer(address dst, uint amount) public returns (bool) {\r\n        uint fee = amount.mul(basisPointFee).div(10000);\r\n        uint net = amount.sub(fee);\r\n        balanceOf[owner] = balanceOf[owner].add(fee);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\r\n        balanceOf[dst] = balanceOf[dst].add(net);\r\n        emit Transfer(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint amount) public returns (bool) {\r\n        uint fee = amount.mul(basisPointFee).div(10000);\r\n        uint net = amount.sub(fee);\r\n        balanceOf[owner] = balanceOf[owner].add(fee);\r\n        balanceOf[src] = balanceOf[src].sub(amount);\r\n        balanceOf[dst] = balanceOf[dst].add(net);\r\n        allowance[src][msg.sender] = allowance[src][msg.sender].sub(amount);\r\n        emit Transfer(src, dst, amount);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/test/FixedPriceOracle.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../PriceOracle.sol\";\r\n\r\ncontract FixedPriceOracle is PriceOracle {\r\n    uint public price;\r\n\r\n    constructor(uint _price) public {\r\n        price = _price;\r\n    }\r\n\r\n    function getUnderlyingPrice(VToken vToken) public view returns (uint) {\r\n        vToken;\r\n        return price;\r\n    }\r\n\r\n    function assetPrices(address asset) public view returns (uint) {\r\n        asset;\r\n        return price;\r\n    }\r\n}\r\n"
    },
    "contracts/test/GovernorAlphaHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../Governance/GovernorAlpha.sol\";\r\n\r\ncontract GovernorAlphaHarness is GovernorAlpha {\r\n    constructor(address timelock_, address xvs_, address guardian_) GovernorAlpha(timelock_, xvs_, guardian_) public {}\r\n\r\n    function votingPeriod() public pure returns (uint) { return 240; }\r\n}\r\n"
    },
    "contracts/test/InterestRateModelHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../InterestRateModel.sol\";\r\n\r\n/**\r\n  * @title An Interest Rate Model for tests that can be instructed to return a failure instead of doing a calculation\r\n  * @author Venus\r\n  */\r\ncontract InterestRateModelHarness is InterestRateModel {\r\n    uint public constant opaqueBorrowFailureCode = 20;\r\n    bool public failBorrowRate;\r\n    uint public borrowRate;\r\n\r\n    constructor(uint borrowRate_) public {\r\n        borrowRate = borrowRate_;\r\n    }\r\n\r\n    function setFailBorrowRate(bool failBorrowRate_) public {\r\n        failBorrowRate = failBorrowRate_;\r\n    }\r\n\r\n    function setBorrowRate(uint borrowRate_) public {\r\n        borrowRate = borrowRate_;\r\n    }\r\n\r\n    function getBorrowRate(uint _cash, uint _borrows, uint _reserves) public view returns (uint) {\r\n        _cash;     // unused\r\n        _borrows;  // unused\r\n        _reserves; // unused\r\n        require(!failBorrowRate, \"INTEREST_RATE_MODEL_ERROR\");\r\n        return borrowRate;\r\n    }\r\n\r\n    function getSupplyRate(uint _cash, uint _borrows, uint _reserves, uint _reserveFactor) external view returns (uint) {\r\n        _cash;     // unused\r\n        _borrows;  // unused\r\n        _reserves; // unused\r\n        return borrowRate * (1 - _reserveFactor);\r\n    }\r\n}"
    },
    "contracts/test/LiquidatorHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Liquidator.sol\";\r\nimport \"./ComptrollerScenario.sol\";\r\n\r\ncontract LiquidatorHarness is Liquidator {\r\n\r\n    constructor(\r\n        address admin_,\r\n        address payable vBnb_,\r\n        address comptroller_,\r\n        address vaiController_,\r\n        address treasury_,\r\n        uint256 treasuryPercentMantissa_\r\n    )\r\n        public\r\n        Liquidator(\r\n            admin_,\r\n            vBnb_,\r\n            comptroller_,\r\n            vaiController_,\r\n            treasury_,\r\n            treasuryPercentMantissa_\r\n        )\r\n    {}\r\n\r\n    event DistributeLiquidationIncentive(uint256 seizeTokensForTreasury, uint256 seizeTokensForLiquidator);\r\n\r\n\r\n    /// @dev Splits the received vTokens between the liquidator and treasury.\r\n    function distributeLiquidationIncentive(\r\n        VToken vTokenCollateral,\r\n        uint256 siezedAmount\r\n    ) public returns (uint256 ours, uint256 theirs) {\r\n        (ours, theirs) = super._distributeLiquidationIncentive(vTokenCollateral, siezedAmount);\r\n        emit DistributeLiquidationIncentive(ours, theirs);\r\n        return (ours, theirs);\r\n    }\r\n\r\n    /// @dev Computes the amounts that would go to treasury and to the liquidator.\r\n    function splitLiquidationIncentive(uint256 seizedAmount)\r\n        public\r\n        view\r\n        returns (uint256 ours, uint256 theirs)\r\n    {\r\n       return super._splitLiquidationIncentive(seizedAmount);\r\n    }\r\n}\r\n"
    },
    "contracts/test/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.5.0;\r\n\r\nimport \"../AggregatorV2V3Interface.sol\";\r\n\r\n/**\r\n * @title MockV3Aggregator\r\n * @notice Based on the FluxAggregator contract\r\n * @notice Use this contract when you need to test\r\n * other contract's ability to read data from an\r\n * aggregator contract, but how the aggregator got\r\n * its answer is unimportant\r\n */\r\ncontract MockV3Aggregator is AggregatorV2V3Interface {\r\n  uint256 constant public version = 0;\r\n\r\n  uint8 public decimals;\r\n  int256 public latestAnswer;\r\n  uint256 public latestTimestamp;\r\n  uint256 public latestRound;\r\n\r\n  mapping(uint256 => int256) public getAnswer;\r\n  mapping(uint256 => uint256) public getTimestamp;\r\n  mapping(uint256 => uint256) private getStartedAt;\r\n\r\n  constructor(\r\n    uint8 _decimals,\r\n    int256 _initialAnswer\r\n  ) public {\r\n    decimals = _decimals;\r\n    updateAnswer(_initialAnswer);\r\n  }\r\n\r\n  function updateAnswer(\r\n    int256 _answer\r\n  ) public {\r\n    latestAnswer = _answer;\r\n    latestTimestamp = block.timestamp;\r\n    latestRound++;\r\n    getAnswer[latestRound] = _answer;\r\n    getTimestamp[latestRound] = block.timestamp;\r\n    getStartedAt[latestRound] = block.timestamp;\r\n  }\r\n\r\n  function updateRoundData(\r\n    uint80 _roundId,\r\n    int256 _answer,\r\n    uint256 _timestamp,\r\n    uint256 _startedAt\r\n  ) public {\r\n    latestRound = _roundId;\r\n    latestAnswer = _answer;\r\n    latestTimestamp = _timestamp;\r\n    getAnswer[latestRound] = _answer;\r\n    getTimestamp[latestRound] = _timestamp;\r\n    getStartedAt[latestRound] = _startedAt;\r\n  }\r\n\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    )\r\n  {\r\n    return (\r\n      _roundId,\r\n      getAnswer[_roundId],\r\n      getStartedAt[_roundId],\r\n      getTimestamp[_roundId],\r\n      _roundId\r\n    );\r\n  }\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    )\r\n  {\r\n    return (\r\n      uint80(latestRound),\r\n      getAnswer[latestRound],\r\n      getStartedAt[latestRound],\r\n      getTimestamp[latestRound],\r\n      uint80(latestRound)\r\n    );\r\n  }\r\n\r\n  function description()\r\n    external\r\n    view\r\n    returns (string memory)\r\n  {\r\n    return \"v0.6/tests/MockV3Aggregator.sol\";\r\n  }\r\n}\r\n"
    },
    "contracts/test/SXPHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Governance/SXP.sol\";\r\n\r\ncontract SXPScenario is SXP {\r\n    constructor(address account) SXP(account) public {}\r\n\r\n    function transferScenario(address[] calldata destinations, uint256 amount) external returns (bool) {\r\n        for (uint i = 0; i < destinations.length; i++) {\r\n            address dst = destinations[i];\r\n            _transfer(msg.sender, dst, amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferFromScenario(address[] calldata froms, uint256 amount) external returns (bool) {\r\n        for (uint i = 0; i < froms.length; i++) {\r\n            address from = froms[i];\r\n            _transfer(from, msg.sender, amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function generateCheckpoints(uint count, uint offset) external {\r\n        for (uint i = 1 + offset; i <= count + offset; i++) {\r\n            checkpoints[msg.sender][numCheckpoints[msg.sender]++] = Checkpoint(uint32(i), uint96(i));\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/test/TetherInterface.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../EIP20Interface.sol\";\r\n\r\ncontract TetherInterface is EIP20Interface {\r\n    function setParams(uint newBasisPoints, uint newMaxFee) external;\r\n}"
    },
    "contracts/test/TimelockHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Timelock.sol\";\r\n\r\ninterface Administered {\r\n    function _acceptAdmin() external returns (uint);\r\n}\r\n\r\ncontract TimelockHarness is Timelock {\r\n    constructor(address admin_, uint delay_)\r\n        Timelock(admin_, delay_) public {\r\n    }\r\n\r\n    function harnessSetPendingAdmin(address pendingAdmin_) public {\r\n        pendingAdmin = pendingAdmin_;\r\n    }\r\n\r\n    function harnessSetAdmin(address admin_) public {\r\n        admin = admin_;\r\n    }\r\n}\r\n\r\ncontract TimelockTest is Timelock {\r\n    constructor(address admin_, uint delay_) Timelock(admin_, 2 days) public {\r\n        delay = delay_;\r\n    }\r\n\r\n    function harnessSetAdmin(address admin_) public {\r\n        require(msg.sender == admin, \"owner check\");\r\n        admin = admin_;\r\n    }\r\n\r\n    function harnessAcceptAdmin(Administered administered) public {\r\n        administered._acceptAdmin();\r\n    }\r\n}\r\n"
    },
    "contracts/test/VAIControllerHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../VAIController.sol\";\r\n\r\ncontract VAIControllerHarness is VAIController {\r\n    address vaiAddress;\r\n    uint public blockNumber;\r\n\r\n    constructor() VAIController() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    function setVenusVAIState(uint224 index, uint32 blockNumber_) public {\r\n        venusVAIState.index = index;\r\n        venusVAIState.block = blockNumber_;\r\n    }\r\n\r\n    function setVAIAddress(address vaiAddress_) public {\r\n        vaiAddress = vaiAddress_;\r\n    }\r\n\r\n    function getVAIAddress() public view returns (address) {\r\n        return vaiAddress;\r\n    }\r\n\r\n    function harnessRepayVAIFresh(address payer, address account, uint repayAmount) public returns (uint) {\r\n       (uint err,) = repayVAIFresh(payer, account, repayAmount);\r\n       return err;\r\n    }\r\n\r\n    function harnessLiquidateVAIFresh(address liquidator, address borrower, uint repayAmount, VToken vTokenCollateral) public returns (uint) {\r\n        (uint err,) = liquidateVAIFresh(liquidator, borrower, repayAmount, vTokenCollateral);\r\n        return err;\r\n    }\r\n\r\n    function harnessFastForward(uint blocks) public returns (uint) {\r\n        blockNumber += blocks;\r\n        return blockNumber;\r\n    }\r\n\r\n    function harnessSetBlockNumber(uint newBlockNumber) public {\r\n        blockNumber = newBlockNumber;\r\n    }\r\n\r\n    function setBlockNumber(uint number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return blockNumber;\r\n    }\r\n}\r\n"
    },
    "contracts/test/VAIControllerScenario.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../VAIController.sol\";\r\nimport \"./ComptrollerScenario.sol\";\r\n\r\ncontract VAIControllerScenario is VAIController {\r\n    uint blockNumber;\r\n    address public xvsAddress;\r\n    address public vaiAddress;\r\n\r\n    constructor() VAIController() public {}\r\n\r\n    function setVAIAddress(address vaiAddress_) public {\r\n        vaiAddress = vaiAddress_;\r\n    }\r\n\r\n    function getVAIAddress() public view returns (address) {\r\n        return vaiAddress;\r\n    }\r\n\r\n    function setBlockNumber(uint number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return blockNumber;\r\n    }\r\n}\r\n"
    },
    "contracts/test/VAIHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../VAI/VAI.sol\";\r\n\r\ncontract VAIScenario is VAI {\r\n    uint blockNumber = 100000;\r\n\r\n    constructor(uint chainId) VAI(chainId) public {}\r\n\r\n    function harnessFastForward(uint blocks) public {\r\n        blockNumber += blocks;\r\n    }\r\n\r\n    function harnessSetTotalSupply(uint _totalSupply) public {\r\n        totalSupply = _totalSupply;\r\n    }\r\n\r\n    function harnessIncrementTotalSupply(uint addtlSupply_) public {\r\n        totalSupply = totalSupply + addtlSupply_;\r\n    }\r\n\r\n    function harnessSetBalanceOf(address account, uint _amount) public {\r\n        balanceOf[account] = _amount;\r\n    }\r\n\r\n    function allocateTo(address _owner, uint256 value) public {\r\n        balanceOf[_owner] += value;\r\n        totalSupply += value;\r\n        emit Transfer(address(this), _owner, value);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/test/VBep20Harness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../VBep20Immutable.sol\";\r\nimport \"../VBep20Delegator.sol\";\r\nimport \"../VBep20Delegate.sol\";\r\nimport \"../VDaiDelegate.sol\";\r\nimport \"./ComptrollerScenario.sol\";\r\n\r\ncontract VBep20Harness is VBep20Immutable {\r\n    uint blockNumber = 100000;\r\n    uint harnessExchangeRate;\r\n    bool harnessExchangeRateStored;\r\n\r\n    mapping (address => bool) public failTransferToAddresses;\r\n\r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_)\r\n    VBep20Immutable(\r\n    underlying_,\r\n    comptroller_,\r\n    interestRateModel_,\r\n    initialExchangeRateMantissa_,\r\n    name_,\r\n    symbol_,\r\n    decimals_,\r\n    admin_) public {}\r\n\r\n    function doTransferOut(address payable to, uint amount) internal {\r\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\r\n        return super.doTransferOut(to, amount);\r\n    }\r\n\r\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\r\n        if (harnessExchangeRateStored) {\r\n            return (MathError.NO_ERROR, harnessExchangeRate);\r\n        }\r\n        return super.exchangeRateStoredInternal();\r\n    }\r\n\r\n    function getBlockNumber() internal view returns (uint) {\r\n        return blockNumber;\r\n    }\r\n\r\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\r\n        return borrowRateMaxMantissa;\r\n    }\r\n\r\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\r\n        accrualBlockNumber = _accrualblockNumber;\r\n    }\r\n\r\n    function harnessSetBlockNumber(uint newBlockNumber) public {\r\n        blockNumber = newBlockNumber;\r\n    }\r\n\r\n    function harnessFastForward(uint blocks) public {\r\n        blockNumber += blocks;\r\n    }\r\n\r\n    function harnessSetBalance(address account, uint amount) external {\r\n        accountTokens[account] = amount;\r\n    }\r\n\r\n    function harnessSetTotalSupply(uint totalSupply_) public {\r\n        totalSupply = totalSupply_;\r\n    }\r\n\r\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\r\n        totalBorrows = totalBorrows_;\r\n    }\r\n\r\n    function harnessSetTotalReserves(uint totalReserves_) public {\r\n        totalReserves = totalReserves_;\r\n    }\r\n\r\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\r\n        totalSupply = totalSupply_;\r\n        totalBorrows = totalBorrows_;\r\n        totalReserves = totalReserves_;\r\n    }\r\n\r\n    function harnessSetExchangeRate(uint exchangeRate) public {\r\n        harnessExchangeRate = exchangeRate;\r\n        harnessExchangeRateStored = true;\r\n    }\r\n\r\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\r\n        failTransferToAddresses[_to] = _fail;\r\n    }\r\n\r\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\r\n        (uint err,) = super.mintFresh(account, mintAmount);\r\n        return err;\r\n    }\r\n\r\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\r\n        (uint err,) = super.mintBehalfFresh(payer, receiver, mintAmount);\r\n        return err;\r\n    }\r\n\r\n    function harnessRedeemFresh(address payable account, uint vTokenAmount, uint underlyingAmount) public returns (uint) {\r\n        return super.redeemFresh(account, vTokenAmount, underlyingAmount);\r\n    }\r\n\r\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\r\n        BorrowSnapshot memory snapshot = accountBorrows[account];\r\n        return (snapshot.principal, snapshot.interestIndex);\r\n    }\r\n\r\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\r\n        accountBorrows[account] = BorrowSnapshot({principal: principal, interestIndex: interestIndex});\r\n    }\r\n\r\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\r\n        borrowIndex = borrowIndex_;\r\n    }\r\n\r\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\r\n        return borrowFresh(account, borrowAmount);\r\n    }\r\n\r\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\r\n        (uint err,) = repayBorrowFresh(payer, account, repayAmount);\r\n        return err;\r\n    }\r\n\r\n    function harnessLiquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, VToken vTokenCollateral) public returns (uint) {\r\n        (uint err,) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\r\n        return err;\r\n    }\r\n\r\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\r\n        return _reduceReservesFresh(amount);\r\n    }\r\n\r\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\r\n        return _setReserveFactorFresh(newReserveFactorMantissa);\r\n    }\r\n\r\n    function harnessSetInterestRateModelFresh(InterestRateModel newInterestRateModel) public returns (uint) {\r\n        return _setInterestRateModelFresh(newInterestRateModel);\r\n    }\r\n\r\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\r\n        interestRateModel = InterestRateModel(newInterestRateModelAddress);\r\n    }\r\n\r\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\r\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\r\n    }\r\n}\r\n\r\ncontract VBep20Scenario is VBep20Immutable {\r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_)\r\n    VBep20Immutable(\r\n    underlying_,\r\n    comptroller_,\r\n    interestRateModel_,\r\n    initialExchangeRateMantissa_,\r\n    name_,\r\n    symbol_,\r\n    decimals_,\r\n    admin_) public {}\r\n\r\n    function setTotalBorrows(uint totalBorrows_) public {\r\n        totalBorrows = totalBorrows_;\r\n    }\r\n\r\n    function setTotalReserves(uint totalReserves_) public {\r\n        totalReserves = totalReserves_;\r\n    }\r\n\r\n    function getBlockNumber() internal view returns (uint) {\r\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\r\n        return comptrollerScenario.blockNumber();\r\n    }\r\n}\r\n\r\ncontract VEvil is VBep20Scenario {\r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_)\r\n    VBep20Scenario(\r\n    underlying_,\r\n    comptroller_,\r\n    interestRateModel_,\r\n    initialExchangeRateMantissa_,\r\n    name_,\r\n    symbol_,\r\n    decimals_,\r\n    admin_) public {}\r\n\r\n    function evilSeize(VToken treasure, address liquidator, address borrower, uint seizeTokens) public returns (uint) {\r\n        return treasure.seize(liquidator, borrower, seizeTokens);\r\n    }\r\n}\r\n\r\ncontract VBep20DelegatorScenario is VBep20Delegator {\r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_,\r\n                address implementation_,\r\n                bytes memory becomeImplementationData)\r\n    VBep20Delegator(\r\n    underlying_,\r\n    comptroller_,\r\n    interestRateModel_,\r\n    initialExchangeRateMantissa_,\r\n    name_,\r\n    symbol_,\r\n    decimals_,\r\n    admin_,\r\n    implementation_,\r\n    becomeImplementationData) public {}\r\n\r\n    function setTotalBorrows(uint totalBorrows_) public {\r\n        totalBorrows = totalBorrows_;\r\n    }\r\n\r\n    function setTotalReserves(uint totalReserves_) public {\r\n        totalReserves = totalReserves_;\r\n    }\r\n}\r\n\r\ncontract VBep20DelegateHarness is VBep20Delegate {\r\n    event Log(string x, address y);\r\n    event Log(string x, uint y);\r\n\r\n    uint blockNumber = 100000;\r\n    uint harnessExchangeRate;\r\n    bool harnessExchangeRateStored;\r\n\r\n    mapping (address => bool) public failTransferToAddresses;\r\n\r\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\r\n        if (harnessExchangeRateStored) {\r\n            return (MathError.NO_ERROR, harnessExchangeRate);\r\n        }\r\n        return super.exchangeRateStoredInternal();\r\n    }\r\n\r\n    function doTransferOut(address payable to, uint amount) internal {\r\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\r\n        return super.doTransferOut(to, amount);\r\n    }\r\n\r\n    function getBlockNumber() internal view returns (uint) {\r\n        return blockNumber;\r\n    }\r\n\r\n    function getBorrowRateMaxMantissa() public pure returns (uint) {\r\n        return borrowRateMaxMantissa;\r\n    }\r\n\r\n    function harnessSetBlockNumber(uint newBlockNumber) public {\r\n        blockNumber = newBlockNumber;\r\n    }\r\n\r\n    function harnessFastForward(uint blocks) public {\r\n        blockNumber += blocks;\r\n    }\r\n\r\n    function harnessSetBalance(address account, uint amount) external {\r\n        accountTokens[account] = amount;\r\n    }\r\n\r\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\r\n        accrualBlockNumber = _accrualblockNumber;\r\n    }\r\n\r\n    function harnessSetTotalSupply(uint totalSupply_) public {\r\n        totalSupply = totalSupply_;\r\n    }\r\n\r\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\r\n        totalBorrows = totalBorrows_;\r\n    }\r\n\r\n    function harnessIncrementTotalBorrows(uint addtlBorrow_) public {\r\n        totalBorrows = totalBorrows + addtlBorrow_;\r\n    }\r\n\r\n    function harnessSetTotalReserves(uint totalReserves_) public {\r\n        totalReserves = totalReserves_;\r\n    }\r\n\r\n    function harnessExchangeRateDetails(uint totalSupply_, uint totalBorrows_, uint totalReserves_) public {\r\n        totalSupply = totalSupply_;\r\n        totalBorrows = totalBorrows_;\r\n        totalReserves = totalReserves_;\r\n    }\r\n\r\n    function harnessSetExchangeRate(uint exchangeRate) public {\r\n        harnessExchangeRate = exchangeRate;\r\n        harnessExchangeRateStored = true;\r\n    }\r\n\r\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\r\n        failTransferToAddresses[_to] = _fail;\r\n    }\r\n\r\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\r\n        (uint err,) = super.mintFresh(account, mintAmount);\r\n        return err;\r\n    }\r\n\r\n    function harnessMintBehalfFresh(address payer, address receiver, uint mintAmount) public returns (uint) {\r\n        (uint err,) = super.mintBehalfFresh(payer, receiver, mintAmount);\r\n        return err;\r\n    }\r\n\r\n    function harnessRedeemFresh(address payable account, uint vTokenAmount, uint underlyingAmount) public returns (uint) {\r\n        return super.redeemFresh(account, vTokenAmount, underlyingAmount);\r\n    }\r\n\r\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\r\n        BorrowSnapshot memory snapshot = accountBorrows[account];\r\n        return (snapshot.principal, snapshot.interestIndex);\r\n    }\r\n\r\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\r\n        accountBorrows[account] = BorrowSnapshot({principal: principal, interestIndex: interestIndex});\r\n    }\r\n\r\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\r\n        borrowIndex = borrowIndex_;\r\n    }\r\n\r\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\r\n        return borrowFresh(account, borrowAmount);\r\n    }\r\n\r\n    function harnessRepayBorrowFresh(address payer, address account, uint repayAmount) public returns (uint) {\r\n        (uint err,) = repayBorrowFresh(payer, account, repayAmount);\r\n        return err;\r\n    }\r\n\r\n    function harnessLiquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, VToken vTokenCollateral) public returns (uint) {\r\n        (uint err,) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\r\n        return err;\r\n    }\r\n\r\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\r\n        return _reduceReservesFresh(amount);\r\n    }\r\n\r\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\r\n        return _setReserveFactorFresh(newReserveFactorMantissa);\r\n    }\r\n\r\n    function harnessSetInterestRateModelFresh(InterestRateModel newInterestRateModel) public returns (uint) {\r\n        return _setInterestRateModelFresh(newInterestRateModel);\r\n    }\r\n\r\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\r\n        interestRateModel = InterestRateModel(newInterestRateModelAddress);\r\n    }\r\n\r\n    function harnessCallBorrowAllowed(uint amount) public returns (uint) {\r\n        return comptroller.borrowAllowed(address(this), msg.sender, amount);\r\n    }\r\n}\r\n\r\ncontract VBep20DelegateScenario is VBep20Delegate {\r\n    constructor() public {}\r\n\r\n    function setTotalBorrows(uint totalBorrows_) public {\r\n        totalBorrows = totalBorrows_;\r\n    }\r\n\r\n    function setTotalReserves(uint totalReserves_) public {\r\n        totalReserves = totalReserves_;\r\n    }\r\n\r\n    function getBlockNumber() internal view returns (uint) {\r\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\r\n        return comptrollerScenario.blockNumber();\r\n    }\r\n}\r\n\r\ncontract VBep20DelegateScenarioExtra is VBep20DelegateScenario {\r\n    function iHaveSpoken() public pure returns (string memory) {\r\n      return \"i have spoken\";\r\n    }\r\n\r\n    function itIsTheWay() public {\r\n      admin = address(1); // make a change to test effect\r\n    }\r\n\r\n    function babyYoda() public pure {\r\n      revert(\"protect the baby\");\r\n    }\r\n}\r\n\r\ncontract VDaiDelegateHarness is VDaiDelegate {\r\n    uint blockNumber = 100000;\r\n    uint harnessExchangeRate;\r\n    bool harnessExchangeRateStored;\r\n\r\n    function harnessFastForward(uint blocks) public {\r\n        blockNumber += blocks;\r\n    }\r\n\r\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\r\n        accrualBlockNumber = _accrualblockNumber;\r\n    }\r\n\r\n    function harnessSetBalance(address account, uint amount) external {\r\n        accountTokens[account] = amount;\r\n    }\r\n\r\n    function harnessSetBlockNumber(uint newBlockNumber) public {\r\n        blockNumber = newBlockNumber;\r\n    }\r\n\r\n    function harnessSetExchangeRate(uint exchangeRate) public {\r\n        harnessExchangeRate = exchangeRate;\r\n        harnessExchangeRateStored = true;\r\n    }\r\n\r\n    function harnessSetTotalSupply(uint totalSupply_) public {\r\n        totalSupply = totalSupply_;\r\n    }\r\n\r\n    function getBlockNumber() internal view returns (uint) {\r\n        return blockNumber;\r\n    }\r\n}\r\n\r\ncontract VDaiDelegateScenario is VDaiDelegate {\r\n    function setTotalBorrows(uint totalBorrows_) public {\r\n        totalBorrows = totalBorrows_;\r\n    }\r\n\r\n    function setTotalReserves(uint totalReserves_) public {\r\n        totalReserves = totalReserves_;\r\n    }\r\n\r\n    function getBlockNumber() internal view returns (uint) {\r\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\r\n        return comptrollerScenario.blockNumber();\r\n    }\r\n}\r\n\r\ncontract VDaiDelegateMakerHarness is PotLike, VatLike, GemLike, DaiJoinLike {\r\n    /* Pot */\r\n\r\n    // exchangeRate\r\n    function chi() external view returns (uint) { return 1; }\r\n\r\n    // totalSupply\r\n    function pie(address) external view returns (uint) { return 0; }\r\n\r\n    // accrueInterest -> new exchangeRate\r\n    function drip() external returns (uint) { return 0; }\r\n\r\n    // mint\r\n    function join(uint) external {}\r\n\r\n    // redeem\r\n    function exit(uint) external {}\r\n\r\n    /* Vat */\r\n\r\n    // internal dai balance\r\n    function dai(address) external view returns (uint) { return 0; }\r\n\r\n    // approve pot transfer\r\n    function hope(address) external {}\r\n\r\n    /* Gem (Dai) */\r\n\r\n    uint public totalSupply;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n    mapping (address => uint) public balanceOf;\r\n    function approve(address, uint) external {}\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool) {\r\n        balanceOf[src] -= amount;\r\n        balanceOf[dst] += amount;\r\n        return true;\r\n    }\r\n\r\n    function harnessSetBalance(address account, uint amount) external {\r\n        balanceOf[account] = amount;\r\n    }\r\n\r\n    /* DaiJoin */\r\n\r\n    // vat contract\r\n    function vat() external returns (VatLike) { return this; }\r\n\r\n    // dai contract\r\n    function dai() external returns (GemLike) { return this; }\r\n\r\n    // dai -> internal dai\r\n    function join(address, uint) external payable {}\r\n\r\n    // internal dai transfer out\r\n    function exit(address, uint) external {}\r\n}\r\n"
    },
    "contracts/test/VBNBHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../VBNB.sol\";\r\nimport \"./ComptrollerScenario.sol\";\r\n\r\ncontract VBNBHarness is VBNB {\r\n    uint harnessExchangeRate;\r\n    uint public blockNumber = 100000;\r\n\r\n    mapping (address => bool) public failTransferToAddresses;\r\n\r\n    constructor(ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_)\r\n    VBNB(\r\n    comptroller_,\r\n    interestRateModel_,\r\n    initialExchangeRateMantissa,\r\n    name_,\r\n    symbol_,\r\n    decimals_,\r\n    admin_) public {}\r\n\r\n    function doTransferOut(address payable to, uint amount) internal {\r\n        require(failTransferToAddresses[to] == false, \"TOKEN_TRANSFER_OUT_FAILED\");\r\n        return super.doTransferOut(to, amount);\r\n    }\r\n\r\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\r\n        if (harnessExchangeRate != 0) {\r\n            return (MathError.NO_ERROR, harnessExchangeRate);\r\n        }\r\n        return super.exchangeRateStoredInternal();\r\n    }\r\n\r\n    function getBlockNumber() internal view returns (uint) {\r\n        return blockNumber;\r\n    }\r\n\r\n    function harnessSetBlockNumber(uint newBlockNumber) public {\r\n        blockNumber = newBlockNumber;\r\n    }\r\n\r\n    function harnessFastForward(uint blocks) public {\r\n        blockNumber += blocks;\r\n    }\r\n\r\n    function harnessSetBalance(address account, uint amount) external {\r\n        accountTokens[account] = amount;\r\n    }\r\n\r\n    function harnessSetAccrualBlockNumber(uint _accrualblockNumber) public {\r\n        accrualBlockNumber = _accrualblockNumber;\r\n    }\r\n\r\n    function harnessSetTotalSupply(uint totalSupply_) public {\r\n        totalSupply = totalSupply_;\r\n    }\r\n\r\n    function harnessSetTotalBorrows(uint totalBorrows_) public {\r\n        totalBorrows = totalBorrows_;\r\n    }\r\n\r\n    function harnessSetTotalReserves(uint totalReserves_) public {\r\n        totalReserves = totalReserves_;\r\n    }\r\n\r\n    function harnessExchangeRateDetails(uint _totalSupply, uint _totalBorrows, uint _totalReserves) public {\r\n        totalSupply = _totalSupply;\r\n        totalBorrows = _totalBorrows;\r\n        totalReserves = _totalReserves;\r\n    }\r\n\r\n    function harnessSetExchangeRate(uint exchangeRate) public {\r\n        harnessExchangeRate = exchangeRate;\r\n    }\r\n\r\n    function harnessSetFailTransferToAddress(address _to, bool _fail) public {\r\n        failTransferToAddresses[_to] = _fail;\r\n    }\r\n\r\n    function harnessMintFresh(address account, uint mintAmount) public returns (uint) {\r\n        (uint err,) = super.mintFresh(account, mintAmount);\r\n        return err;\r\n    }\r\n\r\n    function harnessRedeemFresh(address payable account, uint vTokenAmount, uint underlyingAmount) public returns (uint) {\r\n        return super.redeemFresh(account, vTokenAmount, underlyingAmount);\r\n    }\r\n\r\n    function harnessAccountBorrows(address account) public view returns (uint principal, uint interestIndex) {\r\n        BorrowSnapshot memory snapshot = accountBorrows[account];\r\n        return (snapshot.principal, snapshot.interestIndex);\r\n    }\r\n\r\n    function harnessSetAccountBorrows(address account, uint principal, uint interestIndex) public {\r\n        accountBorrows[account] = BorrowSnapshot({principal: principal, interestIndex: interestIndex});\r\n    }\r\n\r\n    function harnessSetBorrowIndex(uint borrowIndex_) public {\r\n        borrowIndex = borrowIndex_;\r\n    }\r\n\r\n    function harnessBorrowFresh(address payable account, uint borrowAmount) public returns (uint) {\r\n        return borrowFresh(account, borrowAmount);\r\n    }\r\n\r\n    function harnessRepayBorrowFresh(address payer, address account, uint repayBorrowAmount) public payable returns (uint) {\r\n        (uint err,) = repayBorrowFresh(payer, account, repayBorrowAmount);\r\n        return err;\r\n    }\r\n\r\n    function harnessLiquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, VToken vTokenCollateral) public returns (uint) {\r\n        (uint err,) = liquidateBorrowFresh(liquidator, borrower, repayAmount, vTokenCollateral);\r\n        return err;\r\n    }\r\n\r\n    function harnessReduceReservesFresh(uint amount) public returns (uint) {\r\n        return _reduceReservesFresh(amount);\r\n    }\r\n\r\n    function harnessSetReserves(uint amount) public {\r\n        totalReserves = amount;\r\n    }\r\n\r\n    function harnessSetReserveFactorFresh(uint newReserveFactorMantissa) public returns (uint) {\r\n        return _setReserveFactorFresh(newReserveFactorMantissa);\r\n    }\r\n\r\n    function harnessSetInterestRateModelFresh(InterestRateModel newInterestRateModel) public returns (uint) {\r\n        return _setInterestRateModelFresh(newInterestRateModel);\r\n    }\r\n\r\n    function harnessSetInterestRateModel(address newInterestRateModelAddress) public {\r\n        interestRateModel = InterestRateModel(newInterestRateModelAddress);\r\n    }\r\n\r\n    function harnessGetCashPrior() public payable returns (uint) {\r\n        return getCashPrior();\r\n    }\r\n\r\n    function harnessDoTransferIn(address from, uint amount) public payable returns (uint) {\r\n        return doTransferIn(from, amount);\r\n    }\r\n\r\n    function harnessDoTransferOut(address payable to, uint amount) public payable {\r\n        return doTransferOut(to, amount);\r\n    }\r\n\r\n    function harnessRequireNoError(uint error, string calldata message) external pure {\r\n        requireNoError(error, message);\r\n    }\r\n}\r\n\r\ncontract VBNBScenario is VBNB {\r\n    uint reserveFactor;\r\n\r\n    constructor(string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa)\r\n        VBNB(comptroller_,\r\n               interestRateModel_,\r\n               initialExchangeRateMantissa,\r\n               name_,\r\n               symbol_,\r\n               decimals_,\r\n               admin_) public {\r\n    }\r\n\r\n    function setTotalBorrows(uint totalBorrows_) public {\r\n        totalBorrows = totalBorrows_;\r\n    }\r\n\r\n    function setTotalReserves(uint totalReserves_) public {\r\n        totalReserves = totalReserves_;\r\n    }\r\n\r\n    function donate() public payable {\r\n        // no-op\r\n    }\r\n\r\n    function getBlockNumber() internal view returns (uint) {\r\n        ComptrollerScenario comptrollerScenario = ComptrollerScenario(address(comptroller));\r\n        return comptrollerScenario.blockNumber();\r\n    }\r\n}\r\n"
    },
    "contracts/test/VRTConverterHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../../contracts/VRT/VRTConverter.sol\";\r\n\r\ncontract VRTConverterHarness is VRTConverter {\r\n    \r\n    constructor() VRTConverter() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    function balanceOfUser() public view returns (uint256, address) {\r\n        uint256 vrtBalanceOfUser = vrt.balanceOf(msg.sender);\r\n        return (vrtBalanceOfUser, msg.sender);\r\n    }\r\n\r\n    function setConversionRatio(uint256 _conversionRatio) public onlyAdmin {\r\n        conversionRatio = _conversionRatio;\r\n    }\r\n\r\n    function setConversionTimeline(uint256 _conversionStartTime, uint256 _conversionPeriod) public onlyAdmin {\r\n        conversionStartTime = _conversionStartTime;\r\n        conversionPeriod = _conversionPeriod;\r\n        conversionEndTime = conversionStartTime.add(conversionPeriod);\r\n    }\r\n\r\n    function getXVSRedeemedAmount(uint256 vrtAmount)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return\r\n            vrtAmount\r\n                .mul(conversionRatio)\r\n                .mul(xvsDecimalsMultiplier)\r\n                .div(1e18)\r\n                .div(vrtDecimalsMultiplier);\r\n    }\r\n}\r\n"
    },
    "contracts/test/VRTVaultHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../../contracts/VRTVault/VRTVault.sol\";\r\n\r\ncontract VRTVaultHarness is VRTVault {\r\n\r\n    uint public blockNumber;\r\n\r\n    constructor() VRTVault() public {}\r\n\r\n    function overrideInterestRatePerBlock(uint256 _interestRatePerBlock) public {\r\n        interestRatePerBlock = _interestRatePerBlock;\r\n    }\r\n\r\n    function balanceOfUser() public view returns (uint256, address) {\r\n        uint256 vrtBalanceOfUser = vrt.balanceOf(msg.sender);\r\n        return (vrtBalanceOfUser, msg.sender);\r\n    }\r\n\r\n    function harnessFastForward(uint256 blocks) public returns (uint256) {\r\n        blockNumber += blocks;\r\n        return blockNumber;\r\n    }\r\n\r\n    function setBlockNumber(uint256 number) public {\r\n        blockNumber = number;\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint256) {\r\n        return blockNumber;\r\n    }\r\n}\r\n"
    },
    "contracts/test/XVSHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Governance/XVS.sol\";\r\n\r\ncontract XVSScenario is XVS {\r\n    constructor(address account) XVS(account) public {}\r\n\r\n    function transferScenario(address[] calldata destinations, uint256 amount) external returns (bool) {\r\n        for (uint i = 0; i < destinations.length; i++) {\r\n            address dst = destinations[i];\r\n            _transferTokens(msg.sender, dst, uint96(amount));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferFromScenario(address[] calldata froms, uint256 amount) external returns (bool) {\r\n        for (uint i = 0; i < froms.length; i++) {\r\n            address from = froms[i];\r\n            _transferTokens(from, msg.sender, uint96(amount));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function generateCheckpoints(uint count, uint offset) external {\r\n        for (uint i = 1 + offset; i <= count + offset; i++) {\r\n            checkpoints[msg.sender][numCheckpoints[msg.sender]++] = Checkpoint(uint32(i), uint96(i));\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/test/XVSVestingHarness.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../../contracts/VRT/XVSVesting.sol\";\r\n\r\ncontract XVSVestingHarness is XVSVesting {\r\n\r\n   address public constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;\r\n\r\n   constructor() XVSVesting() public {\r\n      admin = msg.sender;\r\n   }\r\n\r\n   uint public blockNumber;\r\n\r\n   function recoverXVS(address recoveryAddress) public payable {\r\n      uint256 xvsBalance = xvs.balanceOf(address(this));\r\n      xvs.safeTransferFrom(address(this), recoveryAddress, xvsBalance);\r\n   }\r\n\r\n   function overWriteVRTConversionAddress() public {\r\n      vrtConversionAddress = ZERO_ADDRESS;\r\n   }\r\n\r\n   function computeWithdrawableAmount(uint256 amount, uint256 vestingStartTime, uint256 withdrawnAmount)\r\n     public view returns (uint256 vestedAmount, uint256 toWithdraw) {\r\n      (vestedAmount, toWithdraw) = super.calculateWithdrawableAmount(amount, vestingStartTime, withdrawnAmount);\r\n      return (vestedAmount, toWithdraw);\r\n   }\r\n\r\n   function computeVestedAmount(uint256 vestingAmount, uint256 vestingStartTime, uint256 currentTime)\r\n   public view returns (uint256) {\r\n      return super.calculateVestedAmount(vestingAmount, vestingStartTime, currentTime);\r\n   }\r\n\r\n   function getVestingCount(address beneficiary) view public returns(uint256) {\r\n      return vestings[beneficiary].length;\r\n   }\r\n\r\n   function getVestedAmount(address recipient) view public nonZeroAddress(recipient) returns (uint256) {\r\n\r\n      VestingRecord[] memory vestingsOfRecipient = vestings[recipient];\r\n      uint256 vestingCount = vestingsOfRecipient.length;\r\n      uint256 totalVestedAmount = 0;\r\n      uint256 currentTime = getCurrentTime();\r\n\r\n      for(uint i = 0; i < vestingCount; i++) {\r\n         VestingRecord memory vesting = vestingsOfRecipient[i];\r\n         uint256 vestedAmount = calculateVestedAmount(vesting.amount, vesting.startTime, currentTime);\r\n         totalVestedAmount = totalVestedAmount.add(vestedAmount);\r\n      }\r\n\r\n      return totalVestedAmount;\r\n   }\r\n\r\n}"
    },
    "contracts/Timelock.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract Timelock {\r\n    using SafeMath for uint;\r\n\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint indexed newDelay);\r\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\r\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\r\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n\r\n    uint public constant GRACE_PERIOD = 14 days;\r\n    uint public constant MINIMUM_DELAY = 2 days;\r\n    uint public constant MAXIMUM_DELAY = 30 days;\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint public delay;\r\n\r\n    mapping (bytes32 => bool) public queuedTransactions;\r\n\r\n\r\n    constructor(address admin_, uint delay_) public {\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n\r\n        admin = admin_;\r\n        delay = delay_;\r\n    }\r\n\r\n    function() external payable { }\r\n\r\n    function setDelay(uint delay_) public {\r\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = delay_;\r\n\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address pendingAdmin_) public {\r\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n        pendingAdmin = pendingAdmin_;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\r\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\r\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\r\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\r\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp;\r\n    }\r\n}"
    },
    "contracts/Unitroller.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\n/**\r\n * @title ComptrollerCore\r\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\r\n * VTokens should reference this contract as their comptroller.\r\n */\r\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\r\n\r\n    /**\r\n      * @notice Emitted when pendingComptrollerImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is changed\r\n      */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n      */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor() public {\r\n        // Set admin to caller\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\r\n\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\r\n        }\r\n\r\n        address oldPendingImplementation = pendingComptrollerImplementation;\r\n\r\n        pendingComptrollerImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n    */\r\n    function _acceptImplementation() public returns (uint) {\r\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\r\n        if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = comptrollerImplementation;\r\n        address oldPendingImplementation = pendingComptrollerImplementation;\r\n\r\n        comptrollerImplementation = pendingComptrollerImplementation;\r\n\r\n        pendingComptrollerImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public returns (uint) {\r\n        // Check caller is pendingAdmin\r\n        if (msg.sender != pendingAdmin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    function () external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize) }\r\n              default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n"
    },
    "contracts/Utils/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Adapted from OpenZeppelin Contracts v4.3.2 (utils/cryptography/ECDSA.sol)\r\n\r\n// SPDX-Copyright-Text: OpenZeppelin, 2021\r\n// SPDX-Copyright-Text: Venus, 2021\r\n\r\npragma solidity ^0.5.16;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\ncontract ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        } else if (error == RecoverError.InvalidSignatureV) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature` or error string. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return (address(0), RecoverError.InvalidSignatureV);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n}"
    },
    "contracts/Utils/IBEP20.sol": {
      "content": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the BEP20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {BEP20Detailed}.\r\n */\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "contracts/Utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n\r\ncontract ReentrancyGuard {\r\n    bool public _notEntered;\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n\r\n    constructor() internal {\r\n        _notEntered = true;\r\n    }\r\n}"
    },
    "contracts/Utils/SafeBEP20.sol": {
      "content": "pragma solidity ^0.5.0;\r\n\r\nimport \"./IBEP20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./Address.sol\";\r\n\r\n/**\r\n * @title SafeBEP20\r\n * @dev Wrappers around BEP20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeBEP20 for BEP20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeBEP20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IBEP20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeBEP20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeBEP20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeBEP20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeBEP20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Utils/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "contracts/Utils/WithAdmin.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n\r\ncontract WithAdmin {\r\n    /// @notice Current admin address\r\n    address public admin;\r\n\r\n    /// @notice The one who can become admin by calling _acceptAdmin\r\n    address public pendingAdmin;\r\n\r\n    /// @notice Emitted when pendingAdmin is changed\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin allowed\");\r\n        _;\r\n    }\r\n\r\n    constructor(address admin_) internal {\r\n        admin = admin_;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) external onlyAdmin {\r\n        emit NewPendingAdmin(pendingAdmin, newPendingAdmin);\r\n        pendingAdmin = newPendingAdmin;\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      */\r\n    function _acceptAdmin() external {\r\n        require(msg.sender == pendingAdmin, \"only pending admin allowed\");\r\n\r\n        emit NewPendingAdmin(pendingAdmin, address(0));\r\n        emit NewAdmin(admin, pendingAdmin);\r\n\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n}\r\n"
    },
    "contracts/VAI/lib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.5.16;\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize()                       // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller(),                            // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/VAI/VAI.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.5.16 <0.8.0;\r\n\r\nimport \"./lib.sol\";\r\n\r\ncontract VAI is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"VAI/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- BEP20 Data ---\r\n    string  public constant name     = \"VAI Stablecoin\";\r\n    string  public constant symbol   = \"VAI\";\r\n    string  public constant version  = \"1\";\r\n    uint8   public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint)                      public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n    mapping (address => uint)                      public nonces;\r\n\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"VAI math error\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"VAI math error\");\r\n    }\r\n\r\n    // --- EIP712 niceties ---\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n    constructor(uint256 chainId_) public {\r\n        wards[msg.sender] = 1;\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n            keccak256(bytes(name)),\r\n            keccak256(bytes(version)),\r\n            chainId_,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    // --- Token ---\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad, \"VAI/insufficient-balance\");\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"VAI/insufficient-allowance\");\r\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\r\n        }\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n        emit Transfer(src, dst, wad);\r\n        return true;\r\n    }\r\n    function mint(address usr, uint wad) external auth {\r\n        balanceOf[usr] = add(balanceOf[usr], wad);\r\n        totalSupply = add(totalSupply, wad);\r\n        emit Transfer(address(0), usr, wad);\r\n    }\r\n    function burn(address usr, uint wad) external {\r\n        require(balanceOf[usr] >= wad, \"VAI/insufficient-balance\");\r\n        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\r\n            require(allowance[usr][msg.sender] >= wad, \"VAI/insufficient-allowance\");\r\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\r\n        }\r\n        balanceOf[usr] = sub(balanceOf[usr], wad);\r\n        totalSupply = sub(totalSupply, wad);\r\n        emit Transfer(usr, address(0), wad);\r\n    }\r\n    function approve(address usr, uint wad) external returns (bool) {\r\n        allowance[msg.sender][usr] = wad;\r\n        emit Approval(msg.sender, usr, wad);\r\n        return true;\r\n    }\r\n\r\n    // --- Alias ---\r\n    function push(address usr, uint wad) external {\r\n        transferFrom(msg.sender, usr, wad);\r\n    }\r\n    function pull(address usr, uint wad) external {\r\n        transferFrom(usr, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) external {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    // --- Approve by signature ---\r\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\r\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\r\n    {\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH,\r\n                                     holder,\r\n                                     spender,\r\n                                     nonce,\r\n                                     expiry,\r\n                                     allowed))\r\n        ));\r\n\r\n        require(holder != address(0), \"VAI/invalid-address-0\");\r\n        require(holder == ecrecover(digest, v, r, s), \"VAI/invalid-permit\");\r\n        require(expiry == 0 || block.timestamp <= expiry, \"VAI/permit-expired\");\r\n        require(nonce == nonces[holder]++, \"VAI/invalid-nonce\");\r\n        uint wad = allowed ? uint(-1) : 0;\r\n        allowance[holder][spender] = wad;\r\n        emit Approval(holder, spender, wad);\r\n    }\r\n}\r\n"
    },
    "contracts/VAIController.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\nimport \"./PriceOracle.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./Exponential.sol\";\r\nimport \"./VAIControllerStorage.sol\";\r\nimport \"./VAIUnitroller.sol\";\r\nimport \"./VAI/VAI.sol\";\r\n\r\ninterface ComptrollerImplInterface {\r\n    function protocolPaused() external view returns (bool);\r\n    function mintedVAIs(address account) external view returns (uint);\r\n    function vaiMintRate() external view returns (uint);\r\n    function venusAccrued(address account) external view returns(uint);\r\n    function getAssetsIn(address account) external view returns (VToken[] memory);\r\n    function oracle() external view returns (PriceOracle);\r\n}\r\n\r\n/**\r\n * @title Venus's VAI Comptroller Contract\r\n * @author Venus\r\n */\r\ncontract VAIController is VAIControllerStorageG2, VAIControllerErrorReporter, Exponential {\r\n\r\n    /// @notice Emitted when Comptroller is changed\r\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\r\n\r\n    /**\r\n     * @notice Event emitted when VAI is minted\r\n     */\r\n    event MintVAI(address minter, uint mintVAIAmount);\r\n\r\n    /**\r\n     * @notice Event emitted when VAI is repaid\r\n     */\r\n    event RepayVAI(address payer, address borrower, uint repayVAIAmount);\r\n\r\n    /// @notice The initial Venus index for a market\r\n    uint224 public constant venusInitialIndex = 1e36;\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is liquidated\r\n     */\r\n    event LiquidateVAI(address liquidator, address borrower, uint repayAmount, address vTokenCollateral, uint seizeTokens);\r\n\r\n    /**\r\n     * @notice Emitted when treasury guardian is changed\r\n     */\r\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\r\n\r\n    /**\r\n     * @notice Emitted when treasury address is changed\r\n     */\r\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\r\n\r\n    /**\r\n     * @notice Emitted when treasury percent is changed\r\n     */\r\n    event NewTreasuryPercent(uint oldTreasuryPercent, uint newTreasuryPercent);\r\n\r\n    /**\r\n     * @notice Event emitted when VAIs are minted and fee are transferred\r\n     */\r\n    event MintFee(address minter, uint feeAmount);\r\n\r\n    /*** Main Actions ***/\r\n    struct MintLocalVars {\r\n        uint oErr;\r\n        MathError mathErr;\r\n        uint mintAmount;\r\n        uint accountMintVAINew;\r\n        uint accountMintableVAI;\r\n    }\r\n\r\n    function mintVAI(uint mintVAIAmount) external nonReentrant returns (uint) {\r\n        if(address(comptroller) != address(0)) {\r\n            require(mintVAIAmount > 0, \"mintVAIAmount cannt be zero\");\r\n\r\n            require(!ComptrollerImplInterface(address(comptroller)).protocolPaused(), \"protocol is paused\");\r\n\r\n            MintLocalVars memory vars;\r\n\r\n            address minter = msg.sender;\r\n\r\n            (vars.oErr, vars.accountMintableVAI) = getMintableVAI(minter);\r\n            if (vars.oErr != uint(Error.NO_ERROR)) {\r\n                return uint(Error.REJECTION);\r\n            }\r\n\r\n            // check that user have sufficient mintableVAI balance\r\n            if (mintVAIAmount > vars.accountMintableVAI) {\r\n                return fail(Error.REJECTION, FailureInfo.VAI_MINT_REJECTION);\r\n            }\r\n\r\n            (vars.mathErr, vars.accountMintVAINew) = addUInt(ComptrollerImplInterface(address(comptroller)).mintedVAIs(minter), mintVAIAmount);\r\n            require(vars.mathErr == MathError.NO_ERROR, \"VAI_MINT_AMOUNT_CALCULATION_FAILED\");\r\n            uint error = comptroller.setMintedVAIOf(minter, vars.accountMintVAINew);\r\n            if (error != 0 ) {\r\n                return error;\r\n            }\r\n\r\n            uint feeAmount;\r\n            uint remainedAmount;\r\n            vars.mintAmount = mintVAIAmount;\r\n            if (treasuryPercent != 0) {\r\n                (vars.mathErr, feeAmount) = mulUInt(vars.mintAmount, treasuryPercent);\r\n                if (vars.mathErr != MathError.NO_ERROR) {\r\n                    return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_FEE_CALCULATION_FAILED, uint(vars.mathErr));\r\n                }\r\n\r\n                (vars.mathErr, feeAmount) = divUInt(feeAmount, 1e18);\r\n                if (vars.mathErr != MathError.NO_ERROR) {\r\n                    return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_FEE_CALCULATION_FAILED, uint(vars.mathErr));\r\n                }\r\n\r\n                (vars.mathErr, remainedAmount) = subUInt(vars.mintAmount, feeAmount);\r\n                if (vars.mathErr != MathError.NO_ERROR) {\r\n                    return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_FEE_CALCULATION_FAILED, uint(vars.mathErr));\r\n                }\r\n\r\n                VAI(getVAIAddress()).mint(treasuryAddress, feeAmount);\r\n\r\n                emit MintFee(minter, feeAmount);\r\n            } else {\r\n                remainedAmount = vars.mintAmount;\r\n            }\r\n\r\n            VAI(getVAIAddress()).mint(minter, remainedAmount);\r\n\r\n            emit MintVAI(minter, remainedAmount);\r\n\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Repay VAI\r\n     */\r\n    function repayVAI(uint repayVAIAmount) external nonReentrant returns (uint, uint) {\r\n        if(address(comptroller) != address(0)) {\r\n            require(repayVAIAmount > 0, \"repayVAIAmount cannt be zero\");\r\n\r\n            require(!ComptrollerImplInterface(address(comptroller)).protocolPaused(), \"protocol is paused\");\r\n\r\n            address payer = msg.sender;\r\n\r\n            return repayVAIFresh(msg.sender, msg.sender, repayVAIAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Repay VAI Internal\r\n     * @notice Borrowed VAIs are repaid by another user (possibly the borrower).\r\n     * @param payer the account paying off the VAI\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount the amount of VAI being returned\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayVAIFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\r\n        uint actualBurnAmount;\r\n\r\n        uint vaiBalanceBorrower = ComptrollerImplInterface(address(comptroller)).mintedVAIs(borrower);\r\n\r\n        if(vaiBalanceBorrower > repayAmount) {\r\n            actualBurnAmount = repayAmount;\r\n        } else {\r\n            actualBurnAmount = vaiBalanceBorrower;\r\n        }\r\n\r\n        MathError mErr;\r\n        uint accountVAINew;\r\n\r\n        VAI(getVAIAddress()).burn(payer, actualBurnAmount);\r\n\r\n        (mErr, accountVAINew) = subUInt(vaiBalanceBorrower, actualBurnAmount);\r\n        require(mErr == MathError.NO_ERROR, \"VAI_BURN_AMOUNT_CALCULATION_FAILED\");\r\n\r\n        uint error = comptroller.setMintedVAIOf(borrower, accountVAINew);\r\n        if (error != 0) {\r\n            return (error, 0);\r\n        }\r\n        emit RepayVAI(payer, borrower, actualBurnAmount);\r\n\r\n        return (uint(Error.NO_ERROR), actualBurnAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the vai minters collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of vai to be liquidated\r\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function liquidateVAI(address borrower, uint repayAmount, VTokenInterface vTokenCollateral) external nonReentrant returns (uint, uint) {\r\n        require(!ComptrollerImplInterface(address(comptroller)).protocolPaused(), \"protocol is paused\");\r\n\r\n        uint error = vTokenCollateral.accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\r\n            return (fail(Error(error), FailureInfo.VAI_LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\r\n        }\r\n\r\n        // liquidateVAIFresh emits borrow-specific logs on errors, so we don't need to\r\n        return liquidateVAIFresh(msg.sender, borrower, repayAmount, vTokenCollateral);\r\n    }\r\n\r\n    /**\r\n     * @notice The liquidator liquidates the borrowers collateral by repay borrowers VAI.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param liquidator The address repaying the VAI and seizing collateral\r\n     * @param borrower The borrower of this VAI to be liquidated\r\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the VAI to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment VAI.\r\n     */\r\n    function liquidateVAIFresh(address liquidator, address borrower, uint repayAmount, VTokenInterface vTokenCollateral) internal returns (uint, uint) {\r\n        if(address(comptroller) != address(0)) {\r\n            /* Fail if liquidate not allowed */\r\n            uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(vTokenCollateral), liquidator, borrower, repayAmount);\r\n            if (allowed != 0) {\r\n                return (failOpaque(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\r\n            }\r\n\r\n            /* Verify vTokenCollateral market's block number equals current block number */\r\n            //if (vTokenCollateral.accrualBlockNumber() != accrualBlockNumber) {\r\n            if (vTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\r\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\r\n            }\r\n\r\n            /* Fail if borrower = liquidator */\r\n            if (borrower == liquidator) {\r\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\r\n            }\r\n\r\n            /* Fail if repayAmount = 0 */\r\n            if (repayAmount == 0) {\r\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\r\n            }\r\n\r\n            /* Fail if repayAmount = -1 */\r\n            if (repayAmount == uint(-1)) {\r\n                return (fail(Error.REJECTION, FailureInfo.VAI_LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\r\n            }\r\n\r\n\r\n            /* Fail if repayVAI fails */\r\n            (uint repayBorrowError, uint actualRepayAmount) = repayVAIFresh(liquidator, borrower, repayAmount);\r\n            if (repayBorrowError != uint(Error.NO_ERROR)) {\r\n                return (fail(Error(repayBorrowError), FailureInfo.VAI_LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\r\n            }\r\n\r\n            /////////////////////////\r\n            // EFFECTS & INTERACTIONS\r\n            // (No safe failures beyond this point)\r\n\r\n            /* We calculate the number of collateral tokens that will be seized */\r\n            (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateVAICalculateSeizeTokens(address(vTokenCollateral), actualRepayAmount);\r\n            require(amountSeizeError == uint(Error.NO_ERROR), \"VAI_LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\r\n\r\n            /* Revert if borrower collateral token balance < seizeTokens */\r\n            require(vTokenCollateral.balanceOf(borrower) >= seizeTokens, \"VAI_LIQUIDATE_SEIZE_TOO_MUCH\");\r\n\r\n            uint seizeError;\r\n            seizeError = vTokenCollateral.seize(liquidator, borrower, seizeTokens);\r\n\r\n            /* Revert if seize tokens fails (since we cannot be sure of side effects) */\r\n            require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\r\n\r\n            /* We emit a LiquidateBorrow event */\r\n            emit LiquidateVAI(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\r\n\r\n            /* We call the defense hook */\r\n            comptroller.liquidateBorrowVerify(address(this), address(vTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\r\n\r\n            return (uint(Error.NO_ERROR), actualRepayAmount);\r\n        }\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Sets a new comptroller\r\n      * @dev Admin function to set a new comptroller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setComptroller(ComptrollerInterface comptroller_) external returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        ComptrollerInterface oldComptroller = comptroller;\r\n        comptroller = comptroller_;\r\n        emit NewComptroller(oldComptroller, comptroller_);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function _become(VAIUnitroller unitroller) external {\r\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\r\n        require(unitroller._acceptImplementation() == 0, \"change not authorized\");\r\n    }\r\n\r\n    /**\r\n     * @dev Local vars for avoiding stack-depth limits in calculating account total supply balance.\r\n     *  Note that `vTokenBalance` is the number of vTokens the account owns in the market,\r\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n     */\r\n    struct AccountAmountLocalVars {\r\n        uint oErr;\r\n        MathError mErr;\r\n        uint sumSupply;\r\n        uint sumBorrowPlusEffects;\r\n        uint vTokenBalance;\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n        uint oraclePriceMantissa;\r\n        Exp exchangeRate;\r\n        Exp oraclePrice;\r\n        Exp tokensToDenom;\r\n    }\r\n\r\n    function getMintableVAI(address minter) public view returns (uint, uint) {\r\n        PriceOracle oracle = ComptrollerImplInterface(address(comptroller)).oracle();\r\n        VToken[] memory enteredMarkets = ComptrollerImplInterface(address(comptroller)).getAssetsIn(minter);\r\n\r\n        AccountAmountLocalVars memory vars; // Holds all our calculation results\r\n\r\n        uint accountMintableVAI;\r\n        uint i;\r\n\r\n        /**\r\n         * We use this formula to calculate mintable VAI amount.\r\n         * totalSupplyAmount * VAIMintRate - (totalBorrowAmount + mintedVAIOf)\r\n         */\r\n        for (i = 0; i < enteredMarkets.length; i++) {\r\n            (vars.oErr, vars.vTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = enteredMarkets[i].getAccountSnapshot(minter);\r\n            if (vars.oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n                return (uint(Error.SNAPSHOT_ERROR), 0);\r\n            }\r\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\r\n\r\n            // Get the normalized price of the asset\r\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(enteredMarkets[i]);\r\n            if (vars.oraclePriceMantissa == 0) {\r\n                return (uint(Error.PRICE_ERROR), 0);\r\n            }\r\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\r\n\r\n            (vars.mErr, vars.tokensToDenom) = mulExp(vars.exchangeRate, vars.oraclePrice);\r\n            if (vars.mErr != MathError.NO_ERROR) {\r\n                return (uint(Error.MATH_ERROR), 0);\r\n            }\r\n\r\n            // sumSupply += tokensToDenom * vTokenBalance\r\n            (vars.mErr, vars.sumSupply) = mulScalarTruncateAddUInt(vars.tokensToDenom, vars.vTokenBalance, vars.sumSupply);\r\n            if (vars.mErr != MathError.NO_ERROR) {\r\n                return (uint(Error.MATH_ERROR), 0);\r\n            }\r\n\r\n            // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n            (vars.mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\r\n            if (vars.mErr != MathError.NO_ERROR) {\r\n                return (uint(Error.MATH_ERROR), 0);\r\n            }\r\n        }\r\n\r\n        (vars.mErr, vars.sumBorrowPlusEffects) = addUInt(vars.sumBorrowPlusEffects, ComptrollerImplInterface(address(comptroller)).mintedVAIs(minter));\r\n        if (vars.mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0);\r\n        }\r\n\r\n        (vars.mErr, accountMintableVAI) = mulUInt(vars.sumSupply, ComptrollerImplInterface(address(comptroller)).vaiMintRate());\r\n        require(vars.mErr == MathError.NO_ERROR, \"VAI_MINT_AMOUNT_CALCULATION_FAILED\");\r\n\r\n        (vars.mErr, accountMintableVAI) = divUInt(accountMintableVAI, 10000);\r\n        require(vars.mErr == MathError.NO_ERROR, \"VAI_MINT_AMOUNT_CALCULATION_FAILED\");\r\n\r\n\r\n        (vars.mErr, accountMintableVAI) = subUInt(accountMintableVAI, vars.sumBorrowPlusEffects);\r\n        if (vars.mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.REJECTION), 0);\r\n        }\r\n\r\n        return (uint(Error.NO_ERROR), accountMintableVAI);\r\n    }\r\n\r\n    function _setTreasuryData(address newTreasuryGuardian, address newTreasuryAddress, uint newTreasuryPercent) external returns (uint) {\r\n        // Check caller is admin\r\n        if (!(msg.sender == admin || msg.sender == treasuryGuardian)) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_TREASURY_OWNER_CHECK);\r\n        }\r\n\r\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\r\n\r\n        address oldTreasuryGuardian = treasuryGuardian;\r\n        address oldTreasuryAddress = treasuryAddress;\r\n        uint oldTreasuryPercent = treasuryPercent;\r\n\r\n        treasuryGuardian = newTreasuryGuardian;\r\n        treasuryAddress = newTreasuryAddress;\r\n        treasuryPercent = newTreasuryPercent;\r\n\r\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\r\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\r\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the address of the VAI token\r\n     * @return The address of VAI\r\n     */\r\n    function getVAIAddress() public view returns (address) {\r\n        return 0x4BD17003473389A42DAF6a0a729f6Fdb328BbBd7;\r\n    }\r\n\r\n    function initialize() onlyAdmin public {\r\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\r\n        _notEntered = true;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    /*** Reentrancy Guard ***/\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n}\r\n"
    },
    "contracts/VAIControllerInterface.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\n\r\ncontract VAIControllerInterface {\r\n    function getVAIAddress() public view returns (address);\r\n    function getMintableVAI(address minter) public view returns (uint, uint);\r\n    function mintVAI(address minter, uint mintVAIAmount) external returns (uint);\r\n    function repayVAI(address repayer, uint repayVAIAmount) external returns (uint);\r\n    function liquidateVAI(address borrower, uint repayAmount, VTokenInterface vTokenCollateral) external returns (uint, uint);\r\n\r\n    function _initializeVenusVAIState(uint blockNumber) external returns (uint);\r\n    function updateVenusVAIMintIndex() external returns (uint);\r\n    function calcDistributeVAIMinterVenus(address vaiMinter) external returns(uint, uint, uint, uint);\r\n}\r\n"
    },
    "contracts/VAIControllerStorage.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./ComptrollerInterface.sol\";\r\n\r\ncontract VAIUnitrollerAdminStorage {\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active brains of Unitroller\r\n    */\r\n    address public vaiControllerImplementation;\r\n\r\n    /**\r\n    * @notice Pending brains of Unitroller\r\n    */\r\n    address public pendingVAIControllerImplementation;\r\n}\r\n\r\ncontract VAIControllerStorageG1 is VAIUnitrollerAdminStorage {\r\n    ComptrollerInterface public comptroller;\r\n\r\n    struct VenusVAIState {\r\n        /// @notice The last updated venusVAIMintIndex\r\n        uint224 index;\r\n\r\n        /// @notice The block number the index was last updated at\r\n        uint32 block;\r\n    }\r\n\r\n    /// @notice The Venus VAI state\r\n    VenusVAIState public venusVAIState;\r\n\r\n    /// @notice The Venus VAI state initialized\r\n    bool public isVenusVAIInitialized;\r\n\r\n    /// @notice The Venus VAI minter index as of the last time they accrued XVS\r\n    mapping(address => uint) public venusVAIMinterIndex;\r\n}\r\n\r\ncontract VAIControllerStorageG2 is VAIControllerStorageG1 {\r\n    /// @notice Treasury Guardian address\r\n    address public treasuryGuardian;\r\n\r\n    /// @notice Treasury address\r\n    address public treasuryAddress;\r\n\r\n    /// @notice Fee percent of accrued interest with decimal 18\r\n    uint256 public treasuryPercent;\r\n\r\n    /// @notice Guard variable for re-entrancy checks\r\n    bool internal _notEntered;\r\n}\r\n"
    },
    "contracts/VAIUnitroller.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./VAIControllerStorage.sol\";\r\n\r\ncontract VAIUnitroller is VAIUnitrollerAdminStorage, VAIControllerErrorReporter {\r\n\r\n    /**\r\n      * @notice Emitted when pendingVAIControllerImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingVAIControllerImplementation is accepted, which means comptroller implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is changed\r\n      */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n      */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor() public {\r\n        // Set admin to caller\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\r\n\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\r\n        }\r\n\r\n        address oldPendingImplementation = pendingVAIControllerImplementation;\r\n\r\n        pendingVAIControllerImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingVAIControllerImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n    */\r\n    function _acceptImplementation() public returns (uint) {\r\n        // Check caller is pendingImplementation\r\n        if (msg.sender != pendingVAIControllerImplementation) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = vaiControllerImplementation;\r\n        address oldPendingImplementation = pendingVAIControllerImplementation;\r\n\r\n        vaiControllerImplementation = pendingVAIControllerImplementation;\r\n\r\n        pendingVAIControllerImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, vaiControllerImplementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingVAIControllerImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public returns (uint) {\r\n        // Check caller is pendingAdmin\r\n        if (msg.sender != pendingAdmin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    function () external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = vaiControllerImplementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize) }\r\n              default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Vault/VAIVault.sol": {
      "content": "pragma solidity ^0.5.16;\r\nimport \"../Utils/SafeBEP20.sol\";\r\nimport \"../Utils/IBEP20.sol\";\r\nimport \"./VAIVaultProxy.sol\";\r\nimport \"./VAIVaultStorage.sol\";\r\nimport \"./VAIVaultErrorReporter.sol\";\r\n\r\ncontract VAIVault is VAIVaultStorage {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    /// @notice Event emitted when VAI deposit\r\n    event Deposit(address indexed user, uint256 amount);\r\n\r\n    /// @notice Event emitted when VAI withrawal\r\n    event Withdraw(address indexed user, uint256 amount);\r\n\r\n    /// @notice Event emitted when admin changed\r\n    event AdminTransfered(address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    /*** Reentrancy Guard ***/\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit VAI to VAIVault for XVS allocation\r\n     * @param _amount The amount to deposit to vault\r\n     */\r\n    function deposit(uint256 _amount) public nonReentrant {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n\r\n        updateVault();\r\n\r\n        // Transfer pending tokens to user\r\n        updateAndPayOutPending(msg.sender);\r\n\r\n        // Transfer in the amounts from user\r\n        if(_amount > 0) {\r\n            vai.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            user.amount = user.amount.add(_amount);\r\n        }\r\n\r\n        user.rewardDebt = user.amount.mul(accXVSPerShare).div(1e18);\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw VAI from VAIVault\r\n     * @param _amount The amount to withdraw from vault\r\n     */\r\n    function withdraw(uint256 _amount) public nonReentrant {\r\n        _withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim XVS from VAIVault\r\n     */\r\n    function claim() public nonReentrant {\r\n        _withdraw(msg.sender, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Low level withdraw function\r\n     * @param account The account to withdraw from vault\r\n     * @param _amount The amount to withdraw from vault\r\n     */\r\n    function _withdraw(address account, uint256 _amount) internal {\r\n        UserInfo storage user = userInfo[account];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n\r\n        updateVault();\r\n        updateAndPayOutPending(account); // Update balances of account this is not withdrawal but claiming XVS farmed\r\n\r\n        if(_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            vai.safeTransfer(address(account), _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(accXVSPerShare).div(1e18);\r\n\r\n        emit Withdraw(account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice View function to see pending XVS on frontend\r\n     * @param _user The user to see pending XVS\r\n     */\r\n    function pendingXVS(address _user) public view returns (uint256)\r\n    {\r\n        UserInfo storage user = userInfo[_user];\r\n\r\n        return user.amount.mul(accXVSPerShare).div(1e18).sub(user.rewardDebt);\r\n    }\r\n\r\n    /**\r\n     * @notice Update and pay out pending XVS to user\r\n     * @param account The user to pay out\r\n     */\r\n    function updateAndPayOutPending(address account) internal {\r\n        uint256 pending = pendingXVS(account);\r\n\r\n        if(pending > 0) {\r\n            safeXVSTransfer(account, pending);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Safe XVS transfer function, just in case if rounding error causes pool to not have enough XVS\r\n     * @param _to The address that XVS to be transfered\r\n     * @param _amount The amount that XVS to be transfered\r\n     */\r\n    function safeXVSTransfer(address _to, uint256 _amount) internal {\r\n        uint256 xvsBal = xvs.balanceOf(address(this));\r\n\r\n        if (_amount > xvsBal) {\r\n            xvs.transfer(_to, xvsBal);\r\n            xvsBalance = xvs.balanceOf(address(this));\r\n        } else {\r\n            xvs.transfer(_to, _amount);\r\n            xvsBalance = xvs.balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Function that updates pending rewards\r\n     */\r\n    function updatePendingRewards() public {\r\n        uint256 newRewards = xvs.balanceOf(address(this)).sub(xvsBalance);\r\n\r\n        if(newRewards > 0) {\r\n            xvsBalance = xvs.balanceOf(address(this)); // If there is no change the balance didn't change\r\n            pendingRewards = pendingRewards.add(newRewards);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update reward variables to be up-to-date\r\n     */\r\n    function updateVault() internal {\r\n        uint256 vaiBalance = vai.balanceOf(address(this));\r\n        if (vaiBalance == 0) { // avoids division by 0 errors\r\n            return;\r\n        }\r\n\r\n        accXVSPerShare = accXVSPerShare.add(pendingRewards.mul(1e18).div(vaiBalance));\r\n        pendingRewards = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current admin\r\n     */\r\n    function getAdmin() public view returns (address) {\r\n        return admin;\r\n    }\r\n\r\n    /**\r\n     * @dev Burn the current admin\r\n     */\r\n    function burnAdmin() public onlyAdmin {\r\n        emit AdminTransfered(admin, address(0));\r\n        admin = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the current admin to new address\r\n     */\r\n    function setNewAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0), \"new owner is the zero address\");\r\n        emit AdminTransfered(admin, newAdmin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _become(VAIVaultProxy vaiVaultProxy) public {\r\n        require(msg.sender == vaiVaultProxy.admin(), \"only proxy admin can change brains\");\r\n        require(vaiVaultProxy._acceptImplementation() == 0, \"change not authorized\");\r\n    }\r\n\r\n    function setVenusInfo(address _xvs, address _vai) public onlyAdmin {\r\n        xvs = IBEP20(_xvs);\r\n        vai = IBEP20(_vai);\r\n\r\n        _notEntered = true;\r\n    }\r\n}\r\n"
    },
    "contracts/Vault/VAIVaultErrorReporter.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\ncontract VAIVaultErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED\r\n    }\r\n\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK\r\n    }\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n"
    },
    "contracts/Vault/VAIVaultProxy.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VAIVaultStorage.sol\";\r\nimport \"./VAIVaultErrorReporter.sol\";\r\n\r\ncontract VAIVaultProxy is VAIVaultAdminStorage, VAIVaultErrorReporter {\r\n\r\n    /**\r\n      * @notice Emitted when pendingVAIVaultImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingVAIVaultImplementation is accepted, which means VAI Vault implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is changed\r\n      */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n      */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor() public {\r\n        // Set admin to caller\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\r\n\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\r\n        }\r\n\r\n        address oldPendingImplementation = pendingVAIVaultImplementation;\r\n\r\n        pendingVAIVaultImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingVAIVaultImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation of VAI Vault. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n    */\r\n    function _acceptImplementation() public returns (uint) {\r\n        // Check caller is pendingImplementation\r\n        if (msg.sender != pendingVAIVaultImplementation) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = vaiVaultImplementation;\r\n        address oldPendingImplementation = pendingVAIVaultImplementation;\r\n\r\n        vaiVaultImplementation = pendingVAIVaultImplementation;\r\n\r\n        pendingVAIVaultImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, vaiVaultImplementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingVAIVaultImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public returns (uint) {\r\n        // Check caller is pendingAdmin\r\n        if (msg.sender != pendingAdmin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    function () external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = vaiVaultImplementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize) }\r\n              default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Vault/VAIVaultStorage.sol": {
      "content": "pragma solidity ^0.5.16;\r\nimport \"../Utils/SafeMath.sol\";\r\nimport \"../Utils/IBEP20.sol\";\r\n\r\ncontract VAIVaultAdminStorage {\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active brains of VAI Vault\r\n    */\r\n    address public vaiVaultImplementation;\r\n\r\n    /**\r\n    * @notice Pending brains of VAI Vault\r\n    */\r\n    address public pendingVAIVaultImplementation;\r\n}\r\n\r\ncontract VAIVaultStorage is VAIVaultAdminStorage {\r\n    /// @notice The XVS TOKEN!\r\n    IBEP20 public xvs;\r\n\r\n    /// @notice The VAI TOKEN!\r\n    IBEP20 public vai;\r\n\r\n    /// @notice Guard variable for re-entrancy checks\r\n    bool internal _notEntered;\r\n\r\n    /// @notice XVS balance of vault\r\n    uint256 public xvsBalance;\r\n\r\n    /// @notice Accumulated XVS per share\r\n    uint256 public accXVSPerShare;\r\n\r\n    //// pending rewards awaiting anyone to update\r\n    uint256 public pendingRewards;\r\n\r\n    /// @notice Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 rewardDebt;\r\n    }\r\n\r\n    // Info of each user that stakes tokens.\r\n    mapping(address => UserInfo) public userInfo;\r\n}\r\n"
    },
    "contracts/VBep20.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\n\r\n/**\r\n * @title Venus's VBep20 Contract\r\n * @notice VTokens which wrap an EIP-20 underlying\r\n * @author Venus\r\n */\r\ncontract VBep20 is VToken, VBep20Interface {\r\n    /**\r\n     * @notice Initialize the new money market\r\n     * @param underlying_ The address of the underlying asset\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ BEP-20 name of this token\r\n     * @param symbol_ BEP-20 symbol of this token\r\n     * @param decimals_ BEP-20 decimal precision of this token\r\n     */\r\n    function initialize(address underlying_,\r\n                        ComptrollerInterface comptroller_,\r\n                        InterestRateModel interestRateModel_,\r\n                        uint initialExchangeRateMantissa_,\r\n                        string memory name_,\r\n                        string memory symbol_,\r\n                        uint8 decimals_) public {\r\n        // VToken initialize does the bulk of the work\r\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\r\n\r\n        // Set underlying and sanity check it\r\n        underlying = underlying_;\r\n        EIP20Interface(underlying).totalSupply();\r\n    }\r\n\r\n    /*** User Interface ***/\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function mint(uint mintAmount) external returns (uint) {\r\n        (uint err,) = mintInternal(mintAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param receiver the account which is receiving the vTokens\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\r\n        (uint err,) = mintBehalfInternal(receiver, mintAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems vTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of vTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        return redeemInternal(redeemTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        return redeemUnderlyingInternal(redeemAmount);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        return borrowInternal(borrowAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrow(uint repayAmount) external returns (uint) {\r\n        (uint err,) = repayBorrowInternal(repayAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\r\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this vToken to be liquidated\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function liquidateBorrow(address borrower, uint repayAmount, VTokenInterface vTokenCollateral) external returns (uint) {\r\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, vTokenCollateral);\r\n        return err;\r\n    }\r\n\r\n    /**\r\n     * @notice The sender adds to reserves.\r\n     * @param addAmount The amount fo underlying token to add as reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _addReserves(uint addAmount) external returns (uint) {\r\n        return _addReservesInternal(addAmount);\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of the underlying\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of underlying tokens owned by this contract\r\n     */\r\n    function getCashPrior() internal view returns (uint) {\r\n        EIP20Interface token = EIP20Interface(underlying);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\r\n     *      This will revert due to insufficient balance or insufficient allowance.\r\n     *      This function returns the actual amount received,\r\n     *      which may be less than `amount` if there is a fee attached to the transfer.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard BEP-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferIn(address from, uint amount) internal returns (uint) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\r\n        token.transferFrom(from, address(this), amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                       // This is a non-standard BEP-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                      // This is a compliant BEP-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                      // This is an excessively non-compliant BEP-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\r\n\r\n        // Calculate the amount that was *actually* transferred\r\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\r\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\r\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\r\n    }\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\r\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\r\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\r\n     *      it is >= amount, this should not revert in normal conditions.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard BEP-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferOut(address payable to, uint amount) internal {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\r\n        token.transfer(to, amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      // This is a non-standard BEP-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                     // This is a complaint BEP-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                     // This is an excessively non-compliant BEP-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\r\n    }\r\n}\r\n"
    },
    "contracts/VBep20Delegate.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VBep20.sol\";\r\n\r\n/**\r\n * @title Venus's VBep20Delegate Contract\r\n * @notice VTokens which wrap an EIP-20 underlying and are delegated to\r\n * @author Venus\r\n */\r\ncontract VBep20Delegate is VBep20, VDelegateInterface {\r\n    /**\r\n     * @notice Construct an empty delegate\r\n     */\r\n    constructor() public {}\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to initialize it for duty\r\n     * @param data The encoded bytes data for any initialization\r\n     */\r\n    function _becomeImplementation(bytes memory data) public {\r\n        // Shh -- currently unused\r\n        data;\r\n\r\n        // Shh -- we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            implementation = address(0);\r\n        }\r\n\r\n        require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\r\n     */\r\n    function _resignImplementation() public {\r\n        // Shh -- we don't ever want this hook to be marked pure\r\n        if (false) {\r\n            implementation = address(0);\r\n        }\r\n\r\n        require(msg.sender == admin, \"only the admin may call _resignImplementation\");\r\n    }\r\n}\r\n"
    },
    "contracts/VBep20Delegator.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VTokenInterfaces.sol\";\r\n\r\n/**\r\n * @title Venus's VBep20Delegator Contract\r\n * @notice VTokens which wrap an EIP-20 underlying and delegate to an implementation\r\n * @author Venus\r\n */\r\ncontract VBep20Delegator is VTokenInterface, VBep20Interface, VDelegatorInterface {\r\n    /**\r\n     * @notice Construct a new money market\r\n     * @param underlying_ The address of the underlying asset\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ BEP-20 name of this token\r\n     * @param symbol_ BEP-20 symbol of this token\r\n     * @param decimals_ BEP-20 decimal precision of this token\r\n     * @param admin_ Address of the administrator of this token\r\n     * @param implementation_ The address of the implementation the contract delegates to\r\n     * @param becomeImplementationData The encoded args for becomeImplementation\r\n     */\r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_,\r\n                address implementation_,\r\n                bytes memory becomeImplementationData) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        // First delegate gets to initialize the delegator (i.e. storage contract)\r\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\r\n                                                            underlying_,\r\n                                                            comptroller_,\r\n                                                            interestRateModel_,\r\n                                                            initialExchangeRateMantissa_,\r\n                                                            name_,\r\n                                                            symbol_,\r\n                                                            decimals_));\r\n\r\n        // New implementations always get set via the settor (post-initialize)\r\n        _setImplementation(implementation_, false, becomeImplementationData);\r\n\r\n        // Set the proper admin now that initialization is done\r\n        admin = admin_;\r\n    }\r\n\r\n    /**\r\n     * @notice Called by the admin to update the implementation of the delegator\r\n     * @param implementation_ The address of the new implementation for delegation\r\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\r\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n     */\r\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\r\n        require(msg.sender == admin, \"VBep20Delegator::_setImplementation: Caller must be admin\");\r\n\r\n        if (allowResign) {\r\n            delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\r\n        }\r\n\r\n        address oldImplementation = implementation;\r\n        implementation = implementation_;\r\n\r\n        delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function mint(uint mintAmount) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"mint(uint256)\", mintAmount));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"mintBehalf(address,uint256)\", receiver, mintAmount));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems vTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of vTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeem(uint256)\", redeemTokens));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeemUnderlying(uint256)\", redeemAmount));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrow(uint repayAmount) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrow(uint256)\", repayAmount));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount The amount to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrowBehalf(address,uint256)\", borrower, repayAmount));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this vToken to be liquidated\r\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function liquidateBorrow(address borrower, uint repayAmount, VTokenInterface vTokenCollateral) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"liquidateBorrow(address,uint256,address)\", borrower, repayAmount, vTokenCollateral));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint amount) external returns (bool) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transfer(address,uint256)\", dst, amount));\r\n        return abi.decode(data, (bool));\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", src, dst, amount));\r\n        return abi.decode(data, (bool));\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param amount The number of tokens that are approved (-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount));\r\n        return abi.decode(data, (bool));\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current allowance from `owner` for `spender`\r\n     * @param owner The address of the account which owns the tokens to be spent\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @return The number of tokens allowed to be spent (-1 means infinite)\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint) {\r\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"allowance(address,address)\", owner, spender));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token balance of the `owner`\r\n     * @param owner The address of the account to query\r\n     * @return The number of tokens owned by `owner`\r\n     */\r\n    function balanceOf(address owner) external view returns (uint) {\r\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"balanceOf(address)\", owner));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying balance of the `owner`\r\n     * @dev This also accrues interest in a transaction\r\n     * @param owner The address of the account to query\r\n     * @return The amount of underlying owned by `owner`\r\n     */\r\n    function balanceOfUnderlying(address owner) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"balanceOfUnderlying(address)\", owner));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\r\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\r\n     * @param account Address of the account to snapshot\r\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\r\n     */\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\r\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getAccountSnapshot(address)\", account));\r\n        return abi.decode(data, (uint, uint, uint, uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block borrow interest rate for this vToken\r\n     * @return The borrow interest rate per block, scaled by 1e18\r\n     */\r\n    function borrowRatePerBlock() external view returns (uint) {\r\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowRatePerBlock()\"));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block supply interest rate for this vToken\r\n     * @return The supply interest rate per block, scaled by 1e18\r\n     */\r\n    function supplyRatePerBlock() external view returns (uint) {\r\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"supplyRatePerBlock()\"));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current total borrows plus accrued interest\r\n     * @return The total borrows with interest\r\n     */\r\n    function totalBorrowsCurrent() external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"totalBorrowsCurrent()\"));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\r\n     * @param account The address whose balance should be calculated after updating borrowIndex\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceCurrent(address account) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrowBalanceCurrent(address)\", account));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Return the borrow balance of account based on stored data\r\n     * @param account The address whose balance should be calculated\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceStored(address account) public view returns (uint) {\r\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowBalanceStored(address)\", account));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n   /**\r\n     * @notice Accrue interest then return the up-to-date exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateCurrent() public returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"exchangeRateCurrent()\"));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the VToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() public view returns (uint) {\r\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"exchangeRateStored()\"));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Get cash balance of this vToken in the underlying asset\r\n     * @return The quantity of underlying asset owned by this contract\r\n     */\r\n    function getCash() external view returns (uint) {\r\n        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getCash()\"));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n      * @notice Applies accrued interest to total borrows and reserves.\r\n      * @dev This calculates interest accrued from the last checkpointed block\r\n      *      up to the current block and writes new checkpoint to storage.\r\n      */\r\n    function accrueInterest() public returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"accrueInterest()\"));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers collateral tokens (this market) to the liquidator.\r\n     * @dev Will fail unless called by another vToken during the process of liquidation.\r\n     *  Its absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\r\n     * @param liquidator The account receiving seized collateral\r\n     * @param borrower The account having collateral seized\r\n     * @param seizeTokens The number of vTokens to seize\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"seize(address,address,uint256)\", liquidator, borrower, seizeTokens));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new comptroller for the market\r\n      * @dev Admin function to set a new comptroller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\r\n      * @dev Admin function to accrue interest and set a new reserve factor\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and adds reserves by transferring from admin\r\n     * @param addAmount Amount of reserves to add\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _addReserves(uint addAmount) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and reduces reserves by transferring to admin\r\n     * @param reduceAmount Amount of reduction to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _reduceReserves(uint reduceAmount) external returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\r\n     * @dev Admin function to accrue interest and update the interest rate model\r\n     * @param newInterestRateModel the new interest rate model to use\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\r\n        bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\r\n        return abi.decode(data, (uint));\r\n    }\r\n\r\n    /**\r\n     * @notice Internal method to delegate execution to another contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     * @param callee The contract to delegatecall\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to the implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\r\n        return delegateTo(implementation, data);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to an implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return abi.decode(returnData, (bytes));\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to an implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     */\r\n    function () external payable {\r\n        require(msg.value == 0,\"VBep20Delegator:fallback: cannot send value to fallback\");\r\n\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n            switch success\r\n            case 0 { revert(free_mem_ptr, returndatasize) }\r\n            default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/VBep20Immutable.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VBep20.sol\";\r\n\r\n/**\r\n * @title Venus's VBep20Immutable Contract\r\n * @notice VTokens which wrap an EIP-20 underlying and are immutable\r\n * @author Venus\r\n */\r\ncontract VBep20Immutable is VBep20 {\r\n    /**\r\n     * @notice Construct a new money market\r\n     * @param underlying_ The address of the underlying asset\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ BEP-20 name of this token\r\n     * @param symbol_ BEP-20 symbol of this token\r\n     * @param decimals_ BEP-20 decimal precision of this token\r\n     * @param admin_ Address of the administrator of this token\r\n     */\r\n    constructor(address underlying_,\r\n                ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        // Initialize the market\r\n        initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\r\n\r\n        // Set the proper admin now that initialization is done\r\n        admin = admin_;\r\n    }\r\n}\r\n"
    },
    "contracts/VBNB.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VToken.sol\";\r\n\r\n/**\r\n * @title Venus's VBNB Contract\r\n * @notice VToken which wraps BNB\r\n * @author Venus\r\n */\r\ncontract VBNB is VToken {\r\n    /**\r\n     * @notice Construct a new VBNB money market\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ BEP-20 name of this token\r\n     * @param symbol_ BEP-20 symbol of this token\r\n     * @param decimals_ BEP-20 decimal precision of this token\r\n     * @param admin_ Address of the administrator of this token\r\n     */\r\n    constructor(ComptrollerInterface comptroller_,\r\n                InterestRateModel interestRateModel_,\r\n                uint initialExchangeRateMantissa_,\r\n                string memory name_,\r\n                string memory symbol_,\r\n                uint8 decimals_,\r\n                address payable admin_) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\r\n\r\n        // Set the proper admin now that initialization is done\r\n        admin = admin_;\r\n    }\r\n\r\n\r\n    /*** User Interface ***/\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\r\n     * @dev Reverts upon any failure\r\n     */\r\n    function mint() external payable {\r\n        (uint err,) = mintInternal(msg.value);\r\n        requireNoError(err, \"mint failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems vTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of vTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) external returns (uint) {\r\n        return redeemInternal(redeemTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\r\n        return redeemUnderlyingInternal(redeemAmount);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrow(uint borrowAmount) external returns (uint) {\r\n        return borrowInternal(borrowAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @dev Reverts upon any failure\r\n     */\r\n    function repayBorrow() external payable {\r\n        (uint err,) = repayBorrowInternal(msg.value);\r\n        requireNoError(err, \"repayBorrow failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @dev Reverts upon any failure\r\n     * @param borrower the account with the debt being payed off\r\n     */\r\n    function repayBorrowBehalf(address borrower) external payable {\r\n        (uint err,) = repayBorrowBehalfInternal(borrower, msg.value);\r\n        requireNoError(err, \"repayBorrowBehalf failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @dev Reverts upon any failure\r\n     * @param borrower The borrower of this vToken to be liquidated\r\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\r\n     */\r\n    function liquidateBorrow(address borrower, VToken vTokenCollateral) external payable {\r\n        (uint err,) = liquidateBorrowInternal(borrower, msg.value, vTokenCollateral);\r\n        requireNoError(err, \"liquidateBorrow failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Send BNB to VBNB to mint\r\n     */\r\n    function () external payable {\r\n        (uint err,) = mintInternal(msg.value);\r\n        requireNoError(err, \"mint failed\");\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of BNB, before this message\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of BNB owned by this contract\r\n     */\r\n    function getCashPrior() internal view returns (uint) {\r\n        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\r\n        require(err == MathError.NO_ERROR, \"cash prior math error\");\r\n        return startingBalance;\r\n    }\r\n\r\n    /**\r\n     * @notice Perform the actual transfer in, which is a no-op\r\n     * @param from Address sending the BNB\r\n     * @param amount Amount of BNB being sent\r\n     * @return The actual amount of BNB transferred\r\n     */\r\n    function doTransferIn(address from, uint amount) internal returns (uint) {\r\n        // Sanity checks\r\n        require(msg.sender == from, \"sender mismatch\");\r\n        require(msg.value == amount, \"value mismatch\");\r\n        return amount;\r\n    }\r\n\r\n    function doTransferOut(address payable to, uint amount) internal {\r\n        /* Send the BNB, with minimal gas and revert on failure */\r\n        to.transfer(amount);\r\n    }\r\n\r\n    function requireNoError(uint errCode, string memory message) internal pure {\r\n        if (errCode == uint(Error.NO_ERROR)) {\r\n            return;\r\n        }\r\n\r\n        bytes memory fullMessage = new bytes(bytes(message).length + 5);\r\n        uint i;\r\n\r\n        for (i = 0; i < bytes(message).length; i++) {\r\n            fullMessage[i] = bytes(message)[i];\r\n        }\r\n\r\n        fullMessage[i+0] = byte(uint8(32));\r\n        fullMessage[i+1] = byte(uint8(40));\r\n        fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));\r\n        fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));\r\n        fullMessage[i+4] = byte(uint8(41));\r\n\r\n        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\r\n    }\r\n}\r\n"
    },
    "contracts/VDaiDelegate.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VBep20Delegate.sol\";\r\n\r\n/**\r\n * @title Venus's VDai Contract\r\n * @notice VToken which wraps Multi-Collateral DAI\r\n * @author Venus\r\n */\r\ncontract VDaiDelegate is VBep20Delegate {\r\n    /**\r\n     * @notice DAI adapter address\r\n     */\r\n    address public daiJoinAddress;\r\n\r\n    /**\r\n     * @notice DAI Savings Rate (DSR) pot address\r\n     */\r\n    address public potAddress;\r\n\r\n    /**\r\n     * @notice DAI vat address\r\n     */\r\n    address public vatAddress;\r\n\r\n    /**\r\n     * @notice Delegate interface to become the implementation\r\n     * @param data The encoded arguments for becoming\r\n     */\r\n    function _becomeImplementation(bytes memory data) public {\r\n        require(msg.sender == admin, \"only the admin may initialize the implementation\");\r\n\r\n        (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\r\n        return _becomeImplementation(daiJoinAddress_, potAddress_);\r\n    }\r\n\r\n    /**\r\n     * @notice Explicit interface to become the implementation\r\n     * @param daiJoinAddress_ DAI adapter address\r\n     * @param potAddress_ DAI Savings Rate (DSR) pot address\r\n     */\r\n    function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\r\n        // Get dai and vat and sanity check the underlying\r\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\r\n        PotLike pot = PotLike(potAddress_);\r\n        GemLike dai = daiJoin.dai();\r\n        VatLike vat = daiJoin.vat();\r\n        require(address(dai) == underlying, \"DAI must be the same as underlying\");\r\n\r\n        // Remember the relevant addresses\r\n        daiJoinAddress = daiJoinAddress_;\r\n        potAddress = potAddress_;\r\n        vatAddress = address(vat);\r\n\r\n        // Approve moving our DAI into the vat through daiJoin\r\n        dai.approve(daiJoinAddress, uint(-1));\r\n\r\n        // Approve the pot to transfer our funds within the vat\r\n        vat.hope(potAddress);\r\n        vat.hope(daiJoinAddress);\r\n\r\n        // Accumulate DSR interest -- must do this in order to doTransferIn\r\n        pot.drip();\r\n\r\n        // Transfer all cash in (doTransferIn does this regardless of amount)\r\n        doTransferIn(address(this), 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate interface to resign the implementation\r\n     */\r\n    function _resignImplementation() public {\r\n        require(msg.sender == admin, \"only the admin may abandon the implementation\");\r\n\r\n        // Transfer all cash out of the DSR - note that this relies on self-transfer\r\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\r\n        PotLike pot = PotLike(potAddress);\r\n        VatLike vat = VatLike(vatAddress);\r\n\r\n        // Accumulate interest\r\n        pot.drip();\r\n\r\n        // Calculate the total amount in the pot, and move it out\r\n        uint pie = pot.pie(address(this));\r\n        pot.exit(pie);\r\n\r\n        // Checks the actual balance of DAI in the vat after the pot exit\r\n        uint bal = vat.dai(address(this));\r\n\r\n        // Remove our whole balance\r\n        daiJoin.exit(address(this), bal / RAY);\r\n    }\r\n\r\n    /*** VToken Overrides ***/\r\n\r\n    /**\r\n      * @notice Accrues DSR then applies accrued interest to total borrows and reserves\r\n      * @dev This calculates interest accrued from the last checkpointed block\r\n      *      up to the current block and writes new checkpoint to storage.\r\n      */\r\n    function accrueInterest() public returns (uint) {\r\n        // Accumulate DSR interest\r\n        PotLike(potAddress).drip();\r\n\r\n        // Accumulate VToken interest\r\n        return super.accrueInterest();\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of the underlying\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of underlying tokens owned by this contract\r\n     */\r\n    function getCashPrior() internal view returns (uint) {\r\n        PotLike pot = PotLike(potAddress);\r\n        uint pie = pot.pie(address(this));\r\n        return mul(pot.chi(), pie) / RAY;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the underlying to this contract and sweep into DSR pot\r\n     * @param from Address to transfer funds from\r\n     * @param amount Amount of underlying to transfer\r\n     * @return The actual amount that is transferred\r\n     */\r\n    function doTransferIn(address from, uint amount) internal returns (uint) {\r\n        // Perform the EIP-20 transfer in\r\n        EIP20Interface token = EIP20Interface(underlying);\r\n        require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\r\n\r\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\r\n        GemLike dai = GemLike(underlying);\r\n        PotLike pot = PotLike(potAddress);\r\n        VatLike vat = VatLike(vatAddress);\r\n\r\n        // Convert all our DAI to internal DAI in the vat\r\n        daiJoin.join(address(this), dai.balanceOf(address(this)));\r\n\r\n        // Checks the actual balance of DAI in the vat after the join\r\n        uint bal = vat.dai(address(this));\r\n\r\n        // Calculate the percentage increase to th pot for the entire vat, and move it in\r\n        // Note: We may leave a tiny bit of DAI in the vat...but we do the whole thing every time\r\n        uint pie = bal / pot.chi();\r\n        pot.join(pie);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the underlying from this contract, after sweeping out of DSR pot\r\n     * @param to Address to transfer funds to\r\n     * @param amount Amount of underlying to transfer\r\n     */\r\n    function doTransferOut(address payable to, uint amount) internal {\r\n        DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\r\n        PotLike pot = PotLike(potAddress);\r\n\r\n        // Calculate the percentage decrease from the pot, and move that much out\r\n        // Note: Use a slightly larger pie size to ensure that we get at least amount in the vat\r\n        uint pie = add(mul(amount, RAY) / pot.chi(), 1);\r\n        pot.exit(pie);\r\n\r\n        daiJoin.exit(to, amount);\r\n    }\r\n\r\n    /*** Maker Internals ***/\r\n\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"add-overflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\r\n    }\r\n}\r\n\r\n/*** Maker Interfaces ***/\r\n\r\ninterface PotLike {\r\n    function chi() external view returns (uint);\r\n    function pie(address) external view returns (uint);\r\n    function drip() external returns (uint);\r\n    function join(uint) external;\r\n    function exit(uint) external;\r\n}\r\n\r\ninterface GemLike {\r\n    function approve(address, uint) external;\r\n    function balanceOf(address) external view returns (uint);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface VatLike {\r\n    function dai(address) external view returns (uint);\r\n    function hope(address) external;\r\n}\r\n\r\ninterface DaiJoinLike {\r\n    function vat() external returns (VatLike);\r\n    function dai() external returns (GemLike);\r\n    function join(address, uint) external payable;\r\n    function exit(address, uint) external;\r\n}\r\n"
    },
    "contracts/VenusChainlinkOracle.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./PriceOracle.sol\";\r\nimport \"./VBep20.sol\";\r\nimport \"./BEP20Interface.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./AggregatorV2V3Interface.sol\";\r\n\r\ncontract VenusChainlinkOracle is PriceOracle {\r\n    using SafeMath for uint;\r\n    uint public constant VAI_VALUE = 1e18;\r\n    address public admin;\r\n\r\n    uint public maxStalePeriod;\r\n\r\n    mapping(address => uint) internal prices;\r\n    mapping(bytes32 => AggregatorV2V3Interface) internal feeds;\r\n\r\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n    event FeedSet(address feed, string symbol);\r\n    event MaxStalePeriodUpdated(uint oldMaxStalePeriod, uint newMaxStalePeriod);\r\n\r\n    constructor(uint maxStalePeriod_) public {\r\n        admin = msg.sender;\r\n        maxStalePeriod = maxStalePeriod_;\r\n    }\r\n\r\n    function setMaxStalePeriod(uint newMaxStalePeriod) external onlyAdmin() {\r\n        require(newMaxStalePeriod > 0, \"stale period can't be zero\");\r\n        uint oldMaxStalePeriod = maxStalePeriod;\r\n        maxStalePeriod = newMaxStalePeriod;\r\n        emit MaxStalePeriodUpdated(oldMaxStalePeriod, newMaxStalePeriod);\r\n    }\r\n\r\n    function getUnderlyingPrice(VToken vToken) public view returns (uint) {\r\n        string memory symbol = vToken.symbol();\r\n        if (compareStrings(symbol, \"vBNB\")) {\r\n            return getChainlinkPrice(getFeed(symbol));\r\n        } else if (compareStrings(symbol, \"VAI\")) {\r\n            return VAI_VALUE;\r\n        } else if (compareStrings(symbol, \"XVS\")) {\r\n            return prices[address(vToken)];\r\n        } else {\r\n            return getPrice(vToken);\r\n        }\r\n    }\r\n\r\n    function getPrice(VToken vToken) internal view returns (uint price) {\r\n        BEP20Interface token = BEP20Interface(VBep20(address(vToken)).underlying());\r\n\r\n        if (prices[address(token)] != 0) {\r\n            price = prices[address(token)];\r\n        } else {\r\n            price = getChainlinkPrice(getFeed(token.symbol()));\r\n        }\r\n\r\n        uint decimalDelta = uint(18).sub(uint(token.decimals()));\r\n        // Ensure that we don't multiply the result by 0\r\n        if (decimalDelta > 0) {\r\n            return price.mul(10**decimalDelta);\r\n        } else {\r\n            return price;\r\n        }\r\n    }\r\n\r\n    function getChainlinkPrice(AggregatorV2V3Interface feed) internal view returns (uint) {\r\n        // Chainlink USD-denominated feeds store answers at 8 decimals\r\n        uint decimalDelta = uint(18).sub(feed.decimals());\r\n\r\n        (, int256 answer,, uint256 updatedAt,) = feed.latestRoundData();\r\n        // Ensure that we don't multiply the result by 0\r\n        if (block.timestamp.sub(updatedAt) > maxStalePeriod) {\r\n            return 0;\r\n        }\r\n\r\n        if (decimalDelta > 0) {\r\n            return uint(answer).mul(10**decimalDelta);\r\n        } else {\r\n            return uint(answer);\r\n        }\r\n    }\r\n\r\n    function setUnderlyingPrice(VToken vToken, uint underlyingPriceMantissa) external onlyAdmin() {\r\n        address asset = address(VBep20(address(vToken)).underlying());\r\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\r\n        prices[asset] = underlyingPriceMantissa;\r\n    }\r\n\r\n    function setDirectPrice(address asset, uint price) external onlyAdmin() {\r\n        emit PricePosted(asset, prices[asset], price, price);\r\n        prices[asset] = price;\r\n    }\r\n\r\n    function setFeed(string calldata symbol, address feed) external onlyAdmin() {\r\n        require(feed != address(0) && feed != address(this), \"invalid feed address\");\r\n        emit FeedSet(feed, symbol);\r\n        feeds[keccak256(abi.encodePacked(symbol))] = AggregatorV2V3Interface(feed);\r\n    }\r\n\r\n    function getFeed(string memory symbol) public view returns (AggregatorV2V3Interface) {\r\n        return feeds[keccak256(abi.encodePacked(symbol))];\r\n    }\r\n\r\n    function assetPrices(address asset) external view returns (uint) {\r\n        return prices[asset];\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    function setAdmin(address newAdmin) external onlyAdmin() {\r\n        address oldAdmin = admin;\r\n        admin = newAdmin;\r\n\r\n        emit NewAdmin(oldAdmin, newAdmin);\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n      require(msg.sender == admin, \"only admin may call\");\r\n      _;\r\n    }\r\n}\r\n"
    },
    "contracts/VenusPriceOracle.sol": {
      "content": "pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./PriceOracle.sol\";\r\nimport \"./VBep20.sol\";\r\nimport \"./BEP20Interface.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ninterface IStdReference {\r\n    /// A structure returned whenever someone requests for standard reference data.\r\n    struct ReferenceData {\r\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\r\n        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\r\n        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\r\n    }\r\n\r\n    /// Returns the price data for the given base/quote pair. Revert if not available.\r\n    function getReferenceData(string calldata _base, string calldata _quote) external view returns (ReferenceData memory);\r\n\r\n    /// Similar to getReferenceData, but with multiple base/quote pairs at once.\r\n    function getReferenceDataBulk(string[] calldata _bases, string[] calldata _quotes) external view returns (ReferenceData[] memory);\r\n}\r\n\r\ncontract VenusPriceOracle is PriceOracle {\r\n    using SafeMath for uint256;\r\n    address public admin;\r\n\r\n    mapping(address => uint) prices;\r\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    IStdReference ref;\r\n\r\n    constructor(IStdReference _ref) public {\r\n        ref = _ref;\r\n        admin = msg.sender;\r\n    }\r\n\r\n    function getUnderlyingPrice(VToken vToken) public view returns (uint) {\r\n        if (compareStrings(vToken.symbol(), \"vBNB\")) {\r\n            IStdReference.ReferenceData memory data = ref.getReferenceData(\"BNB\", \"USD\");\r\n            return data.rate;\r\n        }else if (compareStrings(vToken.symbol(), \"XVS\")) {\r\n            return prices[address(vToken)];\r\n        } else {\r\n            uint256 price;\r\n            BEP20Interface token = BEP20Interface(VBep20(address(vToken)).underlying());\r\n\r\n            if(prices[address(token)] != 0) {\r\n                price = prices[address(token)];\r\n            } else {\r\n                IStdReference.ReferenceData memory data = ref.getReferenceData(token.symbol(), \"USD\");\r\n                price = data.rate;\r\n            }\r\n\r\n            uint256 defaultDecimal = 18;\r\n            uint256 tokenDecimal = uint256(token.decimals());\r\n\r\n            if(defaultDecimal == tokenDecimal) {\r\n                return price;\r\n            } else if(defaultDecimal > tokenDecimal) {\r\n                return price.mul(10**(defaultDecimal.sub(tokenDecimal)));\r\n            } else {\r\n                return price.div(10**(tokenDecimal.sub(defaultDecimal)));\r\n            }\r\n        }\r\n    }\r\n\r\n    function setUnderlyingPrice(VToken vToken, uint underlyingPriceMantissa) public {\r\n        require(msg.sender == admin, \"only admin can set underlying price\");\r\n        address asset = address(VBep20(address(vToken)).underlying());\r\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\r\n        prices[asset] = underlyingPriceMantissa;\r\n    }\r\n\r\n    function setDirectPrice(address asset, uint price) public {\r\n        require(msg.sender == admin, \"only admin can set price\");\r\n        emit PricePosted(asset, prices[asset], price, price);\r\n        prices[asset] = price;\r\n    }\r\n\r\n    function assetPrices(address asset) external view returns (uint) {\r\n        return prices[asset];\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    function setAdmin(address newAdmin) external {\r\n        require(msg.sender == admin, \"only admin can set new admin\");\r\n        address oldAdmin = admin;\r\n        admin = newAdmin;\r\n\r\n        emit NewAdmin(oldAdmin, newAdmin);\r\n    }\r\n}\r\n"
    },
    "contracts/VRT/IXVSVesting.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\ninterface IXVSVesting {\r\n\r\n    /// @param _recipient Address of the Vesting. recipient entitled to claim the vested funds\r\n    /// @param _amount Total number of tokens Vested\r\n    function deposit(address _recipient, uint256 _amount) external;\r\n}"
    },
    "contracts/VRT/VRTConverter.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Utils/IBEP20.sol\";\r\nimport \"../Utils/SafeBEP20.sol\";\r\nimport \"./IXVSVesting.sol\";\r\nimport \"./VRTConverterStorage.sol\";\r\nimport \"./VRTConverterProxy.sol\";\r\n\r\n/**\r\n * @title Venus's VRTConversion Contract\r\n * @author Venus\r\n */\r\ncontract VRTConverter is VRTConverterStorage {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    address public constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    /// @notice decimal precision for VRT\r\n    uint256 public constant vrtDecimalsMultiplier = 1e18;\r\n\r\n    /// @notice decimal precision for XVS\r\n    uint256 public constant xvsDecimalsMultiplier = 1e18;\r\n\r\n    /// @notice Emitted when an admin set conversion info\r\n    event ConversionInfoSet(uint256 conversionRatio, uint256 conversionStartTime, uint256 conversionPeriod, uint256 conversionEndTime);\r\n\r\n    /// @notice Emitted when token conversion is done\r\n    event TokenConverted(address reedeemer, address vrtAddress, uint256 vrtAmount, address xvsAddress, uint256 xvsAmount);\r\n\r\n    /// @notice Emitted when an admin withdraw converted token\r\n    event TokenWithdraw(address token, address to, uint256 amount);\r\n\r\n    /// @notice Emitted when XVSVestingAddress is set\r\n    event XVSVestingSet(address xvsVestingAddress);\r\n\r\n    constructor() public {}\r\n\r\n    function initialize(address _vrtAddress,\r\n                address _xvsAddress,\r\n                uint256 _conversionRatio,\r\n                uint256 _conversionStartTime,\r\n                uint256 _conversionPeriod) public {\r\n        require(msg.sender == admin, \"only admin may initialize the VRTConverter\");\r\n        require(initialized == false, \"VRTConverter is already initialized\");\r\n\r\n        require(_vrtAddress != address(0), \"vrtAddress cannot be Zero\");\r\n        vrt = IBEP20(_vrtAddress);\r\n        \r\n        require(_xvsAddress != address(0), \"xvsAddress cannot be Zero\");\r\n        xvs = IBEP20(_xvsAddress);\r\n        \r\n        require(_conversionRatio > 0, \"conversionRatio cannot be Zero\");\r\n        conversionRatio = _conversionRatio;\r\n\r\n        require(_conversionStartTime >= block.timestamp, \"conversionStartTime must be time in the future\");\r\n        require(_conversionPeriod > 0, \"_conversionPeriod is invalid\");\r\n\r\n        conversionStartTime = _conversionStartTime;\r\n        conversionPeriod = _conversionPeriod;\r\n        conversionEndTime = conversionStartTime.add(conversionPeriod);\r\n        emit ConversionInfoSet(conversionRatio, conversionStartTime, conversionPeriod, conversionEndTime);\r\n        \r\n        totalVrtConverted = 0;\r\n        _notEntered = true;\r\n        initialized = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n\r\n    /**\r\n     * @notice sets XVSVestingProxy Address\r\n     * @dev Note: If XVSVestingProxy is not set, then Conversion is not allowed\r\n     * @param _xvsVestingAddress The XVSVestingProxy Address\r\n     */\r\n    function setXVSVesting(address _xvsVestingAddress) public {\r\n        require(msg.sender == admin, \"only admin may initialize the Vault\");\r\n        require(_xvsVestingAddress != address(0), \"xvsVestingAddress cannot be Zero\");\r\n        xvsVesting = IXVSVesting(_xvsVestingAddress);\r\n        emit XVSVestingSet(_xvsVestingAddress);\r\n    }\r\n\r\n    modifier isInitialized() {\r\n        require(initialized == true, \"VRTConverter is not initialized\");\r\n        _;\r\n    }\r\n\r\n    function isConversionActive() public view returns(bool) {\r\n        uint256 currentTime = block.timestamp;\r\n        if(currentTime >= conversionStartTime && currentTime <= conversionEndTime){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    modifier checkForActiveConversionPeriod(){\r\n        uint256 currentTime = block.timestamp;\r\n        require(currentTime >= conversionStartTime, \"Conversion did not start yet\");\r\n        require(currentTime <= conversionEndTime, \"Conversion Period Ended\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroAddress(address _address) {\r\n        require(_address != address(0), \"Address cannot be Zero\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer VRT and redeem XVS\r\n     * @dev Note: If there is not enough XVS, we do not perform the conversion.\r\n     * @param vrtAmount The amount of VRT\r\n     */\r\n    function convert(uint256 vrtAmount) external isInitialized checkForActiveConversionPeriod nonReentrant\r\n    {\r\n        require(address(xvsVesting) != address(0) && address(xvsVesting) != DEAD_ADDRESS, \"XVS-Vesting Address is not set\");\r\n        require(vrtAmount > 0, \"VRT amount must be non-zero\");\r\n        totalVrtConverted = totalVrtConverted.add(vrtAmount);\r\n\r\n        uint256 redeemAmount = vrtAmount\r\n            .mul(conversionRatio)\r\n            .mul(xvsDecimalsMultiplier)\r\n            .div(1e18)\r\n            .div(vrtDecimalsMultiplier);\r\n\r\n        emit TokenConverted(msg.sender, address(vrt), vrtAmount, address(xvs), redeemAmount);\r\n        vrt.safeTransferFrom(msg.sender, DEAD_ADDRESS, vrtAmount);\r\n        xvsVesting.deposit(msg.sender, redeemAmount);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _become(VRTConverterProxy vrtConverterProxy) public {\r\n        require(msg.sender == vrtConverterProxy.admin(), \"only proxy admin can change brains\");\r\n        vrtConverterProxy._acceptImplementation();\r\n    }\r\n}"
    },
    "contracts/VRT/VRTConverterProxy.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VRTConverterStorage.sol\";\r\n\r\ncontract VRTConverterProxy is VRTConverterAdminStorage {\r\n\r\n    /**\r\n      * @notice Emitted when pendingImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingImplementation is accepted, which means VRTConverter implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n    * @notice Emitted when pendingAdmin is changed\r\n    */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n    * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n    */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor(address implementation_,\r\n                address _vrtAddress,\r\n                address _xvsAddress,\r\n                uint256 _conversionRatio,\r\n                uint256 _conversionStartTime,\r\n                uint256 _conversionPeriod) nonZeroAddress(implementation_) nonZeroAddress(_vrtAddress) nonZeroAddress(_xvsAddress) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        // New implementations always get set via the settor (post-initialize)\r\n        _setImplementation(implementation_);\r\n\r\n        // First delegate gets to initialize the delegator (i.e. storage contract)\r\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,uint256,uint256,uint256)\",\r\n                                                            _vrtAddress,\r\n                                                            _xvsAddress,\r\n                                                            _conversionRatio,\r\n                                                            _conversionStartTime,\r\n                                                            _conversionPeriod));\r\n    }\r\n\r\n    modifier nonZeroAddress(address _address) {\r\n        require(_address != address(0), \"Address cannot be Zero\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the admin to update the implementation of the delegator\r\n    * @param implementation_ The address of the new implementation for delegation\r\n    */\r\n    function _setImplementation(address implementation_) public {\r\n        require(msg.sender == admin, \"VRTConverterProxy::_setImplementation: admin only\");\r\n        require(implementation_ != address(0), \"VRTConverterProxy::_setImplementation: invalid implementation address\");\r\n\r\n        address oldImplementation = implementation;\r\n        implementation = implementation_;\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n    }\r\n\r\n    /**\r\n      * @notice Internal method to delegate execution to another contract\r\n      * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n      * @param callee The contract to delegatecall\r\n      * @param data The raw data to delegatecall\r\n      * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateTo(address callee, bytes memory data) internal nonZeroAddress(callee) returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) nonZeroAddress(newPendingImplementation) public {\r\n\r\n        require(msg.sender == admin, \"Only admin can set Pending Implementation\");\r\n\r\n        address oldPendingImplementation = pendingImplementation;\r\n\r\n        pendingImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingImplementation);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation of VRTConverter. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n    */\r\n    function _acceptImplementation() public {\r\n        // Check caller is pendingImplementation\r\n        require(msg.sender == pendingImplementation, \"only address marked as pendingImplementation can accept Implementation\");\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = implementation;\r\n        address oldPendingImplementation = pendingImplementation;\r\n\r\n        implementation = pendingImplementation;\r\n\r\n        pendingImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingImplementation);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) nonZeroAddress(newPendingAdmin) public {\r\n        // Check caller = admin\r\n        require(msg.sender == admin, \"only admin can set pending admin\");\r\n        require(newPendingAdmin != pendingAdmin , \"New pendingAdmin can not be same as the previous one\");\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public {\r\n        // Check caller is pendingAdmin\r\n        require(msg.sender == pendingAdmin, \"only address marked as pendingAdmin can accept as Admin\");\r\n        \r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    function () external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize) }\r\n              default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}"
    },
    "contracts/VRT/VRTConverterStorage.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Utils/SafeMath.sol\";\r\nimport \"../Utils/IBEP20.sol\";\r\nimport \"./IXVSVesting.sol\";\r\n\r\ncontract VRTConverterAdminStorage {\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active brains of VRTConverter\r\n    */\r\n    address public implementation;\r\n\r\n    /**\r\n    * @notice Pending brains of VRTConverter\r\n    */\r\n    address public pendingImplementation;\r\n}\r\n\r\ncontract VRTConverterStorage is VRTConverterAdminStorage {\r\n\r\n    /// @notice Guard variable for re-entrancy checks\r\n    bool public _notEntered;\r\n\r\n    /// @notice indicator to check if the contract is initialized\r\n    bool public initialized;\r\n\r\n    /// @notice The VRT TOKEN!\r\n    IBEP20 public vrt;\r\n\r\n    /// @notice The XVS TOKEN!\r\n    IBEP20 public xvs;\r\n\r\n    /// @notice XVSVesting Contract reference\r\n    IXVSVesting public xvsVesting;\r\n\r\n    /// @notice Conversion ratio from VRT to XVS with decimal 18\r\n    uint256 public conversionRatio;\r\n\r\n    /// @notice total VRT converted to XVS\r\n    uint256 public totalVrtConverted;\r\n\r\n    /// @notice Conversion Start time in EpochSeconds\r\n    uint256 public conversionStartTime;\r\n\r\n    /// @notice ConversionPeriod in Seconds\r\n    uint256 public conversionPeriod;\r\n\r\n    /// @notice Conversion End time in EpochSeconds\r\n    uint256 public conversionEndTime;\r\n}"
    },
    "contracts/VRT/XVSVesting.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Utils/IBEP20.sol\";\r\nimport \"../Utils/SafeBEP20.sol\";\r\nimport \"./XVSVestingStorage.sol\";\r\nimport \"./XVSVestingProxy.sol\";\r\n\r\n/**\r\n * @title Venus's XVSVesting Contract\r\n * @author Venus\r\n */\r\ncontract XVSVesting is XVSVestingStorage {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    /// @notice total vesting period for 1 year in seconds\r\n    uint256 constant public TOTAL_VESTING_TIME = 365 * 24 * 60 * 60;\r\n\r\n    /// @notice decimal precision for XVS\r\n    uint256 constant public xvsDecimalsMultiplier = 1e18;\r\n\r\n    /// @notice Emitted when XVSVested is claimed by recipient\r\n    event VestedTokensClaimed(address recipient, uint256 amountClaimed);\r\n\r\n    /// @notice Emitted when vrtConversionAddress is set\r\n    event VRTConversionSet(address vrtConversionAddress);\r\n\r\n    /// @notice Emitted when XVS is deposited for vesting\r\n    event XVSVested(\r\n        address indexed recipient,\r\n        uint256 startTime,\r\n        uint256 amount,\r\n        uint256 withdrawnAmount\r\n    );\r\n\r\n    /// @notice Emitted when XVS is withdrawn by recipient\r\n    event XVSWithdrawn(address recipient, uint256 amount);\r\n\r\n    modifier nonZeroAddress(address _address) {\r\n        require(_address != address(0), \"Address cannot be Zero\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {}\r\n\r\n    /**\r\n     * @notice initialize XVSVestingStorage\r\n     * @param _xvsAddress The XVSToken address\r\n     */\r\n    function initialize(address _xvsAddress) public {\r\n        require(msg.sender == admin, \"only admin may initialize the XVSVesting\");\r\n        require(initialized == false, \"XVSVesting is already initialized\");\r\n        require(_xvsAddress != address(0), \"_xvsAddress cannot be Zero\");\r\n        xvs = IBEP20(_xvsAddress);\r\n\r\n        _notEntered = true;\r\n        initialized = true;\r\n    }\r\n\r\n    modifier isInitialized() {\r\n        require(initialized == true, \"XVSVesting is not initialized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice sets VRTConverter Address\r\n     * @dev Note: If VRTConverter is not set, then Vesting is not allowed\r\n     * @param _vrtConversionAddress The VRTConverterProxy Address\r\n     */\r\n    function setVRTConverter(address _vrtConversionAddress) public {\r\n        require(msg.sender == admin, \"only admin may initialize the Vault\");\r\n        require(_vrtConversionAddress != address(0), \"vrtConversionAddress cannot be Zero\");\r\n        vrtConversionAddress = _vrtConversionAddress;\r\n        emit VRTConversionSet(_vrtConversionAddress);\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyVrtConverter() {\r\n        require(\r\n            msg.sender == vrtConversionAddress,\r\n            \"only VRTConversion Address can call the function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier vestingExistCheck(address recipient) {\r\n        require(\r\n            vestings[recipient].length > 0,\r\n            \"recipient doesnot have any vestingRecord\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit XVS for Vesting\r\n     * @param recipient The vesting recipient\r\n     * @param depositAmount XVS amount for deposit\r\n     */\r\n    function deposit(address recipient, uint depositAmount) external isInitialized onlyVrtConverter\r\n        nonZeroAddress(recipient) {\r\n        require(depositAmount > 0, \"Deposit amount must be non-zero\");\r\n\r\n        VestingRecord[] storage vestingsOfRecipient = vestings[recipient];\r\n\r\n        VestingRecord memory vesting = VestingRecord({\r\n            recipient: recipient,\r\n            startTime: getCurrentTime(),\r\n            amount: depositAmount,\r\n            withdrawnAmount: 0\r\n        });\r\n\r\n        vestingsOfRecipient.push(vesting);\r\n\r\n        emit XVSVested(\r\n            recipient,\r\n            vesting.startTime,\r\n            vesting.amount,\r\n            vesting.withdrawnAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw Vested XVS of recipient\r\n     */\r\n    function withdraw() external isInitialized vestingExistCheck(msg.sender) {\r\n        address recipient = msg.sender;\r\n        VestingRecord[] storage vestingsOfRecipient = vestings[recipient];\r\n        uint256 vestingCount = vestingsOfRecipient.length;\r\n        uint256 totalWithdrawableAmount = 0;\r\n\r\n        for(uint i = 0; i < vestingCount; ++i) {\r\n            VestingRecord storage vesting = vestingsOfRecipient[i];\r\n            (uint256 vestedAmount, uint256 toWithdraw) = calculateWithdrawableAmount(vesting.amount, vesting.startTime, vesting.withdrawnAmount);\r\n            if(toWithdraw > 0){\r\n                totalWithdrawableAmount = totalWithdrawableAmount.add(toWithdraw);\r\n                vesting.withdrawnAmount = vesting.withdrawnAmount.add(toWithdraw);\r\n            }\r\n        }\r\n\r\n       if(totalWithdrawableAmount > 0){\r\n           uint256 xvsBalance = xvs.balanceOf(address(this));\r\n           require(xvsBalance >= totalWithdrawableAmount, \"Insufficient XVS for withdrawal\");\r\n           emit XVSWithdrawn(recipient, totalWithdrawableAmount);\r\n           xvs.safeTransfer(recipient, totalWithdrawableAmount);\r\n       }\r\n    }\r\n\r\n    /**\r\n     * @notice get Withdrawable XVS Amount\r\n     * @param recipient The vesting recipient\r\n     * @return A tuple with totalWithdrawableAmount , totalVestedAmount and totalWithdrawnAmount\r\n     */\r\n    function getWithdrawableAmount(address recipient) view public isInitialized nonZeroAddress(recipient) vestingExistCheck(recipient)\r\n    returns (uint256 totalWithdrawableAmount, uint256 totalVestedAmount, uint256 totalWithdrawnAmount)\r\n    {\r\n        VestingRecord[] storage vestingsOfRecipient = vestings[recipient];\r\n        uint256 vestingCount = vestingsOfRecipient.length;\r\n\r\n        for(uint i = 0; i < vestingCount; i++) {\r\n            VestingRecord storage vesting = vestingsOfRecipient[i];\r\n            (uint256 vestedAmount, uint256 toWithdraw) = calculateWithdrawableAmount(vesting.amount, vesting.startTime, vesting.withdrawnAmount);\r\n            totalVestedAmount = totalVestedAmount.add(vestedAmount);\r\n            totalWithdrawableAmount = totalWithdrawableAmount.add(toWithdraw);\r\n            totalWithdrawnAmount = totalWithdrawnAmount.add(vesting.withdrawnAmount);\r\n        }\r\n\r\n        return (totalWithdrawableAmount, totalVestedAmount, totalWithdrawnAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice get Withdrawable XVS Amount\r\n     * @param amount Amount deposited for vesting\r\n     * @param vestingStartTime time in epochSeconds at the time of vestingDeposit\r\n     * @param withdrawnAmount XVSAmount withdrawn from VestedAmount\r\n     * @return A tuple with vestedAmount and withdrawableAmount\r\n     */\r\n    function calculateWithdrawableAmount(uint256 amount, uint256 vestingStartTime, uint256 withdrawnAmount)\r\n      view internal returns (uint256, uint256) {\r\n        uint256 vestedAmount = calculateVestedAmount(amount, vestingStartTime, getCurrentTime());\r\n        uint toWithdraw = vestedAmount.sub(withdrawnAmount);\r\n        return (vestedAmount, toWithdraw);\r\n    }\r\n\r\n    /**\r\n     * @notice calculate total vested amount\r\n     * @param vestingAmount Amount deposited for vesting\r\n     * @param vestingStartTime time in epochSeconds at the time of vestingDeposit\r\n     * @param currentTime currentTime in epochSeconds\r\n     * @return Total XVS amount vested\r\n     */\r\n    function calculateVestedAmount(uint256 vestingAmount, uint256 vestingStartTime, uint256 currentTime) internal view returns (uint256) {\r\n        if (currentTime < vestingStartTime) {\r\n            return 0;\r\n        } else if (currentTime > vestingStartTime.add(TOTAL_VESTING_TIME)) {\r\n            return vestingAmount;\r\n        } else {\r\n            return (vestingAmount.mul(currentTime.sub(vestingStartTime))).div(TOTAL_VESTING_TIME);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice current block timestamp\r\n     * @return blocktimestamp\r\n     */\r\n   function getCurrentTime() public view returns (uint256) {\r\n      return block.timestamp;\r\n   }\r\n\r\n    /*** Admin Functions ***/\r\n    function _become(XVSVestingProxy xvsVestingProxy) public {\r\n        require(msg.sender == xvsVestingProxy.admin(), \"only proxy admin can change brains\");\r\n        xvsVestingProxy._acceptImplementation();\r\n    }\r\n}"
    },
    "contracts/VRT/XVSVestingProxy.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./XVSVestingStorage.sol\";\r\n\r\ncontract XVSVestingProxy is  XVSVestingAdminStorage {\r\n\r\n    /**\r\n      * @notice Emitted when pendingImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingImplementation is accepted, which means XVSVesting implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n    * @notice Emitted when pendingAdmin is changed\r\n    */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n    * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n    */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor(address implementation_,\r\n                address _xvsAddress) nonZeroAddress(implementation_) nonZeroAddress(_xvsAddress) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        // New implementations always get set via the settor (post-initialize)\r\n        _setImplementation(implementation_);\r\n\r\n        // First delegate gets to initialize the delegator (i.e. storage contract)\r\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address)\",\r\n                                                            _xvsAddress));\r\n    }\r\n\r\n    modifier nonZeroAddress(address _address) {\r\n        require(_address != address(0), \"Address cannot be Zero\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the admin to update the implementation of the delegator\r\n    * @param implementation_ The address of the new implementation for delegation\r\n    */\r\n    function _setImplementation(address implementation_) public {\r\n        require(msg.sender == admin, \"XVSVestingProxy::_setImplementation: admin only\");\r\n        require(implementation_ != address(0), \"XVSVestingProxy::_setImplementation: invalid implementation address\");\r\n\r\n        address oldImplementation = implementation;\r\n        implementation = implementation_;\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n    }\r\n\r\n    /**\r\n      * @notice Internal method to delegate execution to another contract\r\n      * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n      * @param callee The contract to delegatecall\r\n      * @param data The raw data to delegatecall\r\n      * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateTo(address callee, bytes memory data) internal nonZeroAddress(callee) returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) nonZeroAddress(newPendingImplementation) public {\r\n\r\n        require(msg.sender == admin, \"Only admin can set Pending Implementation\");\r\n\r\n        address oldPendingImplementation = pendingImplementation;\r\n\r\n        pendingImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingImplementation);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation of VRT Vault. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n    */\r\n    function _acceptImplementation() public {\r\n        // Check caller is pendingImplementation\r\n        require(msg.sender == pendingImplementation, \"only address marked as pendingImplementation can accept Implementation\");\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = implementation;\r\n        address oldPendingImplementation = pendingImplementation;\r\n\r\n        implementation = pendingImplementation;\r\n\r\n        pendingImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingImplementation);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) nonZeroAddress(newPendingAdmin) public {\r\n        // Check caller = admin\r\n        require(msg.sender == admin, \"only admin can set pending admin\");\r\n        require(newPendingAdmin != pendingAdmin , \"New pendingAdmin can not be same as the previous one\");\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public {\r\n        // Check caller is pendingAdmin\r\n        require(msg.sender == pendingAdmin, \"only address marked as pendingAdmin can accept as Admin\");\r\n        \r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    function () external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize) }\r\n              default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}"
    },
    "contracts/VRT/XVSVestingStorage.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Utils/SafeMath.sol\";\r\nimport \"../Utils/IBEP20.sol\";\r\n\r\ncontract XVSVestingAdminStorage {\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active brains of XVSVesting\r\n    */\r\n    address public implementation;\r\n\r\n    /**\r\n    * @notice Pending brains of XVSVesting\r\n    */\r\n    address public pendingImplementation;\r\n}\r\n\r\ncontract XVSVestingStorage is XVSVestingAdminStorage {\r\n\r\n    struct VestingRecord {\r\n        address recipient;\r\n        uint256 startTime;\r\n        uint256 amount;\r\n        uint256 withdrawnAmount;\r\n    }\r\n\r\n    /// @notice Guard variable for re-entrancy checks\r\n    bool public _notEntered;\r\n\r\n    /// @notice indicator to check if the contract is initialized\r\n    bool public initialized;\r\n\r\n    /// @notice The XVS TOKEN!\r\n    IBEP20 public xvs;\r\n\r\n    /// @notice VRTConversion Contract Address\r\n    address public vrtConversionAddress;\r\n\r\n    /// @notice mapping of VestingRecord(s) for user(s)\r\n    mapping(address => VestingRecord[]) public vestings;\r\n}"
    },
    "contracts/VRTVault/VRTVault.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"../Utils/SafeBEP20.sol\";\r\nimport \"../Utils/IBEP20.sol\";\r\nimport \"./VRTVaultProxy.sol\";\r\nimport \"./VRTVaultStorage.sol\";\r\n\r\ncontract VRTVault is VRTVaultStorage {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    /// @notice Event emitted when admin changed\r\n    event AdminTransfered(address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    /// @notice Event emitted when vault is paused\r\n    event VaultPaused(address indexed admin);\r\n\r\n    /// @notice Event emitted when vault is resumed after pause\r\n    event VaultResumed(address indexed admin);\r\n\r\n    /// @notice Event emitted on VRT deposit\r\n    event Deposit(address indexed user, uint256 amount);\r\n\r\n    /// @notice Event emitted when accruedInterest and VRT PrincipalAmount is withrawn\r\n    event Withdraw(address indexed user, uint256 withdrawnAmount, uint256 totalPrincipalAmount, uint256 accruedInterest);\r\n\r\n    /// @notice Event emitted when Admin withdraw BEP20 token from contract\r\n    event WithdrawToken(address indexed tokenAddress, address indexed receiver, uint256 amount);\r\n\r\n    /// @notice Event emitted when accruedInterest is claimed\r\n    event Claim(address indexed user, uint256 interestAmount);\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n    \r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin allowed\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address _vrtAddress, uint256 _interestRatePerBlock) public {\r\n        require(msg.sender == admin, \"only admin may initialize the Vault\");\r\n        require(_vrtAddress != address(0), \"vrtAddress cannot be Zero\");\r\n        require(interestRatePerBlock == 0, \"Vault may only be initialized once\");\r\n\r\n        // Set initial exchange rate\r\n        interestRatePerBlock = _interestRatePerBlock;\r\n        require(interestRatePerBlock > 0, \"interestRate Per Block must be greater than zero.\");\r\n\r\n        // Set the VRT\r\n        vrt = IBEP20(_vrtAddress);\r\n        _notEntered = true;\r\n    }\r\n\r\n    modifier isInitialized() {\r\n        require(interestRatePerBlock > 0, \"Vault is not initialized\");\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyAdmin {\r\n        require(vaultPaused == false, \"Vault is already paused\");\r\n        vaultPaused = true;\r\n        emit VaultPaused(msg.sender);\r\n    }\r\n\r\n    function resume() public onlyAdmin {\r\n        require(vaultPaused == true, \"Vault is not paused\");\r\n        vaultPaused = false;\r\n        emit VaultResumed(msg.sender);\r\n    }\r\n\r\n    modifier isActive() { \r\n        require(vaultPaused == false, \"Vault is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n\r\n    modifier nonZeroAddress(address _address) {\r\n        require(_address != address(0), \"Address cannot be Zero\");\r\n        _;\r\n    }\r\n\r\n    modifier userHasPosition(address userAddress) {\r\n        UserInfo storage user = userInfo[userAddress];\r\n        require(user.userAddress != address(0), \"User doesnot have any position in the Vault.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit VRT to VRTVault for a fixed-interest-rate\r\n     * @param depositAmount The amount to deposit to vault\r\n     */\r\n    function deposit(uint256 depositAmount) external nonReentrant isInitialized isActive {\r\n        require(depositAmount > 0, \"Deposit amount must be non-zero\");\r\n\r\n        address userAddress = msg.sender;\r\n        UserInfo storage user = userInfo[userAddress];\r\n\r\n        if(user.userAddress == address(0)){\r\n            user.userAddress = userAddress;\r\n            user.totalPrincipalAmount = depositAmount;\r\n        } else{\r\n            // accrue Interest and transfer to the user\r\n            uint256 accruedInterest = computeAccruedInterest(user.totalPrincipalAmount, user.accrualStartBlockNumber);\r\n\r\n            user.totalPrincipalAmount = user.totalPrincipalAmount.add(depositAmount);\r\n\r\n            if(accruedInterest > 0){\r\n                uint256 vrtBalance = vrt.balanceOf(address(this));\r\n                require(vrtBalance >= accruedInterest, \"Failed to transfer accruedInterest, Insufficient VRT in Vault.\");\r\n                emit Claim(userAddress, accruedInterest);\r\n                vrt.safeTransfer(user.userAddress, accruedInterest);\r\n            }\r\n        }\r\n\r\n        user.accrualStartBlockNumber = getBlockNumber();\r\n        emit Deposit(userAddress, depositAmount);\r\n        vrt.safeTransferFrom(userAddress, address(this), depositAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice get accruedInterest of the user's VRTDeposits in the Vault\r\n     * @param userAddress Address of User in the the Vault\r\n     */\r\n    function getAccruedInterest(address userAddress) public view nonZeroAddress(userAddress) isInitialized returns (uint256) {\r\n        UserInfo storage user = userInfo[userAddress];\r\n        if(user.accrualStartBlockNumber == 0){\r\n            return 0;\r\n        }\r\n\r\n        return computeAccruedInterest(user.totalPrincipalAmount, user.accrualStartBlockNumber);\r\n    }\r\n\r\n    /**\r\n     * @notice get accruedInterest of the user's VRTDeposits in the Vault\r\n     * @param totalPrincipalAmount of the User\r\n     * @param accrualStartBlockNumber of the User\r\n     */\r\n    function computeAccruedInterest(uint256 totalPrincipalAmount, uint256 accrualStartBlockNumber) isInitialized internal view returns (uint256) {\r\n        \r\n        uint256 blockNumber = getBlockNumber();\r\n\r\n        if(accrualStartBlockNumber == 0 || accrualStartBlockNumber >= blockNumber){\r\n            return 0;\r\n        }\r\n\r\n        //number of blocks Since Deposit\r\n        uint256 blockDelta = blockNumber.sub(accrualStartBlockNumber);\r\n        uint256 accruedInterest = (totalPrincipalAmount.mul(interestRatePerBlock).mul(blockDelta)).div(1e18);\r\n        return accruedInterest;\r\n    }\r\n\r\n    /**\r\n     * @notice claim the accruedInterest of the user's VRTDeposits in the Vault\r\n     */\r\n    function claim() external nonReentrant isInitialized userHasPosition(msg.sender) isActive {\r\n        address userAddress = msg.sender;\r\n        uint256 accruedInterest = getAccruedInterest(userAddress);\r\n        if(accruedInterest > 0){\r\n            UserInfo storage user = userInfo[userAddress];\r\n            uint256 vrtBalance = vrt.balanceOf(address(this));\r\n            require(vrtBalance >= accruedInterest, \"Failed to transfer VRT, Insufficient VRT in Vault.\");\r\n            emit Claim(userAddress, accruedInterest);\r\n            user.accrualStartBlockNumber = getBlockNumber();\r\n            vrt.safeTransfer(user.userAddress, accruedInterest);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw accruedInterest and totalPrincipalAmount of the user's VRTDeposit in the Vault\r\n     */\r\n    function withdraw() external nonReentrant isInitialized userHasPosition(msg.sender) isActive {\r\n        address userAddress = msg.sender;\r\n        uint256 accruedInterest = getAccruedInterest(userAddress);\r\n\r\n        UserInfo storage user = userInfo[userAddress];\r\n\r\n        uint256 totalPrincipalAmount = user.totalPrincipalAmount;\r\n        uint256 vrtForWithdrawal = accruedInterest.add(totalPrincipalAmount);\r\n        user.totalPrincipalAmount = 0;\r\n        user.accrualStartBlockNumber = getBlockNumber();\r\n\r\n        uint256 vrtBalance = vrt.balanceOf(address(this));\r\n        require(vrtBalance >= vrtForWithdrawal, \"Failed to transfer VRT, Insufficient VRT in Vault.\");\r\n\r\n        emit Withdraw(userAddress, vrtForWithdrawal, totalPrincipalAmount, accruedInterest);\r\n        vrt.safeTransfer(user.userAddress, vrtForWithdrawal);\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw BEP20 tokens from the contract to a recipient address.\r\n     * @param tokenAddress address of the BEP20 token\r\n     * @param receiver recipient of the BEP20 token\r\n     * @param amount tokenAmount\r\n     */\r\n    function withdrawBep20(address tokenAddress, address receiver, uint256 amount) onlyAdmin isInitialized nonZeroAddress(tokenAddress) nonZeroAddress(receiver) external {\r\n        require(amount > 0 , \"amount is invalid\");\r\n        IBEP20 token = IBEP20(tokenAddress);\r\n        require(amount <= token.balanceOf(address(this)), \"Insufficient amount in Vault\");\r\n        emit WithdrawToken(tokenAddress, receiver, amount);\r\n        token.safeTransfer(receiver, amount);\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _become(VRTVaultProxy vrtVaultProxy) external {\r\n        require(msg.sender == vrtVaultProxy.admin(), \"only proxy admin can change brains\");\r\n        vrtVaultProxy._acceptImplementation();\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/VRTVault/VRTVaultProxy.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VRTVaultStorage.sol\";\r\n\r\ncontract VRTVaultProxy is VRTVaultAdminStorage {\r\n\r\n    /**\r\n      * @notice Emitted when pendingImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingImplementation is accepted, which means VRT Vault implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is changed\r\n      */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n      */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor(address implementation_, address vrtAddress_, uint256 interestRatePerBlock_) public {\r\n        // Creator of the contract is admin during initialization\r\n        admin = msg.sender;\r\n\r\n        // New implementations always get set via the settor (post-initialize)\r\n        _setImplementation(implementation_);\r\n\r\n        // First delegate gets to initialize the delegator (i.e. storage contract)\r\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,uint256)\",\r\n                                                            vrtAddress_,\r\n                                                            interestRatePerBlock_));\r\n    }\r\n\r\n    \t/**\r\n     * @notice Called by the admin to update the implementation of the delegator\r\n     * @param implementation_ The address of the new implementation for delegation\r\n     */\r\n    function _setImplementation(address implementation_) public {\r\n        require(msg.sender == admin, \"VRTVaultProxy::_setImplementation: admin only\");\r\n        require(implementation_ != address(0), \"VRTVaultProxy::_setImplementation: invalid implementation address\");\r\n\r\n        address oldImplementation = implementation;\r\n        implementation = implementation_;\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n    }\r\n\r\n    /**\r\n      * @notice Internal method to delegate execution to another contract\r\n      * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n      * @param callee The contract to delegatecall\r\n      * @param data The raw data to delegatecall\r\n      * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) public {\r\n\r\n        require(msg.sender == admin, \"Only admin can set Pending Implementation\");\r\n\r\n        address oldPendingImplementation = pendingImplementation;\r\n\r\n        pendingImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingImplementation);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation of VRT Vault. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n    */\r\n    function _acceptImplementation() public {\r\n        // Check caller is pendingImplementation\r\n        require(msg.sender == pendingImplementation, \"only address marked as pendingImplementation can accept Implementation\");\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = implementation;\r\n        address oldPendingImplementation = pendingImplementation;\r\n\r\n        implementation = pendingImplementation;\r\n\r\n        pendingImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingImplementation);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) public {\r\n        // Check caller = admin\r\n        require(msg.sender == admin, \"only admin can set pending admin\");\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public {\r\n        // Check caller is pendingAdmin\r\n        require(msg.sender == pendingAdmin, \"only address marked as pendingAdmin can accept as Admin\");\r\n        \r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    function () external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize) }\r\n              default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/VRTVault/VRTVaultStorage.sol": {
      "content": "pragma solidity ^0.5.16;\r\nimport \"../Utils/SafeMath.sol\";\r\nimport \"../Utils/IBEP20.sol\";\r\n\r\ncontract VRTVaultAdminStorage {\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active brains of VRT Vault\r\n    */\r\n    address public implementation;\r\n\r\n    /**\r\n    * @notice Pending brains of VAI Vault\r\n    */\r\n    address public pendingImplementation;\r\n}\r\n\r\ncontract VRTVaultStorage is VRTVaultAdminStorage {\r\n\r\n    /// @notice Guard variable for re-entrancy checks\r\n    bool public _notEntered;\r\n\r\n    /// @notice pause indicator for Vault\r\n    bool public vaultPaused;\r\n\r\n    /// @notice The VRT TOKEN!\r\n    IBEP20 public vrt;\r\n\r\n    /// @notice interestRate for accrual - per Block\r\n    uint256 public interestRatePerBlock;\r\n\r\n    /// @notice Info of each user.\r\n    struct UserInfo {\r\n        address userAddress;\r\n        uint256 accrualStartBlockNumber;\r\n        uint256 totalPrincipalAmount;\r\n        uint256 lastWithdrawnBlockNumber;\r\n    }\r\n\r\n    // Info of each user that stakes tokens.\r\n    mapping(address => UserInfo) public userInfo;\r\n}\r\n"
    },
    "contracts/VToken.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./VTokenInterfaces.sol\";\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./Exponential.sol\";\r\nimport \"./EIP20Interface.sol\";\r\nimport \"./EIP20NonStandardInterface.sol\";\r\nimport \"./InterestRateModel.sol\";\r\n\r\n/**\r\n * @title Venus's VToken Contract\r\n * @notice Abstract base for VTokens\r\n * @author Venus\r\n */\r\ncontract VToken is VTokenInterface, Exponential, TokenErrorReporter {\r\n    /**\r\n     * @notice Initialize the money market\r\n     * @param comptroller_ The address of the Comptroller\r\n     * @param interestRateModel_ The address of the interest rate model\r\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\r\n     * @param name_ EIP-20 name of this token\r\n     * @param symbol_ EIP-20 symbol of this token\r\n     * @param decimals_ EIP-20 decimal precision of this token\r\n     */\r\n    function initialize(ComptrollerInterface comptroller_,\r\n                        InterestRateModel interestRateModel_,\r\n                        uint initialExchangeRateMantissa_,\r\n                        string memory name_,\r\n                        string memory symbol_,\r\n                        uint8 decimals_) public {\r\n        require(msg.sender == admin, \"only admin may initialize the market\");\r\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\r\n\r\n        // Set initial exchange rate\r\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\r\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\r\n\r\n        // Set the comptroller\r\n        uint err = _setComptroller(comptroller_);\r\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\r\n\r\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\r\n        accrualBlockNumber = getBlockNumber();\r\n        borrowIndex = mantissaOne;\r\n\r\n        // Set the interest rate model (depends on block number / borrow index)\r\n        err = _setInterestRateModelFresh(interestRateModel_);\r\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\r\n\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = decimals_;\r\n\r\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\r\n     * @dev Called by both `transfer` and `transferFrom` internally\r\n     * @param spender The address of the account performing the transfer\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param tokens The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\r\n        /* Fail if transfer not allowed */\r\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Do not allow self-transfers */\r\n        if (src == dst) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        /* Get the allowance, infinite for the account owner */\r\n        uint startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = uint(-1);\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n\r\n        /* Do the calculations, checking for {under,over}flow */\r\n        MathError mathErr;\r\n        uint allowanceNew;\r\n        uint srvTokensNew;\r\n        uint dstTokensNew;\r\n\r\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n        }\r\n\r\n        (mathErr, srvTokensNew) = subUInt(accountTokens[src], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\r\n        }\r\n\r\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        accountTokens[src] = srvTokensNew;\r\n        accountTokens[dst] = dstTokensNew;\r\n\r\n        /* Eat some of the allowance (if necessary) */\r\n        if (startingAllowance != uint(-1)) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        /* We emit a Transfer event */\r\n        emit Transfer(src, dst, tokens);\r\n\r\n        comptroller.transferVerify(address(this), src, dst, tokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param amount The number of tokens that are approved (-1 means infinite)\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current allowance from `owner` for `spender`\r\n     * @param owner The address of the account which owns the tokens to be spent\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @return The number of tokens allowed to be spent (-1 means infinite)\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token balance of the `owner`\r\n     * @param owner The address of the account to query\r\n     * @return The number of tokens owned by `owner`\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        return accountTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the underlying balance of the `owner`\r\n     * @dev This also accrues interest in a transaction\r\n     * @param owner The address of the account to query\r\n     * @return The amount of underlying owned by `owner`\r\n     */\r\n    function balanceOfUnderlying(address owner) external returns (uint) {\r\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\r\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\r\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\r\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\r\n     * @param account Address of the account to snapshot\r\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\r\n     */\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\r\n        uint vTokenBalance = accountTokens[account];\r\n        uint borrowBalance;\r\n        uint exchangeRateMantissa;\r\n\r\n        MathError mErr;\r\n\r\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (mErr != MathError.NO_ERROR) {\r\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\r\n        }\r\n\r\n        return (uint(Error.NO_ERROR), vTokenBalance, borrowBalance, exchangeRateMantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to simply retrieve block number\r\n     *  This exists mainly for inheriting test contracts to stub this result.\r\n     */\r\n    function getBlockNumber() internal view returns (uint) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block borrow interest rate for this vToken\r\n     * @return The borrow interest rate per block, scaled by 1e18\r\n     */\r\n    function borrowRatePerBlock() external view returns (uint) {\r\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current per-block supply interest rate for this vToken\r\n     * @return The supply interest rate per block, scaled by 1e18\r\n     */\r\n    function supplyRatePerBlock() external view returns (uint) {\r\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current total borrows plus accrued interest\r\n     * @return The total borrows with interest\r\n     */\r\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return totalBorrows;\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\r\n     * @param account The address whose balance should be calculated after updating borrowIndex\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return borrowBalanceStored(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the borrow balance of account based on stored data\r\n     * @param account The address whose balance should be calculated\r\n     * @return The calculated balance\r\n     */\r\n    function borrowBalanceStored(address account) public view returns (uint) {\r\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\r\n        require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the borrow balance of account based on stored data\r\n     * @param account The address whose balance should be calculated\r\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\r\n     */\r\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\r\n        /* Note: we do not assert that the market is up to date */\r\n        MathError mathErr;\r\n        uint principalTimesIndex;\r\n        uint result;\r\n\r\n        /* Get borrowBalance and borrowIndex */\r\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\r\n\r\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\r\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\r\n         */\r\n        if (borrowSnapshot.principal == 0) {\r\n            return (MathError.NO_ERROR, 0);\r\n        }\r\n\r\n        /* Calculate new borrow balance using the interest index:\r\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\r\n         */\r\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return (mathErr, 0);\r\n        }\r\n\r\n        return (MathError.NO_ERROR, result);\r\n    }\r\n\r\n    /**\r\n     * @notice Accrue interest then return the up-to-date exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\r\n        require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\r\n        return exchangeRateStored();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the VToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() public view returns (uint) {\r\n        (MathError err, uint result) = exchangeRateStoredInternal();\r\n        require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the VToken\r\n     * @dev This function does not accrue interest before calculating the exchange rate\r\n     * @return (error code, calculated exchange rate scaled by 1e18)\r\n     */\r\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\r\n        uint _totalSupply = totalSupply;\r\n        if (_totalSupply == 0) {\r\n            /*\r\n             * If there are no tokens minted:\r\n             *  exchangeRate = initialExchangeRate\r\n             */\r\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\r\n        } else {\r\n            /*\r\n             * Otherwise:\r\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\r\n             */\r\n            uint totalCash = getCashPrior();\r\n            uint cashPlusBorrowsMinusReserves;\r\n            Exp memory exchangeRate;\r\n            MathError mathErr;\r\n\r\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\r\n            if (mathErr != MathError.NO_ERROR) {\r\n                return (mathErr, 0);\r\n            }\r\n\r\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get cash balance of this vToken in the underlying asset\r\n     * @return The quantity of underlying asset owned by this contract\r\n     */\r\n    function getCash() external view returns (uint) {\r\n        return getCashPrior();\r\n    }\r\n\r\n    /**\r\n     * @notice Applies accrued interest to total borrows and reserves\r\n     * @dev This calculates interest accrued from the last checkpointed block\r\n     *   up to the current block and writes new checkpoint to storage.\r\n     */\r\n    function accrueInterest() public returns (uint) {\r\n        /* Remember the initial block number */\r\n        uint currentBlockNumber = getBlockNumber();\r\n        uint accrualBlockNumberPrior = accrualBlockNumber;\r\n\r\n        /* Short-circuit accumulating 0 interest */\r\n        if (accrualBlockNumberPrior == currentBlockNumber) {\r\n            return uint(Error.NO_ERROR);\r\n        }\r\n\r\n        /* Read the previous values out of storage */\r\n        uint cashPrior = getCashPrior();\r\n        uint borrowsPrior = totalBorrows;\r\n        uint reservesPrior = totalReserves;\r\n        uint borrowIndexPrior = borrowIndex;\r\n\r\n        /* Calculate the current borrow interest rate */\r\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\r\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\r\n\r\n        /* Calculate the number of blocks elapsed since the last accrual */\r\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\r\n        require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\r\n\r\n        /*\r\n         * Calculate the interest accumulated into borrows and reserves and the new index:\r\n         *  simpleInterestFactor = borrowRate * blockDelta\r\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\r\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\r\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\r\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\r\n         */\r\n\r\n        Exp memory simpleInterestFactor;\r\n        uint interestAccumulated;\r\n        uint totalBorrowsNew;\r\n        uint totalReservesNew;\r\n        uint borrowIndexNew;\r\n\r\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accrualBlockNumber = currentBlockNumber;\r\n        borrowIndex = borrowIndexNew;\r\n        totalBorrows = totalBorrowsNew;\r\n        totalReserves = totalReservesNew;\r\n\r\n        /* We emit an AccrueInterest event */\r\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives vTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n     */\r\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted mint failed\r\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\r\n        return mintFresh(msg.sender, mintAmount);\r\n    }\r\n\r\n    struct MintLocalVars {\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint mintTokens;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n        uint actualMintAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice User supplies assets into the market and receives vTokens in exchange\r\n     * @dev Assumes interest has already been accrued up to the current block\r\n     * @param minter The address of the account which is supplying the assets\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n     */\r\n    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {\r\n        /* Fail if mint not allowed */\r\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        MintLocalVars memory vars;\r\n\r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         *  We call `doTransferIn` for the minter and the mintAmount.\r\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\r\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\r\n         *  side-effects occurred. The function returns the amount actually transferred,\r\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\r\n         *  of cash.\r\n         */\r\n        vars.actualMintAmount = doTransferIn(minter, mintAmount);\r\n\r\n        /*\r\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\r\n         *  mintTokens = actualMintAmount / exchangeRate\r\n         */\r\n\r\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\r\n\r\n        /*\r\n         * We calculate the new total supply of vTokens and minter token balance, checking for overflow:\r\n         *  totalSupplyNew = totalSupply + mintTokens\r\n         *  accountTokensNew = accountTokens[minter] + mintTokens\r\n         */\r\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\r\n\r\n        /* We write previously calculated values into storage */\r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[minter] = vars.accountTokensNew;\r\n\r\n        /* We emit a Mint event, and a Transfer event */\r\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\r\n        emit Transfer(address(this), minter, vars.mintTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\r\n\r\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receiver receives vTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param receiver The address of the account which is receiving the vTokens\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n     */\r\n    function mintBehalfInternal(address receiver, uint mintAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted mintBehalf failed\r\n            return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // mintBelahfFresh emits the actual Mint event if successful and logs on errors, so we don't need to\r\n        return mintBehalfFresh(msg.sender, receiver, mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Payer supplies assets into the market and receiver receives vTokens in exchange\r\n     * @dev Assumes interest has already been accrued up to the current block\r\n     * @param payer The address of the account which is paying the underlying token\r\n     * @param receiver The address of the account which is receiving vToken\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n     */\r\n    function mintBehalfFresh(address payer, address receiver, uint mintAmount) internal returns (uint, uint) {\r\n        require(receiver != address(0), \"receiver is invalid\");\r\n        /* Fail if mint not allowed */\r\n        uint allowed = comptroller.mintAllowed(address(this), receiver, mintAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        MintLocalVars memory vars;\r\n\r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr)), 0);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         *  We call `doTransferIn` for the payer and the mintAmount.\r\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\r\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\r\n         *  side-effects occurred. The function returns the amount actually transferred,\r\n         *  in case of a fee. On success, the vToken holds an additional `actualMintAmount`\r\n         *  of cash.\r\n         */\r\n        vars.actualMintAmount = doTransferIn(payer, mintAmount);\r\n\r\n        /*\r\n         * We get the current exchange rate and calculate the number of vTokens to be minted:\r\n         *  mintTokens = actualMintAmount / exchangeRate\r\n         */\r\n\r\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\r\n\r\n        /*\r\n         * We calculate the new total supply of vTokens and receiver token balance, checking for overflow:\r\n         *  totalSupplyNew = totalSupply + mintTokens\r\n         *  accountTokensNew = accountTokens[receiver] + mintTokens\r\n         */\r\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED\");\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[receiver], vars.mintTokens);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED\");\r\n\r\n        /* We write previously calculated values into storage */\r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[receiver] = vars.accountTokensNew;\r\n\r\n        /* We emit a MintBehalf event, and a Transfer event */\r\n        emit MintBehalf(payer, receiver, vars.actualMintAmount, vars.mintTokens);\r\n        emit Transfer(address(this), receiver, vars.mintTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.mintVerify(address(this), receiver, vars.actualMintAmount, vars.mintTokens);\r\n\r\n        return (uint(Error.NO_ERROR), vars.actualMintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems vTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of vTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\r\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\r\n        return redeemFresh(msg.sender, redeemTokens, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems vTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to receive from redeeming vTokens\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\r\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\r\n        return redeemFresh(msg.sender, 0, redeemAmount);\r\n    }\r\n\r\n    struct RedeemLocalVars {\r\n        MathError mathErr;\r\n        uint exchangeRateMantissa;\r\n        uint redeemTokens;\r\n        uint redeemAmount;\r\n        uint totalSupplyNew;\r\n        uint accountTokensNew;\r\n    }\r\n\r\n    /**\r\n     * @notice User redeems vTokens in exchange for the underlying asset\r\n     * @dev Assumes interest has already been accrued up to the current block\r\n     * @param redeemer The address of the account which is redeeming the tokens\r\n     * @param redeemTokensIn The number of vTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\r\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming vTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\r\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\r\n\r\n        RedeemLocalVars memory vars;\r\n\r\n        /* exchangeRate = invoke Exchange Rate Stored() */\r\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /* If redeemTokensIn > 0: */\r\n        if (redeemTokensIn > 0) {\r\n            /*\r\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\r\n             *  redeemTokens = redeemTokensIn\r\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\r\n             */\r\n            vars.redeemTokens = redeemTokensIn;\r\n\r\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n        } else {\r\n            /*\r\n             * We get the current exchange rate and calculate the amount to be redeemed:\r\n             *  redeemTokens = redeemAmountIn / exchangeRate\r\n             *  redeemAmount = redeemAmountIn\r\n             */\r\n\r\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n\r\n            vars.redeemAmount = redeemAmountIn;\r\n        }\r\n\r\n        /* Fail if redeem not allowed */\r\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\r\n        }\r\n\r\n        /*\r\n         * We calculate the new total supply and redeemer balance, checking for underflow:\r\n         *  totalSupplyNew = totalSupply - redeemTokens\r\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\r\n         */\r\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /* Fail gracefully if protocol has insufficient cash */\r\n        if (getCashPrior() < vars.redeemAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\r\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\r\n         *  On success, the vToken has redeemAmount less of cash.\r\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         */\r\n\r\n        uint feeAmount;\r\n        uint remainedAmount;\r\n        if (IComptroller(address(comptroller)).treasuryPercent() != 0) {\r\n            (vars.mathErr, feeAmount) = mulUInt(vars.redeemAmount, IComptroller(address(comptroller)).treasuryPercent());\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_FEE_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n\r\n            (vars.mathErr, feeAmount) = divUInt(feeAmount, 1e18);\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_FEE_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n\r\n            (vars.mathErr, remainedAmount) = subUInt(vars.redeemAmount, feeAmount);\r\n            if (vars.mathErr != MathError.NO_ERROR) {\r\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_FEE_CALCULATION_FAILED, uint(vars.mathErr));\r\n            }\r\n\r\n            doTransferOut(address(uint160(IComptroller(address(comptroller)).treasuryAddress())), feeAmount);\r\n\r\n            emit RedeemFee(redeemer, feeAmount, vars.redeemTokens);\r\n        } else {\r\n            remainedAmount = vars.redeemAmount;\r\n        }\r\n\r\n        doTransferOut(redeemer, remainedAmount);\r\n\r\n        /* We write previously calculated values into storage */\r\n        totalSupply = vars.totalSupplyNew;\r\n        accountTokens[redeemer] = vars.accountTokensNew;\r\n\r\n        /* We emit a Transfer event, and a Redeem event */\r\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\r\n        emit Redeem(redeemer, remainedAmount, vars.redeemTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sender borrows assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\r\n        return borrowFresh(msg.sender, borrowAmount);\r\n    }\r\n\r\n    struct BorrowLocalVars {\r\n        MathError mathErr;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n    }\r\n\r\n    /**\r\n      * @notice Users borrow assets from the protocol to their own address\r\n      * @param borrowAmount The amount of the underlying asset to borrow\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\r\n        /* Fail if borrow not allowed */\r\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\r\n        }\r\n\r\n        /* Fail gracefully if protocol has insufficient underlying cash */\r\n        if (getCashPrior() < borrowAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        BorrowLocalVars memory vars;\r\n\r\n        /*\r\n         * We calculate the new borrower and total borrow balances, failing on overflow:\r\n         *  accountBorrowsNew = accountBorrows + borrowAmount\r\n         *  totalBorrowsNew = totalBorrows + borrowAmount\r\n         */\r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We invoke doTransferOut for the borrower and the borrowAmount.\r\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\r\n         *  On success, the vToken borrowAmount less of cash.\r\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         */\r\n        doTransferOut(borrower, borrowAmount);\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        /* We emit a Borrow event */\r\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays their own borrow\r\n     * @param repayAmount The amount to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\r\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender repays a borrow belonging to borrower\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount The amount to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\r\n            return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\r\n        }\r\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\r\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\r\n    }\r\n\r\n    struct RepayBorrowLocalVars {\r\n        Error err;\r\n        MathError mathErr;\r\n        uint repayAmount;\r\n        uint borrowerIndex;\r\n        uint accountBorrows;\r\n        uint accountBorrowsNew;\r\n        uint totalBorrowsNew;\r\n        uint actualRepayAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Borrows are repaid by another user (possibly the borrower).\r\n     * @param payer the account paying off the borrow\r\n     * @param borrower the account with the debt being payed off\r\n     * @param repayAmount the amount of undelrying tokens being returned\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\r\n        /* Fail if repayBorrow not allowed */\r\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        RepayBorrowLocalVars memory vars;\r\n\r\n        /* We remember the original borrowerIndex for verification purposes */\r\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\r\n\r\n        /* We fetch the amount the borrower owes, with accumulated interest */\r\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\r\n        if (vars.mathErr != MathError.NO_ERROR) {\r\n            return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\r\n        }\r\n\r\n        /* If repayAmount == -1, repayAmount = accountBorrows */\r\n        if (repayAmount == uint(-1)) {\r\n            vars.repayAmount = vars.accountBorrows;\r\n        } else {\r\n            vars.repayAmount = repayAmount;\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We call doTransferIn for the payer and the repayAmount\r\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\r\n         *  On success, the vToken holds an additional repayAmount of cash.\r\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         *   it returns the amount actually transferred, in case of a fee.\r\n         */\r\n        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\r\n\r\n        /*\r\n         * We calculate the new borrower and total borrow balances, failing on underflow:\r\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\r\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\r\n         */\r\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\r\n\r\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\r\n        require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = vars.totalBorrowsNew;\r\n\r\n        /* We emit a RepayBorrow event */\r\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\r\n\r\n        return (uint(Error.NO_ERROR), vars.actualRepayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice The sender liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this vToken to be liquidated\r\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function liquidateBorrowInternal(address borrower, uint repayAmount, VTokenInterface vTokenCollateral) internal nonReentrant returns (uint, uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\r\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\r\n        }\r\n\r\n        error = vTokenCollateral.accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\r\n            return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\r\n        }\r\n\r\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\r\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, vTokenCollateral);\r\n    }\r\n\r\n    /**\r\n     * @notice The liquidator liquidates the borrowers collateral.\r\n     *  The collateral seized is transferred to the liquidator.\r\n     * @param borrower The borrower of this vToken to be liquidated\r\n     * @param liquidator The address repaying the borrow and seizing collateral\r\n     * @param vTokenCollateral The market in which to seize collateral from the borrower\r\n     * @param repayAmount The amount of the underlying borrowed asset to repay\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n     */\r\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, VTokenInterface vTokenCollateral) internal returns (uint, uint) {\r\n        /* Fail if liquidate not allowed */\r\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(vTokenCollateral), liquidator, borrower, repayAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\r\n        }\r\n\r\n        /* Verify market's block number equals current block number */\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        /* Verify vTokenCollateral market's block number equals current block number */\r\n        if (vTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\r\n        }\r\n\r\n        /* Fail if borrower = liquidator */\r\n        if (borrower == liquidator) {\r\n            return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\r\n        }\r\n\r\n        /* Fail if repayAmount = 0 */\r\n        if (repayAmount == 0) {\r\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\r\n        }\r\n\r\n        /* Fail if repayAmount = -1 */\r\n        if (repayAmount == uint(-1)) {\r\n            return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\r\n        }\r\n\r\n\r\n        /* Fail if repayBorrow fails */\r\n        (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\r\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\r\n            return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /* We calculate the number of collateral tokens that will be seized */\r\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(vTokenCollateral), actualRepayAmount);\r\n        require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\r\n\r\n        /* Revert if borrower collateral token balance < seizeTokens */\r\n        require(vTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\r\n\r\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\r\n        uint seizeError;\r\n        if (address(vTokenCollateral) == address(this)) {\r\n            seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\r\n        } else {\r\n            seizeError = vTokenCollateral.seize(liquidator, borrower, seizeTokens);\r\n        }\r\n\r\n        /* Revert if seize tokens fails (since we cannot be sure of side effects) */\r\n        require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\r\n\r\n        /* We emit a LiquidateBorrow event */\r\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(vTokenCollateral), seizeTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.liquidateBorrowVerify(address(this), address(vTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\r\n\r\n        return (uint(Error.NO_ERROR), actualRepayAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers collateral tokens (this market) to the liquidator.\r\n     * @dev Will fail unless called by another vToken during the process of liquidation.\r\n     *  Its absolutely critical to use msg.sender as the borrowed vToken and not a parameter.\r\n     * @param liquidator The account receiving seized collateral\r\n     * @param borrower The account having collateral seized\r\n     * @param seizeTokens The number of vTokens to seize\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\r\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers collateral tokens (this market) to the liquidator.\r\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another VToken.\r\n     *  Its absolutely critical to use msg.sender as the seizer vToken and not a parameter.\r\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed vToken)\r\n     * @param liquidator The account receiving seized collateral\r\n     * @param borrower The account having collateral seized\r\n     * @param seizeTokens The number of vTokens to seize\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {\r\n        /* Fail if seize not allowed */\r\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\r\n        if (allowed != 0) {\r\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\r\n        }\r\n\r\n        /* Fail if borrower = liquidator */\r\n        if (borrower == liquidator) {\r\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\r\n        }\r\n\r\n        MathError mathErr;\r\n        uint borrowerTokensNew;\r\n        uint liquidatorTokensNew;\r\n\r\n        /*\r\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\r\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\r\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\r\n         */\r\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\r\n        if (mathErr != MathError.NO_ERROR) {\r\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /* We write the previously calculated values into storage */\r\n        accountTokens[borrower] = borrowerTokensNew;\r\n        accountTokens[liquidator] = liquidatorTokensNew;\r\n\r\n        /* Emit a Transfer event */\r\n        emit Transfer(borrower, liquidator, seizeTokens);\r\n\r\n        /* We call the defense hook */\r\n        comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() external returns (uint) {\r\n        // Check caller is pendingAdmin\r\n        if (msg.sender != pendingAdmin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new comptroller for the market\r\n      * @dev Admin function to set a new comptroller\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\r\n        }\r\n\r\n        ComptrollerInterface oldComptroller = comptroller;\r\n        // Ensure invoke comptroller.isComptroller() returns true\r\n        require(newComptroller.isComptroller(), \"marker method returned false\");\r\n\r\n        // Set market's comptroller to newComptroller\r\n        comptroller = newComptroller;\r\n\r\n        // Emit NewComptroller(oldComptroller, newComptroller)\r\n        emit NewComptroller(oldComptroller, newComptroller);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\r\n      * @dev Admin function to accrue interest and set a new reserve factor\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\r\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\r\n        return _setReserveFactorFresh(newReserveFactorMantissa);\r\n    }\r\n\r\n    /**\r\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\r\n      * @dev Admin function to set a new reserve factor\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\r\n        }\r\n\r\n        // Verify market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\r\n        }\r\n\r\n        // Check newReserveFactor ≤ maxReserveFactor\r\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\r\n        }\r\n\r\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\r\n        reserveFactorMantissa = newReserveFactorMantissa;\r\n\r\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Accrues interest and adds reserves by transferring from msg.sender\r\n     * @param addAmount Amount of addition to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\r\n            return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\r\n        }\r\n\r\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\r\n        (error, ) = _addReservesFresh(addAmount);\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * @notice Add reserves by transferring from caller\r\n     * @dev Requires fresh interest accrual\r\n     * @param addAmount Amount of addition to reserves\r\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\r\n     */\r\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\r\n        // totalReserves + actualAddAmount\r\n        uint totalReservesNew;\r\n        uint actualAddAmount;\r\n\r\n        // We fail gracefully unless market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        /*\r\n         * We call doTransferIn for the caller and the addAmount\r\n         *  Note: The vToken must handle variations between BEP-20 and BNB underlying.\r\n         *  On success, the vToken holds an additional addAmount of cash.\r\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n         *  it returns the amount actually transferred, in case of a fee.\r\n         */\r\n\r\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\r\n\r\n        totalReservesNew = totalReserves + actualAddAmount;\r\n\r\n        /* Revert on overflow */\r\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\r\n\r\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\r\n        totalReserves = totalReservesNew;\r\n\r\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\r\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\r\n\r\n        /* Return (NO_ERROR, actualAddAmount) */\r\n        return (uint(Error.NO_ERROR), actualAddAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Accrues interest and reduces reserves by transferring to admin\r\n     * @param reduceAmount Amount of reduction to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\r\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\r\n        return _reduceReservesFresh(reduceAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Reduces reserves by transferring to admin\r\n     * @dev Requires fresh interest accrual\r\n     * @param reduceAmount Amount of reduction to reserves\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\r\n        // totalReserves - reduceAmount\r\n        uint totalReservesNew;\r\n\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\r\n        }\r\n\r\n        // We fail gracefully unless market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\r\n        }\r\n\r\n        // Fail gracefully if protocol has insufficient underlying cash\r\n        if (getCashPrior() < reduceAmount) {\r\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\r\n        }\r\n\r\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\r\n        if (reduceAmount > totalReserves) {\r\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\r\n        }\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        totalReservesNew = totalReserves - reduceAmount;\r\n\r\n        // Store reserves[n+1] = reserves[n] - reduceAmount\r\n        totalReserves = totalReservesNew;\r\n\r\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n        doTransferOut(admin, reduceAmount);\r\n\r\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\r\n     * @dev Admin function to accrue interest and update the interest rate model\r\n     * @param newInterestRateModel the new interest rate model to use\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\r\n        uint error = accrueInterest();\r\n        if (error != uint(Error.NO_ERROR)) {\r\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\r\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\r\n        }\r\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\r\n        return _setInterestRateModelFresh(newInterestRateModel);\r\n    }\r\n\r\n    /**\r\n     * @notice updates the interest rate model (*requires fresh interest accrual)\r\n     * @dev Admin function to update the interest rate model\r\n     * @param newInterestRateModel the new interest rate model to use\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\r\n\r\n        // Used to store old model for use in the event that is emitted on success\r\n        InterestRateModel oldInterestRateModel;\r\n\r\n        // Check caller is admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\r\n        }\r\n\r\n        // We fail gracefully unless market's block number equals current block number\r\n        if (accrualBlockNumber != getBlockNumber()) {\r\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\r\n        }\r\n\r\n        // Track the market's current interest rate model\r\n        oldInterestRateModel = interestRateModel;\r\n\r\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\r\n        require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\r\n\r\n        // Set the interest rate model to newInterestRateModel\r\n        interestRateModel = newInterestRateModel;\r\n\r\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\r\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @notice Gets balance of this contract in terms of the underlying\r\n     * @dev This excludes the value of the current message, if any\r\n     * @return The quantity of underlying owned by this contract\r\n     */\r\n    function getCashPrior() internal view returns (uint);\r\n\r\n    /**\r\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\r\n     *  This may revert due to insufficient balance or insufficient allowance.\r\n     */\r\n    function doTransferIn(address from, uint amount) internal returns (uint);\r\n\r\n    /**\r\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\r\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\r\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\r\n     */\r\n    function doTransferOut(address payable to, uint amount) internal;\r\n\r\n\r\n    /*** Reentrancy Guard ***/\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n}\r\n"
    },
    "contracts/VTokenInterfaces.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./InterestRateModel.sol\";\r\n\r\ncontract VTokenStorage {\r\n    /**\r\n     * @dev Guard variable for re-entrancy checks\r\n     */\r\n    bool internal _notEntered;\r\n\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name;\r\n\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol;\r\n\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint8 public decimals;\r\n\r\n    /**\r\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\r\n     */\r\n\r\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\r\n\r\n    /**\r\n     * @notice Maximum fraction of interest that can be set aside for reserves\r\n     */\r\n    uint internal constant reserveFactorMaxMantissa = 1e18;\r\n\r\n    /**\r\n     * @notice Administrator for this contract\r\n     */\r\n    address payable public admin;\r\n\r\n    /**\r\n     * @notice Pending administrator for this contract\r\n     */\r\n    address payable public pendingAdmin;\r\n\r\n    /**\r\n     * @notice Contract which oversees inter-vToken operations\r\n     */\r\n    ComptrollerInterface public comptroller;\r\n\r\n    /**\r\n     * @notice Model which tells what the current interest rate should be\r\n     */\r\n    InterestRateModel public interestRateModel;\r\n\r\n    /**\r\n     * @notice Initial exchange rate used when minting the first VTokens (used when totalSupply = 0)\r\n     */\r\n    uint internal initialExchangeRateMantissa;\r\n\r\n    /**\r\n     * @notice Fraction of interest currently set aside for reserves\r\n     */\r\n    uint public reserveFactorMantissa;\r\n\r\n    /**\r\n     * @notice Block number that interest was last accrued at\r\n     */\r\n    uint public accrualBlockNumber;\r\n\r\n    /**\r\n     * @notice Accumulator of the total earned interest rate since the opening of the market\r\n     */\r\n    uint public borrowIndex;\r\n\r\n    /**\r\n     * @notice Total amount of outstanding borrows of the underlying in this market\r\n     */\r\n    uint public totalBorrows;\r\n\r\n    /**\r\n     * @notice Total amount of reserves of the underlying held in this market\r\n     */\r\n    uint public totalReserves;\r\n\r\n    /**\r\n     * @notice Total number of tokens in circulation\r\n     */\r\n    uint public totalSupply;\r\n\r\n    /**\r\n     * @notice Official record of token balances for each account\r\n     */\r\n    mapping (address => uint) internal accountTokens;\r\n\r\n    /**\r\n     * @notice Approved token transfer amounts on behalf of others\r\n     */\r\n    mapping (address => mapping (address => uint)) internal transferAllowances;\r\n\r\n    /**\r\n     * @notice Container for borrow balance information\r\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\r\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\r\n     */\r\n    struct BorrowSnapshot {\r\n        uint principal;\r\n        uint interestIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Mapping of account addresses to outstanding borrow balances\r\n     */\r\n    mapping(address => BorrowSnapshot) internal accountBorrows;\r\n}\r\n\r\ncontract VTokenInterface is VTokenStorage {\r\n    /**\r\n     * @notice Indicator that this is a VToken contract (for inspection)\r\n     */\r\n    bool public constant isVToken = true;\r\n\r\n\r\n    /*** Market Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when interest is accrued\r\n     */\r\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are minted\r\n     */\r\n    event Mint(address minter, uint mintAmount, uint mintTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are minted behalf by payer to receiver\r\n     */\r\n    event MintBehalf(address payer, address receiver, uint mintAmount, uint mintTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are redeemed\r\n     */\r\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are redeemed and fee are transferred\r\n     */\r\n    event RedeemFee(address redeemer, uint feeAmount, uint redeemTokens);\r\n\r\n    /**\r\n     * @notice Event emitted when underlying is borrowed\r\n     */\r\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is repaid\r\n     */\r\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\r\n\r\n    /**\r\n     * @notice Event emitted when a borrow is liquidated\r\n     */\r\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address vTokenCollateral, uint seizeTokens);\r\n\r\n\r\n    /*** Admin Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is changed\r\n     */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\r\n     */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @notice Event emitted when comptroller is changed\r\n     */\r\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\r\n\r\n    /**\r\n     * @notice Event emitted when interestRateModel is changed\r\n     */\r\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserve factor is changed\r\n     */\r\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are added\r\n     */\r\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice Event emitted when the reserves are reduced\r\n     */\r\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\r\n\r\n    /**\r\n     * @notice EIP20 Transfer event\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n    /**\r\n     * @notice EIP20 Approval event\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n\r\n    /**\r\n     * @notice Failure event\r\n     */\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n\r\n    /*** User Interface ***/\r\n\r\n    function transfer(address dst, uint amount) external returns (bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrowBalanceStored(address account) public view returns (uint);\r\n    function exchangeRateCurrent() public returns (uint);\r\n    function exchangeRateStored() public view returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function accrueInterest() public returns (uint);\r\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint);\r\n    function _acceptAdmin() external returns (uint);\r\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint);\r\n    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\r\n    function _reduceReserves(uint reduceAmount) external returns (uint);\r\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\r\n}\r\n\r\ncontract VBep20Storage {\r\n    /**\r\n     * @notice Underlying asset for this VToken\r\n     */\r\n    address public underlying;\r\n}\r\n\r\ncontract VBep20Interface is VBep20Storage {\r\n\r\n    /*** User Interface ***/\r\n\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function mintBehalf(address receiver, uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, VTokenInterface vTokenCollateral) external returns (uint);\r\n\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _addReserves(uint addAmount) external returns (uint);\r\n}\r\n\r\ncontract VDelegationStorage {\r\n    /**\r\n     * @notice Implementation address for this contract\r\n     */\r\n    address public implementation;\r\n}\r\n\r\ncontract VDelegatorInterface is VDelegationStorage {\r\n    /**\r\n     * @notice Emitted when implementation is changed\r\n     */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n     * @notice Called by the admin to update the implementation of the delegator\r\n     * @param implementation_ The address of the new implementation for delegation\r\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\r\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n     */\r\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public;\r\n}\r\n\r\ncontract VDelegateInterface is VDelegationStorage {\r\n    /**\r\n     * @notice Called by the delegator on a delegate to initialize it for duty\r\n     * @dev Should revert if any issues arise which make it unfit for delegation\r\n     * @param data The encoded bytes data for any initialization\r\n     */\r\n    function _becomeImplementation(bytes memory data) public;\r\n\r\n    /**\r\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\r\n     */\r\n    function _resignImplementation() public;\r\n}\r\n"
    },
    "contracts/VTreasury.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./Utils/IBEP20.sol\";\r\nimport \"./Utils/SafeBEP20.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n/**\r\n * @dev Contract for treasury all tokens as fee and transfer to governance\r\n */\r\ncontract VTreasury is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    // WithdrawTreasuryBEP20 Event\r\n    event WithdrawTreasuryBEP20(address tokenAddress, uint256 withdrawAmount, address withdrawAddress);\r\n\r\n    // WithdrawTreasuryBNB Event\r\n    event WithdrawTreasuryBNB(uint256 withdrawAmount, address withdrawAddress);\r\n\r\n    /**\r\n     * @notice To receive BNB\r\n     */\r\n    function () external payable {}\r\n\r\n    /**\r\n    * @notice Withdraw Treasury BEP20 Tokens, Only owner call it\r\n    * @param tokenAddress The address of treasury token\r\n    * @param withdrawAmount The withdraw amount to owner\r\n    * @param withdrawAddress The withdraw address\r\n    */\r\n    function withdrawTreasuryBEP20(\r\n      address tokenAddress,\r\n      uint256 withdrawAmount,\r\n      address withdrawAddress\r\n    ) external onlyOwner {\r\n        uint256 actualWithdrawAmount = withdrawAmount;\r\n        // Get Treasury Token Balance\r\n        uint256 treasuryBalance = IBEP20(tokenAddress).balanceOf(address(this));\r\n\r\n        // Check Withdraw Amount\r\n        if (withdrawAmount > treasuryBalance) {\r\n            // Update actualWithdrawAmount\r\n            actualWithdrawAmount = treasuryBalance;\r\n        }\r\n\r\n        // Transfer BEP20 Token to withdrawAddress\r\n        IBEP20(tokenAddress).safeTransfer(withdrawAddress, actualWithdrawAmount);\r\n\r\n        emit WithdrawTreasuryBEP20(tokenAddress, actualWithdrawAmount, withdrawAddress);\r\n    }\r\n\r\n    /**\r\n    * @notice Withdraw Treasury BNB, Only owner call it\r\n    * @param withdrawAmount The withdraw amount to owner\r\n    * @param withdrawAddress The withdraw address\r\n    */\r\n    function withdrawTreasuryBNB(\r\n      uint256 withdrawAmount,\r\n      address payable withdrawAddress\r\n    ) external payable onlyOwner {\r\n        uint256 actualWithdrawAmount = withdrawAmount;\r\n        // Get Treasury BNB Balance\r\n        uint256 bnbBalance = address(this).balance;\r\n\r\n        // Check Withdraw Amount\r\n        if (withdrawAmount > bnbBalance) {\r\n            // Update actualWithdrawAmount\r\n            actualWithdrawAmount = bnbBalance;\r\n        }\r\n        // Transfer BNB to withdrawAddress\r\n        withdrawAddress.transfer(actualWithdrawAmount);\r\n\r\n        emit WithdrawTreasuryBNB(actualWithdrawAmount, withdrawAddress);\r\n    }\r\n}\r\n"
    },
    "contracts/VXvsLikeDelegate.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./VBep20Delegate.sol\";\r\n\r\ninterface XvsLike {\r\n  function delegate(address delegatee) external;\r\n}\r\n\r\n/**\r\n * @title Venus's VXvsLikeDelegate Contract\r\n * @notice VTokens which can 'delegate votes' of their underlying BEP-20\r\n * @author Venus\r\n */\r\ncontract VXvsLikeDelegate is VBep20Delegate {\r\n  /**\r\n   * @notice Construct an empty delegate\r\n   */\r\n  constructor() public VBep20Delegate() {}\r\n\r\n  /**\r\n   * @notice Admin call to delegate the votes of the XVS-like underlying\r\n   * @param xvsLikeDelegatee The address to delegate votes to\r\n   */\r\n  function _delegateXvsLikeTo(address xvsLikeDelegatee) external {\r\n    require(msg.sender == admin, \"only the admin may set the xvs-like delegate\");\r\n    XvsLike(underlying).delegate(xvsLikeDelegatee);\r\n  }\r\n}"
    },
    "contracts/WhitePaperInterestRateModel.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./InterestRateModel.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n/**\r\n  * @title Venus's WhitePaperInterestRateModel Contract\r\n  * @author Venus\r\n  * @notice The parameterized model described in section 2.4 of the original Venus Protocol whitepaper\r\n  */\r\ncontract WhitePaperInterestRateModel is InterestRateModel {\r\n    using SafeMath for uint;\r\n\r\n    event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock);\r\n\r\n    /**\r\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\r\n     */\r\n    uint public constant blocksPerYear = 60 * 60 * 24 * 365 / 3; // (assuming 3s blocks)\r\n\r\n    /**\r\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\r\n     */\r\n    uint public multiplierPerBlock;\r\n\r\n    /**\r\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\r\n     */\r\n    uint public baseRatePerBlock;\r\n\r\n    /**\r\n     * @notice Construct an interest rate model\r\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\r\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\r\n     */\r\n    constructor(uint baseRatePerYear, uint multiplierPerYear) public {\r\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\r\n        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\r\n\r\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market (currently unused)\r\n     * @return The utilization rate as a mantissa between [0, 1e18]\r\n     */\r\n    function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\r\n        // Utilization rate is 0 when there are no borrows\r\n        if (borrows == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getBorrowRate(uint cash, uint borrows, uint reserves) public view returns (uint) {\r\n        uint ur = utilizationRate(cash, borrows, reserves);\r\n        return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current supply rate per block\r\n     * @param cash The amount of cash in the market\r\n     * @param borrows The amount of borrows in the market\r\n     * @param reserves The amount of reserves in the market\r\n     * @param reserveFactorMantissa The current reserve factor for the market\r\n     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\r\n     */\r\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) public view returns (uint) {\r\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactorMantissa);\r\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\r\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\r\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\r\n    }\r\n}\r\n"
    },
    "contracts/XVSVault/XVSStore.sol": {
      "content": "pragma solidity ^0.5.16;\r\nimport \"../Utils/SafeBEP20.sol\";\r\nimport \"../Utils/IBEP20.sol\";\r\n\r\ncontract XVSStore {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    /// @notice The Admin Address\r\n    address public admin;\r\n\r\n    /// @notice The pending admin address\r\n    address public pendingAdmin;\r\n\r\n    /// @notice The Owner Address\r\n    address public owner;\r\n\r\n    /// @notice The reward tokens\r\n    mapping(address => bool) public rewardTokens;\r\n\r\n    /// @notice Emitted when pendingAdmin is changed\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /// @notice Event emitted when admin changed\r\n    event AdminTransferred(address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    /// @notice Event emitted when owner changed\r\n    event OwnerTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner can\");\r\n        _;\r\n    }\r\n\r\n    // Safe reward token transfer function, just in case if rounding error causes pool to not have enough tokens.\r\n    function safeRewardTransfer(address token, address _to, uint256 _amount) external onlyOwner {\r\n        require(rewardTokens[token] == true, \"only reward token can\");\r\n\r\n        if (address(token) != address(0)) {\r\n            uint256 tokenBalance = IBEP20(token).balanceOf(address(this));\r\n            if (_amount > tokenBalance) {\r\n                IBEP20(token).safeTransfer(_to, tokenBalance);\r\n            } else {\r\n                IBEP20(token).safeTransfer(_to, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setPendingAdmin(address _admin) external onlyAdmin {\r\n        address oldPendingAdmin = pendingAdmin;\r\n        pendingAdmin = _admin;\r\n        emit NewPendingAdmin(oldPendingAdmin, _admin);\r\n    }\r\n\r\n    function acceptAdmin() external {\r\n        require(msg.sender == pendingAdmin, \"only pending admin\");\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n        emit AdminTransferred(oldAdmin, admin);\r\n    }\r\n\r\n    function setNewOwner(address _owner) external onlyAdmin {\r\n        require(_owner != address(0), \"new owner is the zero address\");\r\n        address oldOwner = owner;\r\n        owner = _owner;\r\n        emit OwnerTransferred(oldOwner, _owner);\r\n    }\r\n\r\n    function setRewardToken(address _tokenAddress, bool status) external {\r\n        require(msg.sender == admin || msg.sender == owner, \"only admin or owner can\");\r\n        rewardTokens[_tokenAddress] = status;\r\n    }\r\n\r\n    function emergencyRewardWithdraw(address _tokenAddress, uint256 _amount) external onlyOwner {\r\n        IBEP20(_tokenAddress).safeTransfer(address(msg.sender), _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/XVSVault/XVSVault.sol": {
      "content": "pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../Utils/ECDSA.sol\";\r\nimport \"../Utils/SafeBEP20.sol\";\r\nimport \"../Utils/IBEP20.sol\";\r\nimport \"./XVSVaultProxy.sol\";\r\nimport \"./XVSVaultStorage.sol\";\r\nimport \"./XVSVaultErrorReporter.sol\";\r\n\r\ninterface IXVSStore {\r\n    function safeRewardTransfer(address _token, address _to, uint256 _amount) external;\r\n    function setRewardToken(address _tokenAddress, bool status) external;\r\n}\r\n\r\ncontract XVSVault is XVSVaultStorage, ECDSA {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    /// @notice Event emitted when deposit\r\n    event Deposit(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\r\n\r\n    /// @notice Event emitted when execute withrawal\r\n    event ExecutedWithdrawal(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\r\n\r\n    /// @notice Event emitted when request withrawal\r\n    event ReqestedWithdrawal(address indexed user, address indexed rewardToken, uint256 indexed pid, uint256 amount);\r\n\r\n    /// @notice Event emitted when admin changed\r\n    event AdminTransferred(address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChangedV2(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChangedV2(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    /// @notice An event emitted when the reward store address is updated\r\n    event StoreUpdated(address oldXvs, address oldStore, address newXvs, address newStore);\r\n\r\n    /// @notice An event emitted when the withdrawal locking period is updated for a pool\r\n    event WithdrawalLockingPeriodUpdated(\r\n        address indexed rewardToken,\r\n        uint indexed pid,\r\n        uint oldPeriod,\r\n        uint newPeriod\r\n    );\r\n\r\n    /// @notice An event emitted when the reward amount per block is modified for a pool\r\n    event RewardAmountUpdated(address indexed rewardToken, uint oldReward, uint newReward);\r\n\r\n    /// @notice An event emitted when a new pool is added\r\n    event PoolAdded(\r\n        address indexed rewardToken,\r\n        uint indexed pid,\r\n        address indexed token,\r\n        uint allocPoints,\r\n        uint rewardPerBlock,\r\n        uint lockPeriod\r\n    );\r\n\r\n    /// @notice An event emitted when a pool allocation points are updated\r\n    event PoolUpdated(\r\n        address indexed rewardToken,\r\n        uint indexed pid,\r\n        uint oldAllocPoints,\r\n        uint newAllocPoints\r\n    );\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"only admin can\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true; // get a gas-refund post-Istanbul\r\n    }\r\n\r\n    function poolLength(address rewardToken) external view returns (uint256) {\r\n        return poolInfos[rewardToken].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new token pool. Can only be called by the admin.\r\n     * @dev This vault DOES NOT support deflationary tokens — it expects that\r\n     *   the amount of transferred tokens would equal the actually deposited\r\n     *   amount. In practice this means that this vault DOES NOT support USDT\r\n     *   and similar tokens (that do not provide these guarantees).\r\n     */\r\n    function add(\r\n        address _rewardToken,\r\n        uint256 _allocPoint,\r\n        IBEP20 _token,\r\n        uint256 _rewardPerBlock,\r\n        uint256 _lockPeriod\r\n    )\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(address(xvsStore) != address(0), \"Store contract addres is empty\");\r\n\r\n        massUpdatePools(_rewardToken);\r\n\r\n        PoolInfo[] storage poolInfo = poolInfos[_rewardToken];\r\n\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            require(poolInfo[pid].token != _token, \"Error pool already added\");\r\n        }\r\n\r\n        totalAllocPoints[_rewardToken] = totalAllocPoints[_rewardToken].add(_allocPoint);\r\n\r\n        rewardTokenAmountsPerBlock[_rewardToken] = _rewardPerBlock;\r\n\r\n        poolInfo.push(\r\n            PoolInfo({\r\n                token: _token,\r\n                allocPoint: _allocPoint,\r\n                lastRewardBlock: block.number,\r\n                accRewardPerShare: 0,\r\n                lockPeriod: _lockPeriod\r\n            })\r\n        );\r\n\r\n        IXVSStore(xvsStore).setRewardToken(_rewardToken, true);\r\n\r\n        emit PoolAdded(\r\n            _rewardToken,\r\n            poolInfo.length - 1,\r\n            address(_token),\r\n            _allocPoint,\r\n            _rewardPerBlock,\r\n            _lockPeriod\r\n        );\r\n    }\r\n\r\n    // Update the given pool's reward allocation point. Can only be called by the admin.\r\n    function set(\r\n        address _rewardToken,\r\n        uint256 _pid,\r\n        uint256 _allocPoint\r\n    )\r\n        external\r\n        onlyAdmin\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        massUpdatePools(_rewardToken);\r\n\r\n        PoolInfo[] storage poolInfo = poolInfos[_rewardToken];\r\n        totalAllocPoints[_rewardToken] = totalAllocPoints[_rewardToken].sub(poolInfo[_pid].allocPoint).add(\r\n            _allocPoint\r\n        );\r\n        uint256 oldAllocPoints = poolInfo[_pid].allocPoint;\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n\r\n        emit PoolUpdated(_rewardToken, _pid, oldAllocPoints, _allocPoint);\r\n    }\r\n\r\n    // Update the given reward token's amount per block\r\n    function setRewardAmountPerBlock(\r\n        address _rewardToken,\r\n        uint256 _rewardAmount\r\n    )\r\n        external\r\n        onlyAdmin\r\n    {\r\n        massUpdatePools(_rewardToken);\r\n        uint256 oldReward = rewardTokenAmountsPerBlock[_rewardToken];\r\n        rewardTokenAmountsPerBlock[_rewardToken] = _rewardAmount;\r\n\r\n        emit RewardAmountUpdated(_rewardToken, oldReward, _rewardAmount);\r\n    }\r\n\r\n    // Update the given reward token's amount per block\r\n    function setWithdrawalLockingPeriod(\r\n        address _rewardToken,\r\n        uint256 _pid,\r\n        uint256 _newPeriod\r\n    )\r\n        external\r\n        onlyAdmin\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        require(_newPeriod > 0, \"Invalid new locking period\");\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        uint256 oldPeriod = pool.lockPeriod;\r\n        pool.lockPeriod = _newPeriod;\r\n\r\n        emit WithdrawalLockingPeriodUpdated(_rewardToken, _pid, oldPeriod, _newPeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit XVSVault for XVS allocation\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _amount The amount to deposit to vault\r\n     */\r\n    function deposit(address _rewardToken, uint256 _pid, uint256 _amount)\r\n        external\r\n        nonReentrant\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\r\n        _updatePool(_rewardToken, _pid);\r\n        if (user.amount > 0) {\r\n            uint256 pending =\r\n                user.amount.mul(pool.accRewardPerShare).div(1e12).sub(\r\n                    user.rewardDebt\r\n                );\r\n            IXVSStore(xvsStore).safeRewardTransfer(_rewardToken, msg.sender, pending);\r\n        }\r\n        pool.token.safeTransferFrom(\r\n            address(msg.sender),\r\n            address(this),\r\n            _amount\r\n        );\r\n        user.amount = user.amount.add(_amount);\r\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\r\n\r\n        // Update Delegate Amount\r\n        if (address(pool.token) == address(xvsAddress)) {\r\n            _moveDelegates(address(0), delegates[msg.sender], uint96(_amount));\r\n        }\r\n\r\n        emit Deposit(msg.sender, _rewardToken, _pid, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Pushes withdrawal request to the requests array and updates\r\n     *   the pending withdrawals amount. The requests are always sorted\r\n     *   by unlock time (descending) so that the earliest to execute requests\r\n     *   are always at the end of the array.\r\n     * @param _user The user struct storage pointer\r\n     * @param _requests The user's requests array storage pointer\r\n     * @param _amount The amount being requested\r\n     */\r\n    function pushWithdrawalRequest(\r\n        UserInfo storage _user,\r\n        WithdrawalRequest[] storage _requests,\r\n        uint _amount,\r\n        uint _lockedUntil\r\n    )\r\n        internal\r\n    {\r\n        uint i = _requests.length;\r\n        _requests.push(WithdrawalRequest(0, 0));\r\n        // Keep it sorted so that the first to get unlocked request is always at the end\r\n        for (; i > 0 && _requests[i - 1].lockedUntil <= _lockedUntil; --i) {\r\n            _requests[i] = _requests[i - 1];\r\n        }\r\n        _requests[i] = WithdrawalRequest(_amount, _lockedUntil);\r\n        _user.pendingWithdrawals = _user.pendingWithdrawals.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Pops the requests with unlock time < now from the requests\r\n     *   array and deducts the computed amount from the user's pending\r\n     *   withdrawals counter. Assumes that the requests array is sorted\r\n     *   by unclock time (descending).\r\n     * @dev This function **removes** the eligible requests from the requests\r\n     *   array. If this function is called, the withdrawal should actually\r\n     *   happen (or the transaction should be reverted).\r\n     * @param _user The user struct storage pointer\r\n     * @param _requests The user's requests array storage pointer\r\n     * @return The amount eligible for withdrawal (this amount should be\r\n     *   sent to the user, otherwise the state would be inconsistent).\r\n     */\r\n    function popEligibleWithdrawalRequests(\r\n        UserInfo storage _user,\r\n        WithdrawalRequest[] storage _requests\r\n    )\r\n        internal\r\n        returns (uint withdrawalAmount)\r\n    {\r\n        // Since the requests are sorted by their unlock time, we can just\r\n        // pop them from the array and stop at the first not-yet-eligible one\r\n        for (uint i = _requests.length; i > 0 && isUnlocked(_requests[i - 1]); --i) {\r\n            withdrawalAmount = withdrawalAmount.add(_requests[i - 1].amount);\r\n            _requests.pop();\r\n        }\r\n        _user.pendingWithdrawals = _user.pendingWithdrawals.sub(withdrawalAmount);\r\n        return withdrawalAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the request is eligible for withdrawal.\r\n     * @param _request The request struct storage pointer\r\n     * @return True if the request is eligible for withdrawal, false otherwise\r\n     */\r\n    function isUnlocked(WithdrawalRequest storage _request) private view returns (bool) {\r\n        return _request.lockedUntil <= block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Execute withdrawal to XVSVault for XVS allocation\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     */\r\n    function executeWithdrawal(address _rewardToken, uint256 _pid)\r\n        external\r\n        nonReentrant\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\r\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][msg.sender];\r\n\r\n        uint256 _amount = popEligibleWithdrawalRequests(user, requests);\r\n        require(_amount > 0, \"nothing to withdraw\");\r\n\r\n        _updatePool(_rewardToken, _pid);\r\n        uint256 pending =\r\n            user.amount.mul(pool.accRewardPerShare).div(1e12).sub(\r\n                user.rewardDebt\r\n            );\r\n        IXVSStore(xvsStore).safeRewardTransfer(_rewardToken, msg.sender, pending);\r\n        user.amount = user.amount.sub(_amount);\r\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\r\n        pool.token.safeTransfer(address(msg.sender), _amount);\r\n\r\n        emit ExecutedWithdrawal(msg.sender, _rewardToken, _pid, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Request withdrawal to XVSVault for XVS allocation\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _amount The amount to withdraw to vault\r\n     */\r\n    function requestWithdrawal(address _rewardToken, uint256 _pid, uint256 _amount)\r\n        external\r\n        nonReentrant\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        require(_amount > 0, \"requested amount cannot be zero\");\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][msg.sender];\r\n        require(user.amount >= user.pendingWithdrawals.add(_amount), \"requested amount is invalid\");\r\n\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][msg.sender];\r\n        uint lockedUntil = pool.lockPeriod.add(block.timestamp);\r\n\r\n        pushWithdrawalRequest(user, requests, _amount, lockedUntil);\r\n\r\n        // Update Delegate Amount\r\n        if (_rewardToken == address(xvsAddress)) {\r\n            _moveDelegates(delegates[msg.sender], address(0), uint96(_amount));\r\n        }\r\n\r\n        emit ReqestedWithdrawal(msg.sender, _rewardToken, _pid, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Get unlocked withdrawal amount\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _user The User Address\r\n     */\r\n    function getEligibleWithdrawalAmount(address _rewardToken, uint256 _pid, address _user)\r\n        external\r\n        view\r\n        returns (uint withdrawalAmount)\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        WithdrawalRequest[] storage requests = withdrawalRequests[_rewardToken][_pid][_user];\r\n        // Since the requests are sorted by their unlock time, we can take\r\n        // the entries from the end of the array and stop at the first\r\n        // not-yet-eligible one\r\n        for (uint i = requests.length; i > 0 && isUnlocked(requests[i - 1]); --i) {\r\n            withdrawalAmount = withdrawalAmount.add(requests[i - 1].amount);\r\n        }\r\n        return withdrawalAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Get requested amount\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _user The User Address\r\n     */\r\n    function getRequestedAmount(address _rewardToken, uint256 _pid, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\r\n        return user.pendingWithdrawals;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the array of withdrawal requests that have not been executed yet\r\n     * @param _rewardToken The Reward Token Address\r\n     * @param _pid The Pool Index\r\n     * @param _user The User Address\r\n     */\r\n    function getWithdrawalRequests(address _rewardToken, uint256 _pid, address _user)\r\n        external\r\n        view\r\n        returns (WithdrawalRequest[] memory)\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        return withdrawalRequests[_rewardToken][_pid][_user];\r\n    }\r\n\r\n    // View function to see pending XVSs on frontend.\r\n    function pendingReward(address _rewardToken, uint256 _pid, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\r\n        uint256 accRewardPerShare = pool.accRewardPerShare;\r\n        uint256 supply = pool.token.balanceOf(address(this));\r\n        uint256 curBlockNumber = block.number;\r\n        uint256 rewardTokenPerBlock = rewardTokenAmountsPerBlock[_rewardToken];\r\n        if (curBlockNumber > pool.lastRewardBlock && supply != 0) {\r\n            uint256 multiplier = curBlockNumber.sub(pool.lastRewardBlock);\r\n            uint256 reward =\r\n                multiplier.mul(rewardTokenPerBlock).mul(pool.allocPoint).div(\r\n                    totalAllocPoints[_rewardToken]\r\n                );\r\n            accRewardPerShare = accRewardPerShare.add(\r\n                reward.mul(1e12).div(supply)\r\n            );\r\n        }\r\n        return user.amount.mul(accRewardPerShare).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward vairables for all pools. Be careful of gas spending!\r\n    function massUpdatePools(address _rewardToken) public {\r\n        uint256 length = poolInfos[_rewardToken].length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            _updatePool(_rewardToken, pid);\r\n        }\r\n    }\r\n\r\n    function updatePool(address _rewardToken, uint256 _pid)\r\n        external\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        _updatePool(_rewardToken, _pid);\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function _updatePool(address _rewardToken, uint256 _pid)\r\n        internal\r\n    {\r\n        PoolInfo storage pool = poolInfos[_rewardToken][_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 supply = pool.token.balanceOf(address(this));\r\n        if (supply == 0) {\r\n            pool.lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 curBlockNumber = block.number;\r\n        uint256 multiplier = curBlockNumber.sub(pool.lastRewardBlock);\r\n        uint256 reward =\r\n            multiplier.mul(rewardTokenAmountsPerBlock[_rewardToken]).mul(pool.allocPoint).div(\r\n                totalAllocPoints[_rewardToken]\r\n            );\r\n        pool.accRewardPerShare = pool.accRewardPerShare.add(\r\n            reward.mul(1e12).div(supply)\r\n        );\r\n        pool.lastRewardBlock = block.number;\r\n    }\r\n\r\n    function _ensureValidPool(address rewardToken, uint256 pid) internal view {\r\n        require(pid < poolInfos[rewardToken].length , \"vault: pool exists?\");\r\n    }\r\n\r\n    // Get user info with reward token address and pid\r\n    function getUserInfo(\r\n        address _rewardToken,\r\n        uint256 _pid,\r\n        address _user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 rewardDebt, uint256 pendingWithdrawals)\r\n    {\r\n        _ensureValidPool(_rewardToken, _pid);\r\n        UserInfo storage user = userInfos[_rewardToken][_pid][_user];\r\n        amount = user.amount;\r\n        rewardDebt = user.rewardDebt;\r\n        pendingWithdrawals = user.pendingWithdrawals;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the XVS stake balance of an account (excluding the pending withdrawals)\r\n     * @param account The address of the account to check\r\n     * @return The balance that user staked\r\n     */\r\n    function getStakeAmount(address account) internal view returns (uint96) {\r\n        require(xvsAddress != address(0), \"XVSVault::getStakeAmount: xvs address is not set\");\r\n\r\n        PoolInfo[] storage poolInfo = poolInfos[xvsAddress];\r\n\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            if (address(poolInfo[pid].token) == address(xvsAddress)) {\r\n                UserInfo storage user = userInfos[xvsAddress][pid][account];\r\n                return uint96(user.amount.sub(user.pendingWithdrawals));\r\n            }\r\n        }\r\n        return uint96(0);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     */\r\n    function delegate(address delegatee) external {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s)\r\n        external\r\n    {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"XVSVault\")), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ECDSA.recover(digest, v, r, s);\r\n        require(nonce == nonces[signatory]++, \"XVSVault::delegateBySig: invalid nonce\");\r\n        require(block.timestamp <= expiry, \"XVSVault::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint96) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = delegates[delegator];\r\n        uint96 delegatorBalance = getStakeAmount(delegator);\r\n        delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChangedV2(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"XVSVault::_moveVotes: vote amount underflows\");\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint96 dstRepNew = add96(dstRepOld, amount, \"XVSVault::_moveVotes: vote amount overflows\");\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\r\n        uint32 blockNumber = safe32(block.number, \"XVSVault::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChangedV2(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\r\n        require(n < 2**96, errorMessage);\r\n        return uint96(n);\r\n    }\r\n\r\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        uint96 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the xvs stake balance for an account\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The balance that user staked\r\n     */\r\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\r\n        require(blockNumber < block.number, \"XVSVault::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current admin\r\n     */\r\n    function getAdmin() external view returns (address) {\r\n        return admin;\r\n    }\r\n\r\n    /**\r\n     * @dev Burn the current admin\r\n     */\r\n    function burnAdmin() external onlyAdmin {\r\n        emit AdminTransferred(admin, address(0));\r\n        admin = address(0);\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n\r\n    function _become(XVSVaultProxy xvsVaultProxy) external {\r\n        require(msg.sender == xvsVaultProxy.admin(), \"only proxy admin can change brains\");\r\n        require(xvsVaultProxy._acceptImplementation() == 0, \"change not authorized\");\r\n    }\r\n\r\n    function setXvsStore(address _xvs, address _xvsStore) external onlyAdmin {\r\n        address oldXvsContract = xvsAddress;\r\n        address oldStore = xvsStore;\r\n        xvsAddress = _xvs;\r\n        xvsStore = _xvsStore;\r\n\r\n        _notEntered = true;\r\n\r\n        emit StoreUpdated(oldXvsContract, oldStore, _xvs, _xvsStore);\r\n    }\r\n}\r\n"
    },
    "contracts/XVSVault/XVSVaultErrorReporter.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\ncontract XVSVaultErrorReporter {\r\n    enum Error {\r\n        NO_ERROR,\r\n        UNAUTHORIZED\r\n    }\r\n\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK\r\n    }\r\n\r\n    /**\r\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n      **/\r\n    event Failure(uint error, uint info, uint detail);\r\n\r\n    /**\r\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n      */\r\n    function fail(Error err, FailureInfo info) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), 0);\r\n\r\n        return uint(err);\r\n    }\r\n\r\n    /**\r\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n      */\r\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\r\n        emit Failure(uint(err), uint(info), opaqueError);\r\n\r\n        return uint(err);\r\n    }\r\n}\r\n"
    },
    "contracts/XVSVault/XVSVaultProxy.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nimport \"./XVSVaultStorage.sol\";\r\nimport \"./XVSVaultErrorReporter.sol\";\r\n\r\ncontract XVSVaultProxy is XVSVaultAdminStorage, XVSVaultErrorReporter {\r\n\r\n    /**\r\n      * @notice Emitted when pendingXVSVaultImplementation is changed\r\n      */\r\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingXVSVaultImplementation is accepted, which means XVS Vault implementation is updated\r\n      */\r\n    event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is changed\r\n      */\r\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n    /**\r\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n      */\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n    constructor() public {\r\n        // Set admin to caller\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /*** Admin Functions ***/\r\n    function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\r\n\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\r\n        }\r\n\r\n        address oldPendingImplementation = pendingXVSVaultImplementation;\r\n\r\n        pendingXVSVaultImplementation = newPendingImplementation;\r\n\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingXVSVaultImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n    * @notice Accepts new implementation of XVS Vault. msg.sender must be pendingImplementation\r\n    * @dev Admin function for new implementation to accept it's role as implementation\r\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n    */\r\n    function _acceptImplementation() public returns (uint) {\r\n        // Check caller is pendingImplementation\r\n        if (msg.sender != pendingXVSVaultImplementation) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldImplementation = implementation;\r\n        address oldPendingImplementation = pendingXVSVaultImplementation;\r\n\r\n        implementation = pendingXVSVaultImplementation;\r\n\r\n        pendingXVSVaultImplementation = address(0);\r\n\r\n        emit NewImplementation(oldImplementation, implementation);\r\n        emit NewPendingImplementation(oldPendingImplementation, pendingXVSVaultImplementation);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n      * @param newPendingAdmin New pending admin.\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\r\n        // Check caller = admin\r\n        if (msg.sender != admin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store pendingAdmin with value newPendingAdmin\r\n        pendingAdmin = newPendingAdmin;\r\n\r\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\r\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n      * @dev Admin function for pending admin to accept role and update admin\r\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n      */\r\n    function _acceptAdmin() public returns (uint) {\r\n        // Check caller is pendingAdmin\r\n        if (msg.sender != pendingAdmin) {\r\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n        }\r\n\r\n        // Save current values for inclusion in log\r\n        address oldAdmin = admin;\r\n        address oldPendingAdmin = pendingAdmin;\r\n\r\n        // Store admin with value pendingAdmin\r\n        admin = pendingAdmin;\r\n\r\n        // Clear the pending value\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(oldAdmin, admin);\r\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n        return uint(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * It returns to the external caller whatever the implementation returns\r\n     * or forwards reverts.\r\n     */\r\n    function () external payable {\r\n        // delegate all other functions to current implementation\r\n        (bool success, ) = implementation.delegatecall(msg.data);\r\n\r\n        assembly {\r\n              let free_mem_ptr := mload(0x40)\r\n              returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n              switch success\r\n              case 0 { revert(free_mem_ptr, returndatasize) }\r\n              default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/XVSVault/XVSVaultStorage.sol": {
      "content": "pragma solidity ^0.5.16;\r\nimport \"../Utils/SafeMath.sol\";\r\nimport \"../Utils/IBEP20.sol\";\r\n\r\ncontract XVSVaultAdminStorage {\r\n    /**\r\n    * @notice Administrator for this contract\r\n    */\r\n    address public admin;\r\n\r\n    /**\r\n    * @notice Pending administrator for this contract\r\n    */\r\n    address public pendingAdmin;\r\n\r\n    /**\r\n    * @notice Active brains of XVS Vault\r\n    */\r\n    address public implementation;\r\n\r\n    /**\r\n    * @notice Pending brains of XVS Vault\r\n    */\r\n    address public pendingXVSVaultImplementation;\r\n}\r\n\r\ncontract XVSVaultStorageV1 is XVSVaultAdminStorage {\r\n    /// @notice Guard variable for re-entrancy checks\r\n    bool internal _notEntered;\r\n\r\n    /// @notice The reward token store\r\n    address public xvsStore;\r\n\r\n    /// @notice The xvs token address\r\n    address public xvsAddress;\r\n\r\n    // Reward tokens created per block indentified by reward token address.\r\n    mapping(address => uint256) public rewardTokenAmountsPerBlock;\r\n\r\n    /// @notice Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 rewardDebt;\r\n        uint256 pendingWithdrawals;\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IBEP20 token;               // Address of token contract to stake.\r\n        uint256 allocPoint;         // How many allocation points assigned to this pool.\r\n        uint256 lastRewardBlock;    // Last block number that reward tokens distribution occurs.\r\n        uint256 accRewardPerShare;  // Accumulated per share, times 1e12. See below.\r\n        uint256 lockPeriod;         // Min time between withdrawal request and its execution.\r\n    }\r\n\r\n    // Infomation about a withdrawal request\r\n    struct WithdrawalRequest {\r\n        uint256 amount;\r\n        uint256 lockedUntil;\r\n    }\r\n\r\n    // Info of each user that stakes tokens.\r\n    mapping(address => mapping(uint256 => mapping(address => UserInfo))) userInfos;\r\n\r\n    // Info of each pool.\r\n    mapping(address => PoolInfo[]) public poolInfos;\r\n\r\n    // Total allocation points. Must be the sum of all allocation points in all pools.\r\n    mapping(address => uint256) public totalAllocPoints;\r\n\r\n    // Info of requested but not yet executed withdrawals\r\n    mapping(address => mapping(uint256 => mapping(address => WithdrawalRequest[]))) withdrawalRequests;\r\n\r\n    /// @notice DEPRECATED A record of each accounts delegate (before the voting power fix)\r\n    mapping (address => address) private __oldDelegatesSlot;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint96 votes;\r\n    }\r\n\r\n    /// @notice DEPRECATED A record of votes checkpoints for each account, by index (before the voting power fix)\r\n    mapping (address => mapping (uint32 => Checkpoint)) private __oldCheckpointsSlot;\r\n\r\n    /// @notice DEPRECATED The number of checkpoints for each account (before the voting power fix)\r\n    mapping (address => uint32) private __oldNumCheckpointsSlot;\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n}\r\n\r\ncontract XVSVaultStorage is XVSVaultStorageV1 {\r\n    /// @notice A record of each accounts delegate\r\n    mapping (address => address) public delegates;\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}